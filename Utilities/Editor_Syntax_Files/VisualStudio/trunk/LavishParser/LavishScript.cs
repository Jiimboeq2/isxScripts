//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Grammars\\LavishScript.g 2012-04-20 03:47:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class LavishScript : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARG", "And", "Assign", "Atom", "Band", "Bnegate", "Bor", "COMMAND", "COMMENT", "CONDITION", "Case", "CodeBlock", "Colon", "Comma", "Comparer", "DataCommand", "DeclareVariable", "Default", "Define", "Div", "Do", "Dollar", "Dot", "ESC_SEQ", "EXPONENT", "Echo", "Elipse", "Else", "ElseIf", "EndIf", "EndMac", "EqualTo", "Error", "FLOAT", "For", "Function", "GreaterThan", "GreaterThanEqual", "HEX_DIGIT", "ID", "INT", "If", "IfDef", "IfNDef", "Include", "Inherits", "LCurly", "LParen", "LSquare", "LeftShift", "LessThan", "LessThanEqual", "MATH", "Macro", "Member", "Method", "Minus", "Modu", "Mult", "Negate", "NewLine", "NotEqualTo", "OCTAL_ESC", "ObjectDef", "Or", "Other", "Param", "Params", "Plus", "PreElse", "PreElseIf", "PreIf", "Quote", "RCurly", "RParen", "RSquare", "Returns", "RightShift", "STRING", "Scope", "Script", "Semi", "Switch", "Type", "UNICODE_ESC", "Unmac", "Variable", "VariableCase", "WS", "While", "Xor"
	};
	public const int EOF=-1;
	public const int ARG=4;
	public const int And=5;
	public const int Assign=6;
	public const int Atom=7;
	public const int Band=8;
	public const int Bnegate=9;
	public const int Bor=10;
	public const int COMMAND=11;
	public const int COMMENT=12;
	public const int CONDITION=13;
	public const int Case=14;
	public const int CodeBlock=15;
	public const int Colon=16;
	public const int Comma=17;
	public const int Comparer=18;
	public const int DataCommand=19;
	public const int DeclareVariable=20;
	public const int Default=21;
	public const int Define=22;
	public const int Div=23;
	public const int Do=24;
	public const int Dollar=25;
	public const int Dot=26;
	public const int ESC_SEQ=27;
	public const int EXPONENT=28;
	public const int Echo=29;
	public const int Elipse=30;
	public const int Else=31;
	public const int ElseIf=32;
	public const int EndIf=33;
	public const int EndMac=34;
	public const int EqualTo=35;
	public const int Error=36;
	public const int FLOAT=37;
	public const int For=38;
	public const int Function=39;
	public const int GreaterThan=40;
	public const int GreaterThanEqual=41;
	public const int HEX_DIGIT=42;
	public const int ID=43;
	public const int INT=44;
	public const int If=45;
	public const int IfDef=46;
	public const int IfNDef=47;
	public const int Include=48;
	public const int Inherits=49;
	public const int LCurly=50;
	public const int LParen=51;
	public const int LSquare=52;
	public const int LeftShift=53;
	public const int LessThan=54;
	public const int LessThanEqual=55;
	public const int MATH=56;
	public const int Macro=57;
	public const int Member=58;
	public const int Method=59;
	public const int Minus=60;
	public const int Modu=61;
	public const int Mult=62;
	public const int Negate=63;
	public const int NewLine=64;
	public const int NotEqualTo=65;
	public const int OCTAL_ESC=66;
	public const int ObjectDef=67;
	public const int Or=68;
	public const int Other=69;
	public const int Param=70;
	public const int Params=71;
	public const int Plus=72;
	public const int PreElse=73;
	public const int PreElseIf=74;
	public const int PreIf=75;
	public const int Quote=76;
	public const int RCurly=77;
	public const int RParen=78;
	public const int RSquare=79;
	public const int Returns=80;
	public const int RightShift=81;
	public const int STRING=82;
	public const int Scope=83;
	public const int Script=84;
	public const int Semi=85;
	public const int Switch=86;
	public const int Type=87;
	public const int UNICODE_ESC=88;
	public const int Unmac=89;
	public const int Variable=90;
	public const int VariableCase=91;
	public const int WS=92;
	public const int While=93;
	public const int Xor=94;

	public LavishScript(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public LavishScript(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return LavishScript.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\LavishScript.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();
	// $ANTLR start "script"
	// Grammars\\LavishScript.g:8:8: public script : ( NewLine )* scriptStructure ( ( NewLine )+ scriptStructure )* ( NewLine )? -> ( scriptStructure )+ ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<CommonTree, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NewLine1 = default(IToken);
		IToken NewLine3 = default(IToken);
		IToken NewLine5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> scriptStructure2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> scriptStructure4 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NewLine1_tree = default(CommonTree);
		CommonTree NewLine3_tree = default(CommonTree);
		CommonTree NewLine5_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleSubtreeStream stream_scriptStructure=new RewriteRuleSubtreeStream(adaptor,"rule scriptStructure");
		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(8, 1);
		try
		{
			// Grammars\\LavishScript.g:8:15: ( ( NewLine )* scriptStructure ( ( NewLine )+ scriptStructure )* ( NewLine )? -> ( scriptStructure )+ )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:8:17: ( NewLine )* scriptStructure ( ( NewLine )+ scriptStructure )* ( NewLine )?
			{
			DebugLocation(8, 17);
			// Grammars\\LavishScript.g:8:17: ( NewLine )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==NewLine))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:8:17: NewLine
					{
					DebugLocation(8, 17);
					NewLine1=(IToken)Match(input,NewLine,Follow._NewLine_in_script41); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_NewLine.Add(NewLine1);


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(8, 26);
			PushFollow(Follow._scriptStructure_in_script44);
			scriptStructure2=scriptStructure();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_scriptStructure.Add(scriptStructure2.Tree);
			DebugLocation(8, 42);
			// Grammars\\LavishScript.g:8:42: ( ( NewLine )+ scriptStructure )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==NewLine))
				{
					int LA3_2 = input.LA(2);

					if ((LA3_2==Atom||LA3_2==Define||LA3_2==Echo||LA3_2==Error||LA3_2==Function||(LA3_2>=IfDef && LA3_2<=Include)||LA3_2==Macro||LA3_2==NewLine||LA3_2==ObjectDef||LA3_2==PreIf||(LA3_2>=Unmac && LA3_2<=Variable)))
					{
						alt3 = 1;
					}


				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:8:43: ( NewLine )+ scriptStructure
					{
					DebugLocation(8, 43);
					// Grammars\\LavishScript.g:8:43: ( NewLine )+
					int cnt2=0;
					try { DebugEnterSubRule(2);
					while (true)
					{
						int alt2=2;
						try { DebugEnterDecision(2, false);
						int LA2_1 = input.LA(1);

						if ((LA2_1==NewLine))
						{
							alt2 = 1;
						}


						} finally { DebugExitDecision(2); }
						switch (alt2)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LavishScript.g:8:43: NewLine
							{
							DebugLocation(8, 43);
							NewLine3=(IToken)Match(input,NewLine,Follow._NewLine_in_script47); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_NewLine.Add(NewLine3);


							}
							break;

						default:
							if (cnt2 >= 1)
								goto loop2;

							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee2 = new EarlyExitException( 2, input );
							DebugRecognitionException(eee2);
							throw eee2;
						}
						cnt2++;
					}
					loop2:
						;

					} finally { DebugExitSubRule(2); }

					DebugLocation(8, 52);
					PushFollow(Follow._scriptStructure_in_script50);
					scriptStructure4=scriptStructure();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_scriptStructure.Add(scriptStructure4.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(8, 70);
			// Grammars\\LavishScript.g:8:70: ( NewLine )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==NewLine))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:8:70: NewLine
				{
				DebugLocation(8, 70);
				NewLine5=(IToken)Match(input,NewLine,Follow._NewLine_in_script54); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NewLine.Add(NewLine5);


				}
				break;

			}
			} finally { DebugExitSubRule(4); }



			{
			// AST REWRITE
			// elements: scriptStructure
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 8:78: -> ( scriptStructure )+
			{
				DebugLocation(8, 80);
				if (!(stream_scriptStructure.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_scriptStructure.HasNext )
				{
					DebugLocation(8, 80);
					adaptor.AddChild(root_0, stream_scriptStructure.NextTree());

				}
				stream_scriptStructure.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(9, 1);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_scriptStructure();
	partial void LeaveRule_scriptStructure();
	// $ANTLR start "scriptStructure"
	// Grammars\\LavishScript.g:11:8: public scriptStructure : ( variableDeclare | function | atom | objectDef | preProcessor );
	[GrammarRule("scriptStructure")]
	public AstParserRuleReturnScope<CommonTree, IToken> scriptStructure()
	{
		EnterRule_scriptStructure();
		EnterRule("scriptStructure", 2);
		TraceIn("scriptStructure", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> variableDeclare6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> function7 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> atom8 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> objectDef9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> preProcessor10 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "scriptStructure");
		DebugLocation(11, 1);
		try
		{
			// Grammars\\LavishScript.g:12:2: ( variableDeclare | function | atom | objectDef | preProcessor )
			int alt5=5;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case Variable:
				{
				alt5 = 1;
				}
				break;
			case Function:
				{
				alt5 = 2;
				}
				break;
			case Atom:
				{
				alt5 = 3;
				}
				break;
			case ObjectDef:
				{
				alt5 = 4;
				}
				break;
			case Define:
			case Echo:
			case Error:
			case IfDef:
			case IfNDef:
			case Include:
			case Macro:
			case PreIf:
			case Unmac:
				{
				alt5 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:12:4: variableDeclare
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(12, 4);
				PushFollow(Follow._variableDeclare_in_scriptStructure71);
				variableDeclare6=variableDeclare();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclare6.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:12:20: function
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(12, 20);
				PushFollow(Follow._function_in_scriptStructure73);
				function7=function();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function7.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:12:29: atom
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(12, 29);
				PushFollow(Follow._atom_in_scriptStructure75);
				atom8=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom8.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:12:34: objectDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(12, 34);
				PushFollow(Follow._objectDef_in_scriptStructure77);
				objectDef9=objectDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectDef9.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishScript.g:12:44: preProcessor
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(12, 44);
				PushFollow(Follow._preProcessor_in_scriptStructure79);
				preProcessor10=preProcessor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, preProcessor10.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("scriptStructure", 2);
			LeaveRule("scriptStructure", 2);
			LeaveRule_scriptStructure();
		}
		DebugLocation(13, 1);
		} finally { DebugExitRule(GrammarFileName, "scriptStructure"); }
		return retval;

	}
	// $ANTLR end "scriptStructure"

	partial void EnterRule_preProcessor();
	partial void LeaveRule_preProcessor();
	// $ANTLR start "preProcessor"
	// Grammars\\LavishScript.g:15:8: public preProcessor : ( ( include )=> include | define | macro | preIf | ifDef | ifNDef | echo | error | unmac );
	[GrammarRule("preProcessor")]
	public AstParserRuleReturnScope<CommonTree, IToken> preProcessor()
	{
		EnterRule_preProcessor();
		EnterRule("preProcessor", 3);
		TraceIn("preProcessor", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> include11 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> define12 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> macro13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> preIf14 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifDef15 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifNDef16 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> echo17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> error18 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unmac19 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "preProcessor");
		DebugLocation(15, 1);
		try
		{
			// Grammars\\LavishScript.g:16:2: ( ( include )=> include | define | macro | preIf | ifDef | ifNDef | echo | error | unmac )
			int alt6=9;
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==Include) && (EvaluatePredicate(synpred1_LavishScript_fragment)))
			{
				alt6 = 1;
			}
			else if ((LA6_1==Define))
			{
				alt6 = 2;
			}
			else if ((LA6_1==Macro))
			{
				alt6 = 3;
			}
			else if ((LA6_1==PreIf))
			{
				alt6 = 4;
			}
			else if ((LA6_1==IfDef))
			{
				alt6 = 5;
			}
			else if ((LA6_1==IfNDef))
			{
				alt6 = 6;
			}
			else if ((LA6_1==Echo))
			{
				alt6 = 7;
			}
			else if ((LA6_1==Error))
			{
				alt6 = 8;
			}
			else if ((LA6_1==Unmac))
			{
				alt6 = 9;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:16:4: ( include )=> include
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 15);
				PushFollow(Follow._include_in_preProcessor96);
				include11=include();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, include11.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:16:23: define
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 23);
				PushFollow(Follow._define_in_preProcessor98);
				define12=define();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, define12.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:16:30: macro
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 30);
				PushFollow(Follow._macro_in_preProcessor100);
				macro13=macro();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, macro13.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:16:36: preIf
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 36);
				PushFollow(Follow._preIf_in_preProcessor102);
				preIf14=preIf();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, preIf14.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishScript.g:16:42: ifDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 42);
				PushFollow(Follow._ifDef_in_preProcessor104);
				ifDef15=ifDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifDef15.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishScript.g:16:48: ifNDef
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 48);
				PushFollow(Follow._ifNDef_in_preProcessor106);
				ifNDef16=ifNDef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifNDef16.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LavishScript.g:16:55: echo
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 55);
				PushFollow(Follow._echo_in_preProcessor108);
				echo17=echo();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, echo17.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LavishScript.g:16:60: error
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 60);
				PushFollow(Follow._error_in_preProcessor110);
				error18=error();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, error18.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LavishScript.g:16:66: unmac
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 66);
				PushFollow(Follow._unmac_in_preProcessor112);
				unmac19=unmac();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unmac19.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("preProcessor", 3);
			LeaveRule("preProcessor", 3);
			LeaveRule_preProcessor();
		}
		DebugLocation(17, 1);
		} finally { DebugExitRule(GrammarFileName, "preProcessor"); }
		return retval;

	}
	// $ANTLR end "preProcessor"

	partial void EnterRule_unmac();
	partial void LeaveRule_unmac();
	// $ANTLR start "unmac"
	// Grammars\\LavishScript.g:18:8: public unmac : Unmac WS ID -> ^( Unmac ID ) ;
	[GrammarRule("unmac")]
	public AstParserRuleReturnScope<CommonTree, IToken> unmac()
	{
		EnterRule_unmac();
		EnterRule("unmac", 4);
		TraceIn("unmac", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Unmac20 = default(IToken);
		IToken WS21 = default(IToken);
		IToken ID22 = default(IToken);

		CommonTree Unmac20_tree = default(CommonTree);
		CommonTree WS21_tree = default(CommonTree);
		CommonTree ID22_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Unmac=new RewriteRuleITokenStream(adaptor,"token Unmac");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "unmac");
		DebugLocation(18, 1);
		try
		{
			// Grammars\\LavishScript.g:19:2: ( Unmac WS ID -> ^( Unmac ID ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:19:4: Unmac WS ID
			{
			DebugLocation(19, 4);
			Unmac20=(IToken)Match(input,Unmac,Follow._Unmac_in_unmac124); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Unmac.Add(Unmac20);

			DebugLocation(19, 10);
			WS21=(IToken)Match(input,WS,Follow._WS_in_unmac126); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS21);

			DebugLocation(19, 13);
			ID22=(IToken)Match(input,ID,Follow._ID_in_unmac128); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID22);



			{
			// AST REWRITE
			// elements: Unmac, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 19:15: -> ^( Unmac ID )
			{
				DebugLocation(19, 17);
				// Grammars\\LavishScript.g:19:17: ^( Unmac ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(19, 19);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Unmac.NextNode(), root_1);

				DebugLocation(19, 25);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unmac", 4);
			LeaveRule("unmac", 4);
			LeaveRule_unmac();
		}
		DebugLocation(20, 1);
		} finally { DebugExitRule(GrammarFileName, "unmac"); }
		return retval;

	}
	// $ANTLR end "unmac"

	partial void EnterRule_define();
	partial void LeaveRule_define();
	// $ANTLR start "define"
	// Grammars\\LavishScript.g:21:8: public define : Define WS ID ( WS vals+= ( ID | INT | string | FLOAT | ( dataSequence )=> dataSequence | ( command )=> command | condition ) )+ -> ^( Define ID ( $vals)+ ) ;
	[GrammarRule("define")]
	public AstParserRuleReturnScope<CommonTree, IToken> define()
	{
		EnterRule_define();
		EnterRule("define", 5);
		TraceIn("define", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Define23 = default(IToken);
		IToken WS24 = default(IToken);
		IToken ID25 = default(IToken);
		IToken WS26 = default(IToken);
		IToken ID27 = default(IToken);
		IToken INT28 = default(IToken);
		IToken FLOAT30 = default(IToken);
		IToken vals = default(IToken);
		List<IToken> list_vals = null;
		AstParserRuleReturnScope<CommonTree, IToken> string29 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence31 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command32 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Define23_tree = default(CommonTree);
		CommonTree WS24_tree = default(CommonTree);
		CommonTree ID25_tree = default(CommonTree);
		CommonTree WS26_tree = default(CommonTree);
		CommonTree ID27_tree = default(CommonTree);
		CommonTree INT28_tree = default(CommonTree);
		CommonTree FLOAT30_tree = default(CommonTree);
		CommonTree vals_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Define=new RewriteRuleITokenStream(adaptor,"token Define");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_FLOAT=new RewriteRuleITokenStream(adaptor,"token FLOAT");
		RewriteRuleSubtreeStream stream_string=new RewriteRuleSubtreeStream(adaptor,"rule string");
		RewriteRuleSubtreeStream stream_dataSequence=new RewriteRuleSubtreeStream(adaptor,"rule dataSequence");
		RewriteRuleSubtreeStream stream_command=new RewriteRuleSubtreeStream(adaptor,"rule command");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "define");
		DebugLocation(21, 1);
		try
		{
			// Grammars\\LavishScript.g:22:2: ( Define WS ID ( WS vals+= ( ID | INT | string | FLOAT | ( dataSequence )=> dataSequence | ( command )=> command | condition ) )+ -> ^( Define ID ( $vals)+ ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:22:4: Define WS ID ( WS vals+= ( ID | INT | string | FLOAT | ( dataSequence )=> dataSequence | ( command )=> command | condition ) )+
			{
			DebugLocation(22, 4);
			Define23=(IToken)Match(input,Define,Follow._Define_in_define146); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Define.Add(Define23);

			DebugLocation(22, 11);
			WS24=(IToken)Match(input,WS,Follow._WS_in_define148); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS24);

			DebugLocation(22, 14);
			ID25=(IToken)Match(input,ID,Follow._ID_in_define150); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID25);

			DebugLocation(22, 17);
			// Grammars\\LavishScript.g:22:17: ( WS vals+= ( ID | INT | string | FLOAT | ( dataSequence )=> dataSequence | ( command )=> command | condition ) )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==WS))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:23:4: WS vals+= ( ID | INT | string | FLOAT | ( dataSequence )=> dataSequence | ( command )=> command | condition )
					{
					DebugLocation(23, 4);
					WS26=(IToken)Match(input,WS,Follow._WS_in_define157); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_WS.Add(WS26);

					DebugLocation(23, 11);
					// Grammars\\LavishScript.g:24:4: ( ID | INT | string | FLOAT | ( dataSequence )=> dataSequence | ( command )=> command | condition )
					int alt7=7;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					switch (input.LA(1))
					{
					case ID:
						{
						alt7 = 1;
						}
						break;
					case INT:
						{
						alt7 = 2;
						}
						break;
					case Quote:
						{
						alt7 = 3;
						}
						break;
					case FLOAT:
						{
						alt7 = 4;
						}
						break;
					case Dollar:
						{
						int LA7_2 = input.LA(2);

						if ((EvaluatePredicate(synpred2_LavishScript_fragment)))
						{
							alt7 = 5;
						}
						else if ((EvaluatePredicate(synpred3_LavishScript_fragment)))
						{
							alt7 = 6;
						}
						else if ((true))
						{
							alt7 = 7;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 7, 5, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case ARG:
					case And:
					case Assign:
					case Atom:
					case Band:
					case Bnegate:
					case Bor:
					case COMMAND:
					case COMMENT:
					case CONDITION:
					case Case:
					case CodeBlock:
					case Colon:
					case Comma:
					case DataCommand:
					case DeclareVariable:
					case Default:
					case Define:
					case Div:
					case Do:
					case Dot:
					case ESC_SEQ:
					case EXPONENT:
					case Echo:
					case Elipse:
					case Else:
					case ElseIf:
					case EndIf:
					case EndMac:
					case EqualTo:
					case Error:
					case For:
					case Function:
					case GreaterThan:
					case GreaterThanEqual:
					case HEX_DIGIT:
					case If:
					case IfDef:
					case IfNDef:
					case Include:
					case Inherits:
					case LCurly:
					case LParen:
					case LSquare:
					case LeftShift:
					case LessThan:
					case LessThanEqual:
					case MATH:
					case Macro:
					case Member:
					case Method:
					case Minus:
					case Modu:
					case Mult:
					case Negate:
					case NewLine:
					case NotEqualTo:
					case OCTAL_ESC:
					case ObjectDef:
					case Or:
					case Other:
					case Param:
					case Params:
					case Plus:
					case PreElse:
					case PreElseIf:
					case PreIf:
					case RCurly:
					case RSquare:
					case Returns:
					case RightShift:
					case STRING:
					case Scope:
					case Script:
					case Semi:
					case Switch:
					case Type:
					case UNICODE_ESC:
					case Unmac:
					case Variable:
					case VariableCase:
					case WS:
					case While:
					case Xor:
						{
						alt7 = 7;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:25:5: ID
						{
						DebugLocation(25, 5);
						ID27=(IToken)Match(input,ID,Follow._ID_in_define171); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_ID.Add(ID27);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishScript.g:26:6: INT
						{
						DebugLocation(26, 6);
						INT28=(IToken)Match(input,INT,Follow._INT_in_define178); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT28);


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Grammars\\LavishScript.g:27:6: string
						{
						DebugLocation(27, 6);
						PushFollow(Follow._string_in_define185);
						string29=@string();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_string.Add(string29.Tree);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Grammars\\LavishScript.g:28:6: FLOAT
						{
						DebugLocation(28, 6);
						FLOAT30=(IToken)Match(input,FLOAT,Follow._FLOAT_in_define192); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_FLOAT.Add(FLOAT30);


						}
						break;
					case 5:
						DebugEnterAlt(5);
						// Grammars\\LavishScript.g:29:6: ( dataSequence )=> dataSequence
						{
						DebugLocation(29, 22);
						PushFollow(Follow._dataSequence_in_define203);
						dataSequence31=dataSequence();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_dataSequence.Add(dataSequence31.Tree);

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// Grammars\\LavishScript.g:30:6: ( command )=> command
						{
						DebugLocation(30, 17);
						PushFollow(Follow._command_in_define214);
						command32=command();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_command.Add(command32.Tree);

						}
						break;
					case 7:
						DebugEnterAlt(7);
						// Grammars\\LavishScript.g:31:6: condition
						{
						DebugLocation(31, 6);
						PushFollow(Follow._condition_in_define221);
						condition33=condition();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_condition.Add(condition33.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(7); }


					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }



			{
			// AST REWRITE
			// elements: Define, ID, vals
			// token labels: 
			// rule labels: retval
			// token list labels: vals
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_vals=new RewriteRuleITokenStream(adaptor,"token vals", list_vals);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 34:4: -> ^( Define ID ( $vals)+ )
			{
				DebugLocation(34, 6);
				// Grammars\\LavishScript.g:34:6: ^( Define ID ( $vals)+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(34, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Define.NextNode(), root_1);

				DebugLocation(34, 15);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(34, 19);
				if (!(stream_vals.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_vals.HasNext )
				{
					DebugLocation(34, 19);
					adaptor.AddChild(root_1, stream_vals.NextNode());

				}
				stream_vals.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("define", 5);
			LeaveRule("define", 5);
			LeaveRule_define();
		}
		DebugLocation(35, 1);
		} finally { DebugExitRule(GrammarFileName, "define"); }
		return retval;

	}
	// $ANTLR end "define"

	partial void EnterRule_macro();
	partial void LeaveRule_macro();
	// $ANTLR start "macro"
	// Grammars\\LavishScript.g:36:8: public macro : Macro WS ID ws LParen ws params ws RParen ( WS )? ( ( expression )* ) EndMac -> ^( Macro ID ^( Params ( params )* ) ( expression )* ) ;
	[GrammarRule("macro")]
	public AstParserRuleReturnScope<CommonTree, IToken> macro()
	{
		EnterRule_macro();
		EnterRule("macro", 6);
		TraceIn("macro", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Macro34 = default(IToken);
		IToken WS35 = default(IToken);
		IToken ID36 = default(IToken);
		IToken LParen38 = default(IToken);
		IToken RParen42 = default(IToken);
		IToken WS43 = default(IToken);
		IToken EndMac45 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ws37 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> params40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression44 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Macro34_tree = default(CommonTree);
		CommonTree WS35_tree = default(CommonTree);
		CommonTree ID36_tree = default(CommonTree);
		CommonTree LParen38_tree = default(CommonTree);
		CommonTree RParen42_tree = default(CommonTree);
		CommonTree WS43_tree = default(CommonTree);
		CommonTree EndMac45_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Macro=new RewriteRuleITokenStream(adaptor,"token Macro");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_EndMac=new RewriteRuleITokenStream(adaptor,"token EndMac");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"rule params");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "macro");
		DebugLocation(36, 1);
		try
		{
			// Grammars\\LavishScript.g:37:2: ( Macro WS ID ws LParen ws params ws RParen ( WS )? ( ( expression )* ) EndMac -> ^( Macro ID ^( Params ( params )* ) ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:37:4: Macro WS ID ws LParen ws params ws RParen ( WS )? ( ( expression )* ) EndMac
			{
			DebugLocation(37, 4);
			Macro34=(IToken)Match(input,Macro,Follow._Macro_in_macro258); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Macro.Add(Macro34);

			DebugLocation(37, 10);
			WS35=(IToken)Match(input,WS,Follow._WS_in_macro260); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS35);

			DebugLocation(37, 14);
			ID36=(IToken)Match(input,ID,Follow._ID_in_macro263); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID36);

			DebugLocation(37, 17);
			PushFollow(Follow._ws_in_macro265);
			ws37=ws();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ws.Add(ws37.Tree);
			DebugLocation(37, 20);
			LParen38=(IToken)Match(input,LParen,Follow._LParen_in_macro267); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LParen.Add(LParen38);

			DebugLocation(37, 27);
			PushFollow(Follow._ws_in_macro269);
			ws39=ws();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ws.Add(ws39.Tree);
			DebugLocation(37, 30);
			PushFollow(Follow._params_in_macro271);
			params40=@params();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_params.Add(params40.Tree);
			DebugLocation(37, 37);
			PushFollow(Follow._ws_in_macro273);
			ws41=ws();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ws.Add(ws41.Tree);
			DebugLocation(37, 40);
			RParen42=(IToken)Match(input,RParen,Follow._RParen_in_macro275); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RParen.Add(RParen42);

			DebugLocation(37, 47);
			// Grammars\\LavishScript.g:37:47: ( WS )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==WS))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:37:47: WS
				{
				DebugLocation(37, 47);
				WS43=(IToken)Match(input,WS,Follow._WS_in_macro277); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS43);


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(38, 4);
			// Grammars\\LavishScript.g:38:4: ( ( expression )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:38:5: ( expression )*
			{
			DebugLocation(38, 5);
			// Grammars\\LavishScript.g:38:5: ( expression )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==NewLine))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:38:5: expression
					{
					DebugLocation(38, 5);
					PushFollow(Follow._expression_in_macro284);
					expression44=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression44.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			DebugLocation(39, 3);
			EndMac45=(IToken)Match(input,EndMac,Follow._EndMac_in_macro290); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EndMac.Add(EndMac45);



			{
			// AST REWRITE
			// elements: Macro, ID, params, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 39:10: -> ^( Macro ID ^( Params ( params )* ) ( expression )* )
			{
				DebugLocation(39, 12);
				// Grammars\\LavishScript.g:39:12: ^( Macro ID ^( Params ( params )* ) ( expression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(39, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Macro.NextNode(), root_1);

				DebugLocation(39, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(39, 23);
				// Grammars\\LavishScript.g:39:23: ^( Params ( params )* )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(39, 25);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Params, "Params"), root_2);

				DebugLocation(39, 32);
				// Grammars\\LavishScript.g:39:32: ( params )*
				while ( stream_params.HasNext )
				{
					DebugLocation(39, 32);
					adaptor.AddChild(root_2, stream_params.NextTree());

				}
				stream_params.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(39, 41);
				// Grammars\\LavishScript.g:39:41: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(39, 41);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("macro", 6);
			LeaveRule("macro", 6);
			LeaveRule_macro();
		}
		DebugLocation(40, 1);
		} finally { DebugExitRule(GrammarFileName, "macro"); }
		return retval;

	}
	// $ANTLR end "macro"

	partial void EnterRule_preIf();
	partial void LeaveRule_preIf();
	// $ANTLR start "preIf"
	// Grammars\\LavishScript.g:41:8: public preIf : PreIf WS condition ( WS )? ( expression )* ( preElseIf )* ( preElse )? endIf -> ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? ) ;
	[GrammarRule("preIf")]
	public AstParserRuleReturnScope<CommonTree, IToken> preIf()
	{
		EnterRule_preIf();
		EnterRule("preIf", 7);
		TraceIn("preIf", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken PreIf46 = default(IToken);
		IToken WS47 = default(IToken);
		IToken WS49 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> preElseIf51 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> preElse52 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> endIf53 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PreIf46_tree = default(CommonTree);
		CommonTree WS47_tree = default(CommonTree);
		CommonTree WS49_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PreIf=new RewriteRuleITokenStream(adaptor,"token PreIf");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_preElseIf=new RewriteRuleSubtreeStream(adaptor,"rule preElseIf");
		RewriteRuleSubtreeStream stream_preElse=new RewriteRuleSubtreeStream(adaptor,"rule preElse");
		RewriteRuleSubtreeStream stream_endIf=new RewriteRuleSubtreeStream(adaptor,"rule endIf");
		try { DebugEnterRule(GrammarFileName, "preIf");
		DebugLocation(41, 1);
		try
		{
			// Grammars\\LavishScript.g:42:2: ( PreIf WS condition ( WS )? ( expression )* ( preElseIf )* ( preElse )? endIf -> ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:42:4: PreIf WS condition ( WS )? ( expression )* ( preElseIf )* ( preElse )? endIf
			{
			DebugLocation(42, 4);
			PreIf46=(IToken)Match(input,PreIf,Follow._PreIf_in_preIf319); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PreIf.Add(PreIf46);

			DebugLocation(42, 10);
			WS47=(IToken)Match(input,WS,Follow._WS_in_preIf321); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS47);

			DebugLocation(42, 13);
			PushFollow(Follow._condition_in_preIf323);
			condition48=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition48.Tree);
			DebugLocation(42, 23);
			// Grammars\\LavishScript.g:42:23: ( WS )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==WS))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:42:23: WS
				{
				DebugLocation(42, 23);
				WS49=(IToken)Match(input,WS,Follow._WS_in_preIf325); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS49);


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(43, 4);
			// Grammars\\LavishScript.g:43:4: ( expression )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==NewLine))
				{
					int LA12_2 = input.LA(2);

					if ((LA12_2==DeclareVariable||LA12_2==Define||(LA12_2>=Do && LA12_2<=Dollar)||LA12_2==Echo||LA12_2==Error||LA12_2==For||LA12_2==ID||(LA12_2>=If && LA12_2<=Include)||LA12_2==LCurly||LA12_2==Macro||LA12_2==NewLine||LA12_2==PreIf||LA12_2==Switch||(LA12_2>=Unmac && LA12_2<=Variable)||(LA12_2>=WS && LA12_2<=While)))
					{
						alt12 = 1;
					}


				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:43:4: expression
					{
					DebugLocation(43, 4);
					PushFollow(Follow._expression_in_preIf331);
					expression50=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression50.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(44, 4);
			// Grammars\\LavishScript.g:44:4: ( preElseIf )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==NewLine))
				{
					int LA13_2 = input.LA(2);

					if ((LA13_2==PreElseIf))
					{
						alt13 = 1;
					}


				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:44:4: preElseIf
					{
					DebugLocation(44, 4);
					PushFollow(Follow._preElseIf_in_preIf337);
					preElseIf51=preElseIf();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_preElseIf.Add(preElseIf51.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(45, 4);
			// Grammars\\LavishScript.g:45:4: ( preElse )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==NewLine))
			{
				int LA14_2 = input.LA(2);

				if ((LA14_2==PreElse))
				{
					alt14 = 1;
				}
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:45:4: preElse
				{
				DebugLocation(45, 4);
				PushFollow(Follow._preElse_in_preIf343);
				preElse52=preElse();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_preElse.Add(preElse52.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(46, 4);
			PushFollow(Follow._endIf_in_preIf349);
			endIf53=endIf();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_endIf.Add(endIf53.Tree);


			{
			// AST REWRITE
			// elements: PreIf, condition, expression, preElseIf, preElse
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 46:10: -> ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? )
			{
				DebugLocation(46, 12);
				// Grammars\\LavishScript.g:46:12: ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(46, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_PreIf.NextNode(), root_1);

				DebugLocation(46, 20);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(46, 30);
				// Grammars\\LavishScript.g:46:30: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(46, 30);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();
				DebugLocation(46, 42);
				// Grammars\\LavishScript.g:46:42: ( preElseIf )*
				while ( stream_preElseIf.HasNext )
				{
					DebugLocation(46, 42);
					adaptor.AddChild(root_1, stream_preElseIf.NextTree());

				}
				stream_preElseIf.Reset();
				DebugLocation(46, 53);
				// Grammars\\LavishScript.g:46:53: ( preElse )?
				if (stream_preElse.HasNext)
				{
					DebugLocation(46, 53);
					adaptor.AddChild(root_1, stream_preElse.NextTree());

				}
				stream_preElse.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("preIf", 7);
			LeaveRule("preIf", 7);
			LeaveRule_preIf();
		}
		DebugLocation(48, 1);
		} finally { DebugExitRule(GrammarFileName, "preIf"); }
		return retval;

	}
	// $ANTLR end "preIf"

	partial void EnterRule_endIf();
	partial void LeaveRule_endIf();
	// $ANTLR start "endIf"
	// Grammars\\LavishScript.g:49:8: public endIf : NewLine ! EndIf !;
	[GrammarRule("endIf")]
	public AstParserRuleReturnScope<CommonTree, IToken> endIf()
	{
		EnterRule_endIf();
		EnterRule("endIf", 8);
		TraceIn("endIf", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NewLine54 = default(IToken);
		IToken EndIf55 = default(IToken);

		CommonTree NewLine54_tree = default(CommonTree);
		CommonTree EndIf55_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "endIf");
		DebugLocation(49, 1);
		try
		{
			// Grammars\\LavishScript.g:50:2: ( NewLine ! EndIf !)
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:50:4: NewLine ! EndIf !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(50, 11);
			NewLine54=(IToken)Match(input,NewLine,Follow._NewLine_in_endIf380); if (state.failed) return retval;
			DebugLocation(50, 18);
			EndIf55=(IToken)Match(input,EndIf,Follow._EndIf_in_endIf383); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("endIf", 8);
			LeaveRule("endIf", 8);
			LeaveRule_endIf();
		}
		DebugLocation(51, 1);
		} finally { DebugExitRule(GrammarFileName, "endIf"); }
		return retval;

	}
	// $ANTLR end "endIf"

	partial void EnterRule_preElse();
	partial void LeaveRule_preElse();
	// $ANTLR start "preElse"
	// Grammars\\LavishScript.g:52:8: public preElse : NewLine PreElse ( WS )? ( expression )* -> ^( PreElse ( expression )* ) ;
	[GrammarRule("preElse")]
	public AstParserRuleReturnScope<CommonTree, IToken> preElse()
	{
		EnterRule_preElse();
		EnterRule("preElse", 9);
		TraceIn("preElse", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NewLine56 = default(IToken);
		IToken PreElse57 = default(IToken);
		IToken WS58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression59 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NewLine56_tree = default(CommonTree);
		CommonTree PreElse57_tree = default(CommonTree);
		CommonTree WS58_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleITokenStream stream_PreElse=new RewriteRuleITokenStream(adaptor,"token PreElse");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "preElse");
		DebugLocation(52, 1);
		try
		{
			// Grammars\\LavishScript.g:53:2: ( NewLine PreElse ( WS )? ( expression )* -> ^( PreElse ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:53:4: NewLine PreElse ( WS )? ( expression )*
			{
			DebugLocation(53, 4);
			NewLine56=(IToken)Match(input,NewLine,Follow._NewLine_in_preElse396); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine56);

			DebugLocation(53, 12);
			PreElse57=(IToken)Match(input,PreElse,Follow._PreElse_in_preElse398); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PreElse.Add(PreElse57);

			DebugLocation(53, 20);
			// Grammars\\LavishScript.g:53:20: ( WS )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==WS))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:53:20: WS
				{
				DebugLocation(53, 20);
				WS58=(IToken)Match(input,WS,Follow._WS_in_preElse400); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS58);


				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(53, 24);
			// Grammars\\LavishScript.g:53:24: ( expression )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==NewLine))
				{
					int LA16_2 = input.LA(2);

					if ((LA16_2==DeclareVariable||LA16_2==Define||(LA16_2>=Do && LA16_2<=Dollar)||LA16_2==Echo||LA16_2==Error||LA16_2==For||LA16_2==ID||(LA16_2>=If && LA16_2<=Include)||LA16_2==LCurly||LA16_2==Macro||LA16_2==NewLine||LA16_2==PreIf||LA16_2==Switch||(LA16_2>=Unmac && LA16_2<=Variable)||(LA16_2>=WS && LA16_2<=While)))
					{
						alt16 = 1;
					}


				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:53:24: expression
					{
					DebugLocation(53, 24);
					PushFollow(Follow._expression_in_preElse403);
					expression59=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression59.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }



			{
			// AST REWRITE
			// elements: PreElse, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 53:36: -> ^( PreElse ( expression )* )
			{
				DebugLocation(53, 38);
				// Grammars\\LavishScript.g:53:38: ^( PreElse ( expression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(53, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_PreElse.NextNode(), root_1);

				DebugLocation(53, 48);
				// Grammars\\LavishScript.g:53:48: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(53, 48);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("preElse", 9);
			LeaveRule("preElse", 9);
			LeaveRule_preElse();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "preElse"); }
		return retval;

	}
	// $ANTLR end "preElse"

	partial void EnterRule_preElseIf();
	partial void LeaveRule_preElseIf();
	// $ANTLR start "preElseIf"
	// Grammars\\LavishScript.g:55:8: public preElseIf : NewLine PreElseIf ( WS )? condition ( expression )* -> ^( PreElse condition ( expression )* ) ;
	[GrammarRule("preElseIf")]
	public AstParserRuleReturnScope<CommonTree, IToken> preElseIf()
	{
		EnterRule_preElseIf();
		EnterRule("preElseIf", 10);
		TraceIn("preElseIf", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NewLine60 = default(IToken);
		IToken PreElseIf61 = default(IToken);
		IToken WS62 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition63 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression64 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NewLine60_tree = default(CommonTree);
		CommonTree PreElseIf61_tree = default(CommonTree);
		CommonTree WS62_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleITokenStream stream_PreElseIf=new RewriteRuleITokenStream(adaptor,"token PreElseIf");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "preElseIf");
		DebugLocation(55, 1);
		try
		{
			// Grammars\\LavishScript.g:56:2: ( NewLine PreElseIf ( WS )? condition ( expression )* -> ^( PreElse condition ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:56:4: NewLine PreElseIf ( WS )? condition ( expression )*
			{
			DebugLocation(56, 4);
			NewLine60=(IToken)Match(input,NewLine,Follow._NewLine_in_preElseIf424); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine60);

			DebugLocation(56, 12);
			PreElseIf61=(IToken)Match(input,PreElseIf,Follow._PreElseIf_in_preElseIf426); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PreElseIf.Add(PreElseIf61);

			DebugLocation(56, 22);
			// Grammars\\LavishScript.g:56:22: ( WS )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==WS))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:56:22: WS
				{
				DebugLocation(56, 22);
				WS62=(IToken)Match(input,WS,Follow._WS_in_preElseIf428); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS62);


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(56, 26);
			PushFollow(Follow._condition_in_preElseIf431);
			condition63=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition63.Tree);
			DebugLocation(56, 36);
			// Grammars\\LavishScript.g:56:36: ( expression )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==NewLine))
				{
					int LA18_2 = input.LA(2);

					if ((LA18_2==DeclareVariable||LA18_2==Define||(LA18_2>=Do && LA18_2<=Dollar)||LA18_2==Echo||LA18_2==Error||LA18_2==For||LA18_2==ID||(LA18_2>=If && LA18_2<=Include)||LA18_2==LCurly||LA18_2==Macro||LA18_2==NewLine||LA18_2==PreIf||LA18_2==Switch||(LA18_2>=Unmac && LA18_2<=Variable)||(LA18_2>=WS && LA18_2<=While)))
					{
						alt18 = 1;
					}


				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:56:36: expression
					{
					DebugLocation(56, 36);
					PushFollow(Follow._expression_in_preElseIf433);
					expression64=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression64.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: condition, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 56:47: -> ^( PreElse condition ( expression )* )
			{
				DebugLocation(56, 49);
				// Grammars\\LavishScript.g:56:49: ^( PreElse condition ( expression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(56, 51);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PreElse, "PreElse"), root_1);

				DebugLocation(56, 59);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(56, 69);
				// Grammars\\LavishScript.g:56:69: ( expression )*
				while ( stream_expression.HasNext )
				{
					DebugLocation(56, 69);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("preElseIf", 10);
			LeaveRule("preElseIf", 10);
			LeaveRule_preElseIf();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "preElseIf"); }
		return retval;

	}
	// $ANTLR end "preElseIf"

	partial void EnterRule_ifDef();
	partial void LeaveRule_ifDef();
	// $ANTLR start "ifDef"
	// Grammars\\LavishScript.g:58:8: public ifDef : IfDef WS ID ( preElse )? endIf -> ^( IfDef ID ( preElse )? ) ;
	[GrammarRule("ifDef")]
	public AstParserRuleReturnScope<CommonTree, IToken> ifDef()
	{
		EnterRule_ifDef();
		EnterRule("ifDef", 11);
		TraceIn("ifDef", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IfDef65 = default(IToken);
		IToken WS66 = default(IToken);
		IToken ID67 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> preElse68 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> endIf69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IfDef65_tree = default(CommonTree);
		CommonTree WS66_tree = default(CommonTree);
		CommonTree ID67_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IfDef=new RewriteRuleITokenStream(adaptor,"token IfDef");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_preElse=new RewriteRuleSubtreeStream(adaptor,"rule preElse");
		RewriteRuleSubtreeStream stream_endIf=new RewriteRuleSubtreeStream(adaptor,"rule endIf");
		try { DebugEnterRule(GrammarFileName, "ifDef");
		DebugLocation(58, 1);
		try
		{
			// Grammars\\LavishScript.g:59:2: ( IfDef WS ID ( preElse )? endIf -> ^( IfDef ID ( preElse )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:59:4: IfDef WS ID ( preElse )? endIf
			{
			DebugLocation(59, 4);
			IfDef65=(IToken)Match(input,IfDef,Follow._IfDef_in_ifDef455); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IfDef.Add(IfDef65);

			DebugLocation(59, 10);
			WS66=(IToken)Match(input,WS,Follow._WS_in_ifDef457); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS66);

			DebugLocation(59, 13);
			ID67=(IToken)Match(input,ID,Follow._ID_in_ifDef459); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID67);

			DebugLocation(60, 3);
			// Grammars\\LavishScript.g:60:3: ( preElse )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==NewLine))
			{
				int LA19_2 = input.LA(2);

				if ((LA19_2==PreElse))
				{
					alt19 = 1;
				}
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:60:3: preElse
				{
				DebugLocation(60, 3);
				PushFollow(Follow._preElse_in_ifDef463);
				preElse68=preElse();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_preElse.Add(preElse68.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(61, 3);
			PushFollow(Follow._endIf_in_ifDef468);
			endIf69=endIf();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_endIf.Add(endIf69.Tree);


			{
			// AST REWRITE
			// elements: IfDef, ID, preElse
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 61:9: -> ^( IfDef ID ( preElse )? )
			{
				DebugLocation(61, 11);
				// Grammars\\LavishScript.g:61:11: ^( IfDef ID ( preElse )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(61, 13);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_IfDef.NextNode(), root_1);

				DebugLocation(61, 19);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(61, 22);
				// Grammars\\LavishScript.g:61:22: ( preElse )?
				if (stream_preElse.HasNext)
				{
					DebugLocation(61, 22);
					adaptor.AddChild(root_1, stream_preElse.NextTree());

				}
				stream_preElse.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifDef", 11);
			LeaveRule("ifDef", 11);
			LeaveRule_ifDef();
		}
		DebugLocation(62, 1);
		} finally { DebugExitRule(GrammarFileName, "ifDef"); }
		return retval;

	}
	// $ANTLR end "ifDef"

	partial void EnterRule_ifNDef();
	partial void LeaveRule_ifNDef();
	// $ANTLR start "ifNDef"
	// Grammars\\LavishScript.g:63:8: public ifNDef : IfNDef WS ID ( preElse )? endIf -> ^( IfNDef ID ( preElse )? ) ;
	[GrammarRule("ifNDef")]
	public AstParserRuleReturnScope<CommonTree, IToken> ifNDef()
	{
		EnterRule_ifNDef();
		EnterRule("ifNDef", 12);
		TraceIn("ifNDef", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IfNDef70 = default(IToken);
		IToken WS71 = default(IToken);
		IToken ID72 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> preElse73 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> endIf74 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IfNDef70_tree = default(CommonTree);
		CommonTree WS71_tree = default(CommonTree);
		CommonTree ID72_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IfNDef=new RewriteRuleITokenStream(adaptor,"token IfNDef");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_preElse=new RewriteRuleSubtreeStream(adaptor,"rule preElse");
		RewriteRuleSubtreeStream stream_endIf=new RewriteRuleSubtreeStream(adaptor,"rule endIf");
		try { DebugEnterRule(GrammarFileName, "ifNDef");
		DebugLocation(63, 1);
		try
		{
			// Grammars\\LavishScript.g:64:2: ( IfNDef WS ID ( preElse )? endIf -> ^( IfNDef ID ( preElse )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:64:4: IfNDef WS ID ( preElse )? endIf
			{
			DebugLocation(64, 4);
			IfNDef70=(IToken)Match(input,IfNDef,Follow._IfNDef_in_ifNDef490); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IfNDef.Add(IfNDef70);

			DebugLocation(64, 11);
			WS71=(IToken)Match(input,WS,Follow._WS_in_ifNDef492); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS71);

			DebugLocation(64, 14);
			ID72=(IToken)Match(input,ID,Follow._ID_in_ifNDef494); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID72);

			DebugLocation(65, 3);
			// Grammars\\LavishScript.g:65:3: ( preElse )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==NewLine))
			{
				int LA20_2 = input.LA(2);

				if ((LA20_2==PreElse))
				{
					alt20 = 1;
				}
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:65:3: preElse
				{
				DebugLocation(65, 3);
				PushFollow(Follow._preElse_in_ifNDef498);
				preElse73=preElse();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_preElse.Add(preElse73.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(66, 3);
			PushFollow(Follow._endIf_in_ifNDef503);
			endIf74=endIf();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_endIf.Add(endIf74.Tree);


			{
			// AST REWRITE
			// elements: IfNDef, ID, preElse
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 66:9: -> ^( IfNDef ID ( preElse )? )
			{
				DebugLocation(66, 11);
				// Grammars\\LavishScript.g:66:11: ^( IfNDef ID ( preElse )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(66, 13);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_IfNDef.NextNode(), root_1);

				DebugLocation(66, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(66, 23);
				// Grammars\\LavishScript.g:66:23: ( preElse )?
				if (stream_preElse.HasNext)
				{
					DebugLocation(66, 23);
					adaptor.AddChild(root_1, stream_preElse.NextTree());

				}
				stream_preElse.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifNDef", 12);
			LeaveRule("ifNDef", 12);
			LeaveRule_ifNDef();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "ifNDef"); }
		return retval;

	}
	// $ANTLR end "ifNDef"

	partial void EnterRule_echo();
	partial void LeaveRule_echo();
	// $ANTLR start "echo"
	// Grammars\\LavishScript.g:68:8: public echo : Echo WS ( lineArg )* -> ^( Echo ( lineArg )* ) ;
	[GrammarRule("echo")]
	public AstParserRuleReturnScope<CommonTree, IToken> echo()
	{
		EnterRule_echo();
		EnterRule("echo", 13);
		TraceIn("echo", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Echo75 = default(IToken);
		IToken WS76 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Echo75_tree = default(CommonTree);
		CommonTree WS76_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Echo=new RewriteRuleITokenStream(adaptor,"token Echo");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_lineArg=new RewriteRuleSubtreeStream(adaptor,"rule lineArg");
		try { DebugEnterRule(GrammarFileName, "echo");
		DebugLocation(68, 1);
		try
		{
			// Grammars\\LavishScript.g:69:2: ( Echo WS ( lineArg )* -> ^( Echo ( lineArg )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:69:4: Echo WS ( lineArg )*
			{
			DebugLocation(69, 4);
			Echo75=(IToken)Match(input,Echo,Follow._Echo_in_echo525); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Echo.Add(Echo75);

			DebugLocation(69, 9);
			WS76=(IToken)Match(input,WS,Follow._WS_in_echo527); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS76);

			DebugLocation(69, 12);
			// Grammars\\LavishScript.g:69:12: ( lineArg )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				switch (input.LA(1))
				{
				case WS:
					{
					alt21 = 1;
					}
					break;
				case EndMac:
					{
					alt21 = 1;
					}
					break;
				case ARG:
				case And:
				case Assign:
				case Atom:
				case Band:
				case Bnegate:
				case Bor:
				case COMMAND:
				case COMMENT:
				case CONDITION:
				case Case:
				case CodeBlock:
				case Colon:
				case Comma:
				case Comparer:
				case DataCommand:
				case DeclareVariable:
				case Default:
				case Define:
				case Div:
				case Do:
				case Dollar:
				case Dot:
				case ESC_SEQ:
				case EXPONENT:
				case Echo:
				case Elipse:
				case Else:
				case ElseIf:
				case EndIf:
				case EqualTo:
				case Error:
				case FLOAT:
				case For:
				case Function:
				case GreaterThan:
				case GreaterThanEqual:
				case HEX_DIGIT:
				case ID:
				case INT:
				case If:
				case IfDef:
				case IfNDef:
				case Include:
				case Inherits:
				case LCurly:
				case LParen:
				case LSquare:
				case LeftShift:
				case LessThan:
				case LessThanEqual:
				case MATH:
				case Macro:
				case Member:
				case Method:
				case Minus:
				case Modu:
				case Mult:
				case Negate:
				case NotEqualTo:
				case OCTAL_ESC:
				case ObjectDef:
				case Or:
				case Other:
				case Param:
				case Params:
				case Plus:
				case PreElse:
				case PreElseIf:
				case PreIf:
				case Quote:
				case RCurly:
				case RParen:
				case RSquare:
				case Returns:
				case RightShift:
				case STRING:
				case Scope:
				case Script:
				case Semi:
				case Switch:
				case Type:
				case UNICODE_ESC:
				case Unmac:
				case Variable:
				case VariableCase:
				case While:
				case Xor:
					{
					alt21 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:69:12: lineArg
					{
					DebugLocation(69, 12);
					PushFollow(Follow._lineArg_in_echo529);
					lineArg77=lineArg();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_lineArg.Add(lineArg77.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }



			{
			// AST REWRITE
			// elements: Echo, lineArg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 69:20: -> ^( Echo ( lineArg )* )
			{
				DebugLocation(69, 22);
				// Grammars\\LavishScript.g:69:22: ^( Echo ( lineArg )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(69, 24);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Echo.NextNode(), root_1);

				DebugLocation(69, 29);
				// Grammars\\LavishScript.g:69:29: ( lineArg )*
				while ( stream_lineArg.HasNext )
				{
					DebugLocation(69, 29);
					adaptor.AddChild(root_1, stream_lineArg.NextTree());

				}
				stream_lineArg.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("echo", 13);
			LeaveRule("echo", 13);
			LeaveRule_echo();
		}
		DebugLocation(70, 1);
		} finally { DebugExitRule(GrammarFileName, "echo"); }
		return retval;

	}
	// $ANTLR end "echo"

	partial void EnterRule_error();
	partial void LeaveRule_error();
	// $ANTLR start "error"
	// Grammars\\LavishScript.g:71:8: public error : Error WS ( lineArg )* -> ^( Error ( lineArg )* ) ;
	[GrammarRule("error")]
	public AstParserRuleReturnScope<CommonTree, IToken> error()
	{
		EnterRule_error();
		EnterRule("error", 14);
		TraceIn("error", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Error78 = default(IToken);
		IToken WS79 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg80 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Error78_tree = default(CommonTree);
		CommonTree WS79_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Error=new RewriteRuleITokenStream(adaptor,"token Error");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_lineArg=new RewriteRuleSubtreeStream(adaptor,"rule lineArg");
		try { DebugEnterRule(GrammarFileName, "error");
		DebugLocation(71, 1);
		try
		{
			// Grammars\\LavishScript.g:72:2: ( Error WS ( lineArg )* -> ^( Error ( lineArg )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:72:4: Error WS ( lineArg )*
			{
			DebugLocation(72, 4);
			Error78=(IToken)Match(input,Error,Follow._Error_in_error549); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Error.Add(Error78);

			DebugLocation(72, 10);
			WS79=(IToken)Match(input,WS,Follow._WS_in_error551); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS79);

			DebugLocation(72, 13);
			// Grammars\\LavishScript.g:72:13: ( lineArg )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				switch (input.LA(1))
				{
				case WS:
					{
					alt22 = 1;
					}
					break;
				case EndMac:
					{
					alt22 = 1;
					}
					break;
				case ARG:
				case And:
				case Assign:
				case Atom:
				case Band:
				case Bnegate:
				case Bor:
				case COMMAND:
				case COMMENT:
				case CONDITION:
				case Case:
				case CodeBlock:
				case Colon:
				case Comma:
				case Comparer:
				case DataCommand:
				case DeclareVariable:
				case Default:
				case Define:
				case Div:
				case Do:
				case Dollar:
				case Dot:
				case ESC_SEQ:
				case EXPONENT:
				case Echo:
				case Elipse:
				case Else:
				case ElseIf:
				case EndIf:
				case EqualTo:
				case Error:
				case FLOAT:
				case For:
				case Function:
				case GreaterThan:
				case GreaterThanEqual:
				case HEX_DIGIT:
				case ID:
				case INT:
				case If:
				case IfDef:
				case IfNDef:
				case Include:
				case Inherits:
				case LCurly:
				case LParen:
				case LSquare:
				case LeftShift:
				case LessThan:
				case LessThanEqual:
				case MATH:
				case Macro:
				case Member:
				case Method:
				case Minus:
				case Modu:
				case Mult:
				case Negate:
				case NotEqualTo:
				case OCTAL_ESC:
				case ObjectDef:
				case Or:
				case Other:
				case Param:
				case Params:
				case Plus:
				case PreElse:
				case PreElseIf:
				case PreIf:
				case Quote:
				case RCurly:
				case RParen:
				case RSquare:
				case Returns:
				case RightShift:
				case STRING:
				case Scope:
				case Script:
				case Semi:
				case Switch:
				case Type:
				case UNICODE_ESC:
				case Unmac:
				case Variable:
				case VariableCase:
				case While:
				case Xor:
					{
					alt22 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:72:13: lineArg
					{
					DebugLocation(72, 13);
					PushFollow(Follow._lineArg_in_error553);
					lineArg80=lineArg();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_lineArg.Add(lineArg80.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: Error, lineArg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 72:21: -> ^( Error ( lineArg )* )
			{
				DebugLocation(72, 23);
				// Grammars\\LavishScript.g:72:23: ^( Error ( lineArg )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(72, 25);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Error.NextNode(), root_1);

				DebugLocation(72, 31);
				// Grammars\\LavishScript.g:72:31: ( lineArg )*
				while ( stream_lineArg.HasNext )
				{
					DebugLocation(72, 31);
					adaptor.AddChild(root_1, stream_lineArg.NextTree());

				}
				stream_lineArg.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("error", 14);
			LeaveRule("error", 14);
			LeaveRule_error();
		}
		DebugLocation(73, 1);
		} finally { DebugExitRule(GrammarFileName, "error"); }
		return retval;

	}
	// $ANTLR end "error"

	partial void EnterRule_include();
	partial void LeaveRule_include();
	// $ANTLR start "include"
	// Grammars\\LavishScript.g:74:8: public include : Include WS string -> ^( Include string ) ;
	[GrammarRule("include")]
	public AstParserRuleReturnScope<CommonTree, IToken> include()
	{
		EnterRule_include();
		EnterRule("include", 15);
		TraceIn("include", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Include81 = default(IToken);
		IToken WS82 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> string83 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Include81_tree = default(CommonTree);
		CommonTree WS82_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Include=new RewriteRuleITokenStream(adaptor,"token Include");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_string=new RewriteRuleSubtreeStream(adaptor,"rule string");
		try { DebugEnterRule(GrammarFileName, "include");
		DebugLocation(74, 1);
		try
		{
			// Grammars\\LavishScript.g:75:2: ( Include WS string -> ^( Include string ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:75:4: Include WS string
			{
			DebugLocation(75, 4);
			Include81=(IToken)Match(input,Include,Follow._Include_in_include573); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Include.Add(Include81);

			DebugLocation(75, 12);
			WS82=(IToken)Match(input,WS,Follow._WS_in_include575); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS82);

			DebugLocation(75, 15);
			PushFollow(Follow._string_in_include577);
			string83=@string();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_string.Add(string83.Tree);


			{
			// AST REWRITE
			// elements: Include, string
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 75:21: -> ^( Include string )
			{
				DebugLocation(75, 23);
				// Grammars\\LavishScript.g:75:23: ^( Include string )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(75, 25);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Include.NextNode(), root_1);

				DebugLocation(75, 33);
				adaptor.AddChild(root_1, stream_string.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("include", 15);
			LeaveRule("include", 15);
			LeaveRule_include();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "include"); }
		return retval;

	}
	// $ANTLR end "include"

	partial void EnterRule_string();
	partial void LeaveRule_string();
	// $ANTLR start "string"
	// Grammars\\LavishScript.g:77:8: public string : ( Quote (val+= ( ( dataSequence )=> dataSequence | quoteString ) )* Quote ) -> ^( STRING ( $val)* ) ;
	[GrammarRule("string")]
	public AstParserRuleReturnScope<CommonTree, IToken> @string()
	{
		EnterRule_string();
		EnterRule("string", 16);
		TraceIn("string", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Quote84 = default(IToken);
		IToken Quote87 = default(IToken);
		IToken val = default(IToken);
		List<IToken> list_val = null;
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence85 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> quoteString86 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Quote84_tree = default(CommonTree);
		CommonTree Quote87_tree = default(CommonTree);
		CommonTree val_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Quote=new RewriteRuleITokenStream(adaptor,"token Quote");
		RewriteRuleSubtreeStream stream_dataSequence=new RewriteRuleSubtreeStream(adaptor,"rule dataSequence");
		RewriteRuleSubtreeStream stream_quoteString=new RewriteRuleSubtreeStream(adaptor,"rule quoteString");
		try { DebugEnterRule(GrammarFileName, "string");
		DebugLocation(77, 1);
		try
		{
			// Grammars\\LavishScript.g:78:2: ( ( Quote (val+= ( ( dataSequence )=> dataSequence | quoteString ) )* Quote ) -> ^( STRING ( $val)* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:78:4: ( Quote (val+= ( ( dataSequence )=> dataSequence | quoteString ) )* Quote )
			{
			DebugLocation(78, 4);
			// Grammars\\LavishScript.g:78:4: ( Quote (val+= ( ( dataSequence )=> dataSequence | quoteString ) )* Quote )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:78:5: Quote (val+= ( ( dataSequence )=> dataSequence | quoteString ) )* Quote
			{
			DebugLocation(78, 5);
			Quote84=(IToken)Match(input,Quote,Follow._Quote_in_string596); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Quote.Add(Quote84);

			DebugLocation(79, 7);
			// Grammars\\LavishScript.g:79:7: (val+= ( ( dataSequence )=> dataSequence | quoteString ) )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if (((LA24_1>=ARG && LA24_1<=PreIf)||(LA24_1>=RCurly && LA24_1<=Xor)))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:79:7: val+= ( ( dataSequence )=> dataSequence | quoteString )
					{
					DebugLocation(79, 7);
					// Grammars\\LavishScript.g:79:9: ( ( dataSequence )=> dataSequence | quoteString )
					int alt23=2;
					try { DebugEnterSubRule(23);
					try { DebugEnterDecision(23, false);
					int LA23_1 = input.LA(1);

					if ((LA23_1==Dollar))
					{
						int LA23_2 = input.LA(2);

						if ((EvaluatePredicate(synpred4_LavishScript_fragment)))
						{
							alt23 = 1;
						}
						else if ((true))
						{
							alt23 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 23, 1, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if (((LA23_1>=ARG && LA23_1<=Do)||(LA23_1>=Dot && LA23_1<=PreIf)||(LA23_1>=RCurly && LA23_1<=Xor)))
					{
						alt23 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(23); }
					switch (alt23)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:79:10: ( dataSequence )=> dataSequence
						{
						DebugLocation(79, 26);
						PushFollow(Follow._dataSequence_in_string609);
						dataSequence85=dataSequence();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_dataSequence.Add(dataSequence85.Tree);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishScript.g:79:39: quoteString
						{
						DebugLocation(79, 39);
						PushFollow(Follow._quoteString_in_string611);
						quoteString86=quoteString();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_quoteString.Add(quoteString86.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(23); }


					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(80, 3);
			Quote87=(IToken)Match(input,Quote,Follow._Quote_in_string617); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Quote.Add(Quote87);


			}



			{
			// AST REWRITE
			// elements: val
			// token labels: 
			// rule labels: retval
			// token list labels: val
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_val=new RewriteRuleITokenStream(adaptor,"token val", list_val);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 80:9: -> ^( STRING ( $val)* )
			{
				DebugLocation(80, 11);
				// Grammars\\LavishScript.g:80:11: ^( STRING ( $val)* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(80, 13);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(STRING, "STRING"), root_1);

				DebugLocation(80, 21);
				// Grammars\\LavishScript.g:80:21: ( $val)*
				while ( stream_val.HasNext )
				{
					DebugLocation(80, 21);
					adaptor.AddChild(root_1, stream_val.NextNode());

				}
				stream_val.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string", 16);
			LeaveRule("string", 16);
			LeaveRule_string();
		}
		DebugLocation(81, 1);
		} finally { DebugExitRule(GrammarFileName, "string"); }
		return retval;

	}
	// $ANTLR end "string"

	partial void EnterRule_quoteString();
	partial void LeaveRule_quoteString();
	// $ANTLR start "quoteString"
	// Grammars\\LavishScript.g:82:8: public quoteString : ~ ( Quote ) ;
	[GrammarRule("quoteString")]
	public AstParserRuleReturnScope<CommonTree, IToken> quoteString()
	{
		EnterRule_quoteString();
		EnterRule("quoteString", 17);
		TraceIn("quoteString", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set88 = default(IToken);

		CommonTree set88_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "quoteString");
		DebugLocation(82, 1);
		try
		{
			// Grammars\\LavishScript.g:83:2: (~ ( Quote ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(83, 2);

			set88=(IToken)input.LT(1);
			if ((input.LA(1)>=ARG && input.LA(1)<=PreIf)||(input.LA(1)>=RCurly && input.LA(1)<=Xor))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set88));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quoteString", 17);
			LeaveRule("quoteString", 17);
			LeaveRule_quoteString();
		}
		DebugLocation(84, 1);
		} finally { DebugExitRule(GrammarFileName, "quoteString"); }
		return retval;

	}
	// $ANTLR end "quoteString"

	partial void EnterRule_dataSequence();
	partial void LeaveRule_dataSequence();
	// $ANTLR start "dataSequence"
	// Grammars\\LavishScript.g:85:8: public dataSequence : Dollar LCurly accessor ( member )? RCurly -> ^( Dollar accessor ( member )? ) ;
	[GrammarRule("dataSequence")]
	public AstParserRuleReturnScope<CommonTree, IToken> dataSequence()
	{
		EnterRule_dataSequence();
		EnterRule("dataSequence", 18);
		TraceIn("dataSequence", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Dollar89 = default(IToken);
		IToken LCurly90 = default(IToken);
		IToken RCurly93 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> accessor91 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> member92 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Dollar89_tree = default(CommonTree);
		CommonTree LCurly90_tree = default(CommonTree);
		CommonTree RCurly93_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Dollar=new RewriteRuleITokenStream(adaptor,"token Dollar");
		RewriteRuleITokenStream stream_LCurly=new RewriteRuleITokenStream(adaptor,"token LCurly");
		RewriteRuleITokenStream stream_RCurly=new RewriteRuleITokenStream(adaptor,"token RCurly");
		RewriteRuleSubtreeStream stream_accessor=new RewriteRuleSubtreeStream(adaptor,"rule accessor");
		RewriteRuleSubtreeStream stream_member=new RewriteRuleSubtreeStream(adaptor,"rule member");
		try { DebugEnterRule(GrammarFileName, "dataSequence");
		DebugLocation(85, 1);
		try
		{
			// Grammars\\LavishScript.g:86:2: ( Dollar LCurly accessor ( member )? RCurly -> ^( Dollar accessor ( member )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:86:4: Dollar LCurly accessor ( member )? RCurly
			{
			DebugLocation(86, 4);
			Dollar89=(IToken)Match(input,Dollar,Follow._Dollar_in_dataSequence653); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Dollar.Add(Dollar89);

			DebugLocation(86, 11);
			LCurly90=(IToken)Match(input,LCurly,Follow._LCurly_in_dataSequence655); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCurly.Add(LCurly90);

			DebugLocation(86, 18);
			PushFollow(Follow._accessor_in_dataSequence657);
			accessor91=accessor();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_accessor.Add(accessor91.Tree);
			DebugLocation(86, 27);
			// Grammars\\LavishScript.g:86:27: ( member )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==Colon||LA25_1==Dot))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:86:27: member
				{
				DebugLocation(86, 27);
				PushFollow(Follow._member_in_dataSequence659);
				member92=member();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_member.Add(member92.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(86, 35);
			RCurly93=(IToken)Match(input,RCurly,Follow._RCurly_in_dataSequence662); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCurly.Add(RCurly93);



			{
			// AST REWRITE
			// elements: Dollar, accessor, member
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 86:42: -> ^( Dollar accessor ( member )? )
			{
				DebugLocation(86, 44);
				// Grammars\\LavishScript.g:86:44: ^( Dollar accessor ( member )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(86, 46);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Dollar.NextNode(), root_1);

				DebugLocation(86, 53);
				adaptor.AddChild(root_1, stream_accessor.NextTree());
				DebugLocation(86, 62);
				// Grammars\\LavishScript.g:86:62: ( member )?
				if (stream_member.HasNext)
				{
					DebugLocation(86, 62);
					adaptor.AddChild(root_1, stream_member.NextTree());

				}
				stream_member.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dataSequence", 18);
			LeaveRule("dataSequence", 18);
			LeaveRule_dataSequence();
		}
		DebugLocation(87, 1);
		} finally { DebugExitRule(GrammarFileName, "dataSequence"); }
		return retval;

	}
	// $ANTLR end "dataSequence"

	partial void EnterRule_id();
	partial void LeaveRule_id();
	// $ANTLR start "id"
	// Grammars\\LavishScript.g:88:8: public id : ( ID ( id )? -> ^( ID ( id )? ) | dataSequence ( id )? );
	[GrammarRule("id")]
	public AstParserRuleReturnScope<CommonTree, IToken> id()
	{
		EnterRule_id();
		EnterRule("id", 19);
		TraceIn("id", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID94 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> id95 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence96 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> id97 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ID94_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
		try { DebugEnterRule(GrammarFileName, "id");
		DebugLocation(88, 1);
		try
		{
			// Grammars\\LavishScript.g:89:2: ( ID ( id )? -> ^( ID ( id )? ) | dataSequence ( id )? )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==ID))
			{
				alt28 = 1;
			}
			else if ((LA28_1==Dollar))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:89:4: ID ( id )?
				{
				DebugLocation(89, 4);
				ID94=(IToken)Match(input,ID,Follow._ID_in_id684); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID94);

				DebugLocation(89, 7);
				// Grammars\\LavishScript.g:89:7: ( id )?
				int alt26=2;
				try { DebugEnterSubRule(26);
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==Dollar||LA26_1==ID))
				{
					alt26 = 1;
				}
				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:89:7: id
					{
					DebugLocation(89, 7);
					PushFollow(Follow._id_in_id686);
					id95=id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_id.Add(id95.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(26); }



				{
				// AST REWRITE
				// elements: ID, id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 89:11: -> ^( ID ( id )? )
				{
					DebugLocation(89, 13);
					// Grammars\\LavishScript.g:89:13: ^( ID ( id )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(89, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_ID.NextNode(), root_1);

					DebugLocation(89, 18);
					// Grammars\\LavishScript.g:89:18: ( id )?
					if (stream_id.HasNext)
					{
						DebugLocation(89, 18);
						adaptor.AddChild(root_1, stream_id.NextTree());

					}
					stream_id.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:90:4: dataSequence ( id )?
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._dataSequence_in_id700);
				dataSequence96=dataSequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, dataSequence96.Tree);
				DebugLocation(90, 17);
				// Grammars\\LavishScript.g:90:17: ( id )?
				int alt27=2;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==Dollar||LA27_1==ID))
				{
					alt27 = 1;
				}
				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:90:17: id
					{
					DebugLocation(90, 17);
					PushFollow(Follow._id_in_id702);
					id97=id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, id97.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(27); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("id", 19);
			LeaveRule("id", 19);
			LeaveRule_id();
		}
		DebugLocation(91, 1);
		} finally { DebugExitRule(GrammarFileName, "id"); }
		return retval;

	}
	// $ANTLR end "id"

	partial void EnterRule_member();
	partial void LeaveRule_member();
	// $ANTLR start "member"
	// Grammars\\LavishScript.g:92:8: public member : ( Dot accessor ( member )? -> ^( Dot accessor ( member )? ) | Colon accessor ( member )? -> ^( Colon accessor ( member )? ) );
	[GrammarRule("member")]
	public AstParserRuleReturnScope<CommonTree, IToken> member()
	{
		EnterRule_member();
		EnterRule("member", 20);
		TraceIn("member", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Dot98 = default(IToken);
		IToken Colon101 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> accessor99 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> member100 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> accessor102 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> member103 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Dot98_tree = default(CommonTree);
		CommonTree Colon101_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Dot=new RewriteRuleITokenStream(adaptor,"token Dot");
		RewriteRuleITokenStream stream_Colon=new RewriteRuleITokenStream(adaptor,"token Colon");
		RewriteRuleSubtreeStream stream_accessor=new RewriteRuleSubtreeStream(adaptor,"rule accessor");
		RewriteRuleSubtreeStream stream_member=new RewriteRuleSubtreeStream(adaptor,"rule member");
		try { DebugEnterRule(GrammarFileName, "member");
		DebugLocation(92, 1);
		try
		{
			// Grammars\\LavishScript.g:93:2: ( Dot accessor ( member )? -> ^( Dot accessor ( member )? ) | Colon accessor ( member )? -> ^( Colon accessor ( member )? ) )
			int alt31=2;
			try { DebugEnterDecision(31, false);
			int LA31_1 = input.LA(1);

			if ((LA31_1==Dot))
			{
				alt31 = 1;
			}
			else if ((LA31_1==Colon))
			{
				alt31 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:93:4: Dot accessor ( member )?
				{
				DebugLocation(93, 4);
				Dot98=(IToken)Match(input,Dot,Follow._Dot_in_member715); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Dot.Add(Dot98);

				DebugLocation(93, 8);
				PushFollow(Follow._accessor_in_member717);
				accessor99=accessor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessor.Add(accessor99.Tree);
				DebugLocation(93, 17);
				// Grammars\\LavishScript.g:93:17: ( member )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==Colon||LA29_1==Dot))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:93:17: member
					{
					DebugLocation(93, 17);
					PushFollow(Follow._member_in_member719);
					member100=member();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_member.Add(member100.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(29); }



				{
				// AST REWRITE
				// elements: Dot, accessor, member
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 93:25: -> ^( Dot accessor ( member )? )
				{
					DebugLocation(93, 27);
					// Grammars\\LavishScript.g:93:27: ^( Dot accessor ( member )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(93, 29);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_Dot.NextNode(), root_1);

					DebugLocation(93, 33);
					adaptor.AddChild(root_1, stream_accessor.NextTree());
					DebugLocation(93, 42);
					// Grammars\\LavishScript.g:93:42: ( member )?
					if (stream_member.HasNext)
					{
						DebugLocation(93, 42);
						adaptor.AddChild(root_1, stream_member.NextTree());

					}
					stream_member.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:94:4: Colon accessor ( member )?
				{
				DebugLocation(94, 4);
				Colon101=(IToken)Match(input,Colon,Follow._Colon_in_member735); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Colon.Add(Colon101);

				DebugLocation(94, 10);
				PushFollow(Follow._accessor_in_member737);
				accessor102=accessor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessor.Add(accessor102.Tree);
				DebugLocation(94, 19);
				// Grammars\\LavishScript.g:94:19: ( member )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==Colon||LA30_1==Dot))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:94:19: member
					{
					DebugLocation(94, 19);
					PushFollow(Follow._member_in_member739);
					member103=member();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_member.Add(member103.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(30); }



				{
				// AST REWRITE
				// elements: Colon, accessor, member
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 94:26: -> ^( Colon accessor ( member )? )
				{
					DebugLocation(94, 28);
					// Grammars\\LavishScript.g:94:28: ^( Colon accessor ( member )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(94, 30);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_Colon.NextNode(), root_1);

					DebugLocation(94, 36);
					adaptor.AddChild(root_1, stream_accessor.NextTree());
					DebugLocation(94, 45);
					// Grammars\\LavishScript.g:94:45: ( member )?
					if (stream_member.HasNext)
					{
						DebugLocation(94, 45);
						adaptor.AddChild(root_1, stream_member.NextTree());

					}
					stream_member.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("member", 20);
			LeaveRule("member", 20);
			LeaveRule_member();
		}
		DebugLocation(95, 1);
		} finally { DebugExitRule(GrammarFileName, "member"); }
		return retval;

	}
	// $ANTLR end "member"

	partial void EnterRule_dataCommand();
	partial void LeaveRule_dataCommand();
	// $ANTLR start "dataCommand"
	// Grammars\\LavishScript.g:97:8: public dataCommand : accessor member ;
	[GrammarRule("dataCommand")]
	public AstParserRuleReturnScope<CommonTree, IToken> dataCommand()
	{
		EnterRule_dataCommand();
		EnterRule("dataCommand", 21);
		TraceIn("dataCommand", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> accessor104 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> member105 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "dataCommand");
		DebugLocation(97, 1);
		try
		{
			// Grammars\\LavishScript.g:98:2: ( accessor member )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:98:4: accessor member
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(98, 4);
			PushFollow(Follow._accessor_in_dataCommand762);
			accessor104=accessor();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, accessor104.Tree);
			DebugLocation(98, 13);
			PushFollow(Follow._member_in_dataCommand764);
			member105=member();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, member105.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dataCommand", 21);
			LeaveRule("dataCommand", 21);
			LeaveRule_dataCommand();
		}
		DebugLocation(99, 1);
		} finally { DebugExitRule(GrammarFileName, "dataCommand"); }
		return retval;

	}
	// $ANTLR end "dataCommand"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// Grammars\\LavishScript.g:100:8: public switchStatement : Switch ( ( lineArg )+ ) NewLine LCurly ( NewLine ( NewLine )* switchCase )* ( NewLine ( NewLine )* defaultCase )? NewLine RCurly -> ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? ) ;
	[GrammarRule("switchStatement")]
	public AstParserRuleReturnScope<CommonTree, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 22);
		TraceIn("switchStatement", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Switch106 = default(IToken);
		IToken NewLine108 = default(IToken);
		IToken LCurly109 = default(IToken);
		IToken NewLine110 = default(IToken);
		IToken NewLine111 = default(IToken);
		IToken NewLine113 = default(IToken);
		IToken NewLine114 = default(IToken);
		IToken NewLine116 = default(IToken);
		IToken RCurly117 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg107 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> switchCase112 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> defaultCase115 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Switch106_tree = default(CommonTree);
		CommonTree NewLine108_tree = default(CommonTree);
		CommonTree LCurly109_tree = default(CommonTree);
		CommonTree NewLine110_tree = default(CommonTree);
		CommonTree NewLine111_tree = default(CommonTree);
		CommonTree NewLine113_tree = default(CommonTree);
		CommonTree NewLine114_tree = default(CommonTree);
		CommonTree NewLine116_tree = default(CommonTree);
		CommonTree RCurly117_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Switch=new RewriteRuleITokenStream(adaptor,"token Switch");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleITokenStream stream_LCurly=new RewriteRuleITokenStream(adaptor,"token LCurly");
		RewriteRuleITokenStream stream_RCurly=new RewriteRuleITokenStream(adaptor,"token RCurly");
		RewriteRuleSubtreeStream stream_lineArg=new RewriteRuleSubtreeStream(adaptor,"rule lineArg");
		RewriteRuleSubtreeStream stream_switchCase=new RewriteRuleSubtreeStream(adaptor,"rule switchCase");
		RewriteRuleSubtreeStream stream_defaultCase=new RewriteRuleSubtreeStream(adaptor,"rule defaultCase");
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(100, 1);
		try
		{
			// Grammars\\LavishScript.g:101:2: ( Switch ( ( lineArg )+ ) NewLine LCurly ( NewLine ( NewLine )* switchCase )* ( NewLine ( NewLine )* defaultCase )? NewLine RCurly -> ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:101:4: Switch ( ( lineArg )+ ) NewLine LCurly ( NewLine ( NewLine )* switchCase )* ( NewLine ( NewLine )* defaultCase )? NewLine RCurly
			{
			DebugLocation(101, 4);
			Switch106=(IToken)Match(input,Switch,Follow._Switch_in_switchStatement776); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Switch.Add(Switch106);

			DebugLocation(101, 11);
			// Grammars\\LavishScript.g:101:11: ( ( lineArg )+ )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:101:12: ( lineArg )+
			{
			DebugLocation(101, 12);
			// Grammars\\LavishScript.g:101:12: ( lineArg )+
			int cnt32=0;
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if (((LA32_1>=ARG && LA32_1<=Negate)||(LA32_1>=NotEqualTo && LA32_1<=Xor)))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:101:12: lineArg
					{
					DebugLocation(101, 12);
					PushFollow(Follow._lineArg_in_switchStatement779);
					lineArg107=lineArg();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_lineArg.Add(lineArg107.Tree);

					}
					break;

				default:
					if (cnt32 >= 1)
						goto loop32;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee32 = new EarlyExitException( 32, input );
					DebugRecognitionException(eee32);
					throw eee32;
				}
				cnt32++;
			}
			loop32:
				;

			} finally { DebugExitSubRule(32); }


			}

			DebugLocation(101, 22);
			NewLine108=(IToken)Match(input,NewLine,Follow._NewLine_in_switchStatement783); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine108);

			DebugLocation(102, 3);
			LCurly109=(IToken)Match(input,LCurly,Follow._LCurly_in_switchStatement787); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCurly.Add(LCurly109);

			DebugLocation(103, 3);
			// Grammars\\LavishScript.g:103:3: ( NewLine ( NewLine )* switchCase )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				try
				{
					alt34 = dfa34.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:103:4: NewLine ( NewLine )* switchCase
					{
					DebugLocation(103, 4);
					NewLine110=(IToken)Match(input,NewLine,Follow._NewLine_in_switchStatement792); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_NewLine.Add(NewLine110);

					DebugLocation(103, 12);
					// Grammars\\LavishScript.g:103:12: ( NewLine )*
					try { DebugEnterSubRule(33);
					while (true)
					{
						int alt33=2;
						try { DebugEnterDecision(33, false);
						int LA33_1 = input.LA(1);

						if ((LA33_1==NewLine))
						{
							alt33 = 1;
						}


						} finally { DebugExitDecision(33); }
						switch ( alt33 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LavishScript.g:103:12: NewLine
							{
							DebugLocation(103, 12);
							NewLine111=(IToken)Match(input,NewLine,Follow._NewLine_in_switchStatement794); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_NewLine.Add(NewLine111);


							}
							break;

						default:
							goto loop33;
						}
					}

					loop33:
						;

					} finally { DebugExitSubRule(33); }

					DebugLocation(103, 21);
					PushFollow(Follow._switchCase_in_switchStatement797);
					switchCase112=switchCase();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_switchCase.Add(switchCase112.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(104, 3);
			// Grammars\\LavishScript.g:104:3: ( NewLine ( NewLine )* defaultCase )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==NewLine))
			{
				int LA36_2 = input.LA(2);

				if ((LA36_2==Default||LA36_2==NewLine))
				{
					alt36 = 1;
				}
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:104:4: NewLine ( NewLine )* defaultCase
				{
				DebugLocation(104, 4);
				NewLine113=(IToken)Match(input,NewLine,Follow._NewLine_in_switchStatement804); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NewLine.Add(NewLine113);

				DebugLocation(104, 12);
				// Grammars\\LavishScript.g:104:12: ( NewLine )*
				try { DebugEnterSubRule(35);
				while (true)
				{
					int alt35=2;
					try { DebugEnterDecision(35, false);
					int LA35_1 = input.LA(1);

					if ((LA35_1==NewLine))
					{
						alt35 = 1;
					}


					} finally { DebugExitDecision(35); }
					switch ( alt35 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:104:12: NewLine
						{
						DebugLocation(104, 12);
						NewLine114=(IToken)Match(input,NewLine,Follow._NewLine_in_switchStatement806); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_NewLine.Add(NewLine114);


						}
						break;

					default:
						goto loop35;
					}
				}

				loop35:
					;

				} finally { DebugExitSubRule(35); }

				DebugLocation(104, 21);
				PushFollow(Follow._defaultCase_in_switchStatement809);
				defaultCase115=defaultCase();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_defaultCase.Add(defaultCase115.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(36); }

			DebugLocation(105, 3);
			NewLine116=(IToken)Match(input,NewLine,Follow._NewLine_in_switchStatement815); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine116);

			DebugLocation(105, 11);
			RCurly117=(IToken)Match(input,RCurly,Follow._RCurly_in_switchStatement817); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCurly.Add(RCurly117);



			{
			// AST REWRITE
			// elements: Switch, lineArg, switchCase, defaultCase
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 106:3: -> ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? )
			{
				DebugLocation(106, 5);
				// Grammars\\LavishScript.g:106:5: ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(106, 7);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Switch.NextNode(), root_1);

				DebugLocation(106, 14);
				// Grammars\\LavishScript.g:106:14: ^( Param ( lineArg )+ )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(106, 16);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Param, "Param"), root_2);

				DebugLocation(106, 22);
				if (!(stream_lineArg.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_lineArg.HasNext )
				{
					DebugLocation(106, 22);
					adaptor.AddChild(root_2, stream_lineArg.NextTree());

				}
				stream_lineArg.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(106, 32);
				// Grammars\\LavishScript.g:106:32: ( switchCase )*
				while ( stream_switchCase.HasNext )
				{
					DebugLocation(106, 32);
					adaptor.AddChild(root_1, stream_switchCase.NextTree());

				}
				stream_switchCase.Reset();
				DebugLocation(106, 44);
				// Grammars\\LavishScript.g:106:44: ( defaultCase )?
				if (stream_defaultCase.HasNext)
				{
					DebugLocation(106, 44);
					adaptor.AddChild(root_1, stream_defaultCase.NextTree());

				}
				stream_defaultCase.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 22);
			LeaveRule("switchStatement", 22);
			LeaveRule_switchStatement();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_switchCase();
	partial void LeaveRule_switchCase();
	// $ANTLR start "switchCase"
	// Grammars\\LavishScript.g:108:8: public switchCase : ( Case ( lineArg )+ ( expression )* -> ^( Case ^( Param ( lineArg )+ ) ( expression )* ) | VariableCase dataSequence ( expression )* -> ^( VariableCase dataSequence ( expression )* ) );
	[GrammarRule("switchCase")]
	public AstParserRuleReturnScope<CommonTree, IToken> switchCase()
	{
		EnterRule_switchCase();
		EnterRule("switchCase", 23);
		TraceIn("switchCase", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Case118 = default(IToken);
		IToken VariableCase121 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg119 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression120 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence122 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression123 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Case118_tree = default(CommonTree);
		CommonTree VariableCase121_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Case=new RewriteRuleITokenStream(adaptor,"token Case");
		RewriteRuleITokenStream stream_VariableCase=new RewriteRuleITokenStream(adaptor,"token VariableCase");
		RewriteRuleSubtreeStream stream_lineArg=new RewriteRuleSubtreeStream(adaptor,"rule lineArg");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_dataSequence=new RewriteRuleSubtreeStream(adaptor,"rule dataSequence");
		try { DebugEnterRule(GrammarFileName, "switchCase");
		DebugLocation(108, 1);
		try
		{
			// Grammars\\LavishScript.g:109:2: ( Case ( lineArg )+ ( expression )* -> ^( Case ^( Param ( lineArg )+ ) ( expression )* ) | VariableCase dataSequence ( expression )* -> ^( VariableCase dataSequence ( expression )* ) )
			int alt40=2;
			try { DebugEnterDecision(40, false);
			int LA40_1 = input.LA(1);

			if ((LA40_1==Case))
			{
				alt40 = 1;
			}
			else if ((LA40_1==VariableCase))
			{
				alt40 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 40, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:109:4: Case ( lineArg )+ ( expression )*
				{
				DebugLocation(109, 4);
				Case118=(IToken)Match(input,Case,Follow._Case_in_switchCase849); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Case.Add(Case118);

				DebugLocation(109, 9);
				// Grammars\\LavishScript.g:109:9: ( lineArg )+
				int cnt37=0;
				try { DebugEnterSubRule(37);
				while (true)
				{
					int alt37=2;
					try { DebugEnterDecision(37, false);
					int LA37_1 = input.LA(1);

					if (((LA37_1>=ARG && LA37_1<=Negate)||(LA37_1>=NotEqualTo && LA37_1<=Xor)))
					{
						alt37 = 1;
					}


					} finally { DebugExitDecision(37); }
					switch (alt37)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:109:9: lineArg
						{
						DebugLocation(109, 9);
						PushFollow(Follow._lineArg_in_switchCase851);
						lineArg119=lineArg();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_lineArg.Add(lineArg119.Tree);

						}
						break;

					default:
						if (cnt37 >= 1)
							goto loop37;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee37 = new EarlyExitException( 37, input );
						DebugRecognitionException(eee37);
						throw eee37;
					}
					cnt37++;
				}
				loop37:
					;

				} finally { DebugExitSubRule(37); }

				DebugLocation(109, 18);
				// Grammars\\LavishScript.g:109:18: ( expression )*
				try { DebugEnterSubRule(38);
				while (true)
				{
					int alt38=2;
					try { DebugEnterDecision(38, false);
					int LA38_1 = input.LA(1);

					if ((LA38_1==NewLine))
					{
						int LA38_2 = input.LA(2);

						if ((LA38_2==DeclareVariable||LA38_2==Define||(LA38_2>=Do && LA38_2<=Dollar)||LA38_2==Echo||LA38_2==Error||LA38_2==For||LA38_2==ID||(LA38_2>=If && LA38_2<=Include)||LA38_2==LCurly||LA38_2==Macro||LA38_2==NewLine||LA38_2==PreIf||LA38_2==Switch||(LA38_2>=Unmac && LA38_2<=Variable)||(LA38_2>=WS && LA38_2<=While)))
						{
							alt38 = 1;
						}


					}


					} finally { DebugExitDecision(38); }
					switch ( alt38 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:109:18: expression
						{
						DebugLocation(109, 18);
						PushFollow(Follow._expression_in_switchCase854);
						expression120=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(expression120.Tree);

						}
						break;

					default:
						goto loop38;
					}
				}

				loop38:
					;

				} finally { DebugExitSubRule(38); }



				{
				// AST REWRITE
				// elements: Case, lineArg, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 109:30: -> ^( Case ^( Param ( lineArg )+ ) ( expression )* )
				{
					DebugLocation(109, 32);
					// Grammars\\LavishScript.g:109:32: ^( Case ^( Param ( lineArg )+ ) ( expression )* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(109, 34);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_Case.NextNode(), root_1);

					DebugLocation(109, 39);
					// Grammars\\LavishScript.g:109:39: ^( Param ( lineArg )+ )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(109, 41);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Param, "Param"), root_2);

					DebugLocation(109, 47);
					if (!(stream_lineArg.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_lineArg.HasNext )
					{
						DebugLocation(109, 47);
						adaptor.AddChild(root_2, stream_lineArg.NextTree());

					}
					stream_lineArg.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(109, 57);
					// Grammars\\LavishScript.g:109:57: ( expression )*
					while ( stream_expression.HasNext )
					{
						DebugLocation(109, 57);
						adaptor.AddChild(root_1, stream_expression.NextTree());

					}
					stream_expression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:110:4: VariableCase dataSequence ( expression )*
				{
				DebugLocation(110, 4);
				VariableCase121=(IToken)Match(input,VariableCase,Follow._VariableCase_in_switchCase875); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VariableCase.Add(VariableCase121);

				DebugLocation(110, 17);
				PushFollow(Follow._dataSequence_in_switchCase877);
				dataSequence122=dataSequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dataSequence.Add(dataSequence122.Tree);
				DebugLocation(110, 30);
				// Grammars\\LavishScript.g:110:30: ( expression )*
				try { DebugEnterSubRule(39);
				while (true)
				{
					int alt39=2;
					try { DebugEnterDecision(39, false);
					int LA39_1 = input.LA(1);

					if ((LA39_1==NewLine))
					{
						int LA39_2 = input.LA(2);

						if ((LA39_2==DeclareVariable||LA39_2==Define||(LA39_2>=Do && LA39_2<=Dollar)||LA39_2==Echo||LA39_2==Error||LA39_2==For||LA39_2==ID||(LA39_2>=If && LA39_2<=Include)||LA39_2==LCurly||LA39_2==Macro||LA39_2==NewLine||LA39_2==PreIf||LA39_2==Switch||(LA39_2>=Unmac && LA39_2<=Variable)||(LA39_2>=WS && LA39_2<=While)))
						{
							alt39 = 1;
						}


					}


					} finally { DebugExitDecision(39); }
					switch ( alt39 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:110:30: expression
						{
						DebugLocation(110, 30);
						PushFollow(Follow._expression_in_switchCase879);
						expression123=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(expression123.Tree);

						}
						break;

					default:
						goto loop39;
					}
				}

				loop39:
					;

				} finally { DebugExitSubRule(39); }



				{
				// AST REWRITE
				// elements: VariableCase, dataSequence, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 110:41: -> ^( VariableCase dataSequence ( expression )* )
				{
					DebugLocation(110, 43);
					// Grammars\\LavishScript.g:110:43: ^( VariableCase dataSequence ( expression )* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(110, 45);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_VariableCase.NextNode(), root_1);

					DebugLocation(110, 58);
					adaptor.AddChild(root_1, stream_dataSequence.NextTree());
					DebugLocation(110, 71);
					// Grammars\\LavishScript.g:110:71: ( expression )*
					while ( stream_expression.HasNext )
					{
						DebugLocation(110, 71);
						adaptor.AddChild(root_1, stream_expression.NextTree());

					}
					stream_expression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchCase", 23);
			LeaveRule("switchCase", 23);
			LeaveRule_switchCase();
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "switchCase"); }
		return retval;

	}
	// $ANTLR end "switchCase"

	partial void EnterRule_defaultCase();
	partial void LeaveRule_defaultCase();
	// $ANTLR start "defaultCase"
	// Grammars\\LavishScript.g:112:8: public defaultCase : Default ^ ( expression )* ;
	[GrammarRule("defaultCase")]
	public AstParserRuleReturnScope<CommonTree, IToken> defaultCase()
	{
		EnterRule_defaultCase();
		EnterRule("defaultCase", 24);
		TraceIn("defaultCase", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Default124 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression125 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Default124_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "defaultCase");
		DebugLocation(112, 1);
		try
		{
			// Grammars\\LavishScript.g:113:2: ( Default ^ ( expression )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:113:4: Default ^ ( expression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(113, 11);
			Default124=(IToken)Match(input,Default,Follow._Default_in_defaultCase901); if (state.failed) return retval;
			if (state.backtracking == 0) {
			Default124_tree = (CommonTree)adaptor.Create(Default124);
			root_0 = (CommonTree)adaptor.BecomeRoot(Default124_tree, root_0);
			}
			DebugLocation(113, 13);
			// Grammars\\LavishScript.g:113:13: ( expression )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==NewLine))
				{
					int LA41_2 = input.LA(2);

					if ((LA41_2==DeclareVariable||LA41_2==Define||(LA41_2>=Do && LA41_2<=Dollar)||LA41_2==Echo||LA41_2==Error||LA41_2==For||LA41_2==ID||(LA41_2>=If && LA41_2<=Include)||LA41_2==LCurly||LA41_2==Macro||LA41_2==NewLine||LA41_2==PreIf||LA41_2==Switch||(LA41_2>=Unmac && LA41_2<=Variable)||(LA41_2>=WS && LA41_2<=While)))
					{
						alt41 = 1;
					}


				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:113:13: expression
					{
					DebugLocation(113, 13);
					PushFollow(Follow._expression_in_defaultCase904);
					expression125=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expression125.Tree);

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultCase", 24);
			LeaveRule("defaultCase", 24);
			LeaveRule_defaultCase();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultCase"); }
		return retval;

	}
	// $ANTLR end "defaultCase"

	partial void EnterRule_objectDef();
	partial void LeaveRule_objectDef();
	// $ANTLR start "objectDef"
	// Grammars\\LavishScript.g:116:8: public objectDef : ObjectDef WS ID WS ( Inherits WS ID )? NewLine LCurly ( ( NewLine )+ (members+= function |members+= atom |members+= objectMethod |members+= objectMember |members+= variableDeclare )? )+ RCurly -> ^( ObjectDef ^( ID ( $members)* ) ( ^( Inherits ID ) )? ) ;
	[GrammarRule("objectDef")]
	public AstParserRuleReturnScope<CommonTree, IToken> objectDef()
	{
		EnterRule_objectDef();
		EnterRule("objectDef", 25);
		TraceIn("objectDef", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ObjectDef126 = default(IToken);
		IToken WS127 = default(IToken);
		IToken ID128 = default(IToken);
		IToken WS129 = default(IToken);
		IToken Inherits130 = default(IToken);
		IToken WS131 = default(IToken);
		IToken ID132 = default(IToken);
		IToken NewLine133 = default(IToken);
		IToken LCurly134 = default(IToken);
		IToken NewLine135 = default(IToken);
		IToken RCurly136 = default(IToken);
		List<CommonTree> list_members = null;
		AstParserRuleReturnScope<CommonTree, IToken> members = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree ObjectDef126_tree = default(CommonTree);
		CommonTree WS127_tree = default(CommonTree);
		CommonTree ID128_tree = default(CommonTree);
		CommonTree WS129_tree = default(CommonTree);
		CommonTree Inherits130_tree = default(CommonTree);
		CommonTree WS131_tree = default(CommonTree);
		CommonTree ID132_tree = default(CommonTree);
		CommonTree NewLine133_tree = default(CommonTree);
		CommonTree LCurly134_tree = default(CommonTree);
		CommonTree NewLine135_tree = default(CommonTree);
		CommonTree RCurly136_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ObjectDef=new RewriteRuleITokenStream(adaptor,"token ObjectDef");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_Inherits=new RewriteRuleITokenStream(adaptor,"token Inherits");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleITokenStream stream_LCurly=new RewriteRuleITokenStream(adaptor,"token LCurly");
		RewriteRuleITokenStream stream_RCurly=new RewriteRuleITokenStream(adaptor,"token RCurly");
		RewriteRuleSubtreeStream stream_function=new RewriteRuleSubtreeStream(adaptor,"rule function");
		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		RewriteRuleSubtreeStream stream_objectMethod=new RewriteRuleSubtreeStream(adaptor,"rule objectMethod");
		RewriteRuleSubtreeStream stream_objectMember=new RewriteRuleSubtreeStream(adaptor,"rule objectMember");
		RewriteRuleSubtreeStream stream_variableDeclare=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclare");
		try { DebugEnterRule(GrammarFileName, "objectDef");
		DebugLocation(116, 1);
		try
		{
			// Grammars\\LavishScript.g:117:2: ( ObjectDef WS ID WS ( Inherits WS ID )? NewLine LCurly ( ( NewLine )+ (members+= function |members+= atom |members+= objectMethod |members+= objectMember |members+= variableDeclare )? )+ RCurly -> ^( ObjectDef ^( ID ( $members)* ) ( ^( Inherits ID ) )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:117:4: ObjectDef WS ID WS ( Inherits WS ID )? NewLine LCurly ( ( NewLine )+ (members+= function |members+= atom |members+= objectMethod |members+= objectMember |members+= variableDeclare )? )+ RCurly
			{
			DebugLocation(117, 4);
			ObjectDef126=(IToken)Match(input,ObjectDef,Follow._ObjectDef_in_objectDef918); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ObjectDef.Add(ObjectDef126);

			DebugLocation(117, 14);
			WS127=(IToken)Match(input,WS,Follow._WS_in_objectDef920); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS127);

			DebugLocation(117, 17);
			ID128=(IToken)Match(input,ID,Follow._ID_in_objectDef922); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID128);

			DebugLocation(117, 20);
			WS129=(IToken)Match(input,WS,Follow._WS_in_objectDef924); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS129);

			DebugLocation(117, 23);
			// Grammars\\LavishScript.g:117:23: ( Inherits WS ID )?
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1==Inherits))
			{
				alt42 = 1;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:117:24: Inherits WS ID
				{
				DebugLocation(117, 24);
				Inherits130=(IToken)Match(input,Inherits,Follow._Inherits_in_objectDef927); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Inherits.Add(Inherits130);

				DebugLocation(117, 33);
				WS131=(IToken)Match(input,WS,Follow._WS_in_objectDef929); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS131);

				DebugLocation(117, 36);
				ID132=(IToken)Match(input,ID,Follow._ID_in_objectDef931); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID132);


				}
				break;

			}
			} finally { DebugExitSubRule(42); }

			DebugLocation(117, 41);
			NewLine133=(IToken)Match(input,NewLine,Follow._NewLine_in_objectDef935); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine133);

			DebugLocation(118, 3);
			LCurly134=(IToken)Match(input,LCurly,Follow._LCurly_in_objectDef939); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCurly.Add(LCurly134);

			DebugLocation(119, 4);
			// Grammars\\LavishScript.g:119:4: ( ( NewLine )+ (members+= function |members+= atom |members+= objectMethod |members+= objectMember |members+= variableDeclare )? )+
			int cnt45=0;
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=2;
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==NewLine))
				{
					alt45 = 1;
				}


				} finally { DebugExitDecision(45); }
				switch (alt45)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:119:5: ( NewLine )+ (members+= function |members+= atom |members+= objectMethod |members+= objectMember |members+= variableDeclare )?
					{
					DebugLocation(119, 5);
					// Grammars\\LavishScript.g:119:5: ( NewLine )+
					int cnt43=0;
					try { DebugEnterSubRule(43);
					while (true)
					{
						int alt43=2;
						try { DebugEnterDecision(43, false);
						int LA43_1 = input.LA(1);

						if ((LA43_1==NewLine))
						{
							alt43 = 1;
						}


						} finally { DebugExitDecision(43); }
						switch (alt43)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LavishScript.g:119:5: NewLine
							{
							DebugLocation(119, 5);
							NewLine135=(IToken)Match(input,NewLine,Follow._NewLine_in_objectDef945); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_NewLine.Add(NewLine135);


							}
							break;

						default:
							if (cnt43 >= 1)
								goto loop43;

							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee43 = new EarlyExitException( 43, input );
							DebugRecognitionException(eee43);
							throw eee43;
						}
						cnt43++;
					}
					loop43:
						;

					} finally { DebugExitSubRule(43); }

					DebugLocation(119, 14);
					// Grammars\\LavishScript.g:119:14: (members+= function |members+= atom |members+= objectMethod |members+= objectMember |members+= variableDeclare )?
					int alt44=6;
					try { DebugEnterSubRule(44);
					try { DebugEnterDecision(44, false);
					switch (input.LA(1))
					{
					case Function:
						{
						alt44 = 1;
						}
						break;
					case Atom:
						{
						alt44 = 2;
						}
						break;
					case Method:
						{
						alt44 = 3;
						}
						break;
					case Member:
						{
						alt44 = 4;
						}
						break;
					case Variable:
						{
						alt44 = 5;
						}
						break;
					}

					} finally { DebugExitDecision(44); }
					switch (alt44)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:119:15: members+= function
						{
						DebugLocation(119, 22);
						PushFollow(Follow._function_in_objectDef951);
						members=function();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_function.Add(members.Tree);
						if (list_members==null) list_members=new List<CommonTree>();
						list_members.Add(members.Tree);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishScript.g:119:33: members+= atom
						{
						DebugLocation(119, 40);
						PushFollow(Follow._atom_in_objectDef955);
						members=atom();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_atom.Add(members.Tree);
						if (list_members==null) list_members=new List<CommonTree>();
						list_members.Add(members.Tree);


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Grammars\\LavishScript.g:119:47: members+= objectMethod
						{
						DebugLocation(119, 54);
						PushFollow(Follow._objectMethod_in_objectDef959);
						members=objectMethod();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_objectMethod.Add(members.Tree);
						if (list_members==null) list_members=new List<CommonTree>();
						list_members.Add(members.Tree);


						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Grammars\\LavishScript.g:119:69: members+= objectMember
						{
						DebugLocation(119, 76);
						PushFollow(Follow._objectMember_in_objectDef963);
						members=objectMember();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_objectMember.Add(members.Tree);
						if (list_members==null) list_members=new List<CommonTree>();
						list_members.Add(members.Tree);


						}
						break;
					case 5:
						DebugEnterAlt(5);
						// Grammars\\LavishScript.g:119:91: members+= variableDeclare
						{
						DebugLocation(119, 98);
						PushFollow(Follow._variableDeclare_in_objectDef967);
						members=variableDeclare();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_variableDeclare.Add(members.Tree);
						if (list_members==null) list_members=new List<CommonTree>();
						list_members.Add(members.Tree);


						}
						break;

					}
					} finally { DebugExitSubRule(44); }


					}
					break;

				default:
					if (cnt45 >= 1)
						goto loop45;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee45 = new EarlyExitException( 45, input );
					DebugRecognitionException(eee45);
					throw eee45;
				}
				cnt45++;
			}
			loop45:
				;

			} finally { DebugExitSubRule(45); }

			DebugLocation(120, 3);
			RCurly136=(IToken)Match(input,RCurly,Follow._RCurly_in_objectDef975); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCurly.Add(RCurly136);



			{
			// AST REWRITE
			// elements: ObjectDef, ID, members, Inherits, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: members
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_members=new RewriteRuleSubtreeStream(adaptor,"token members",list_members);
			root_0 = (CommonTree)adaptor.Nil();
			// 121:4: -> ^( ObjectDef ^( ID ( $members)* ) ( ^( Inherits ID ) )? )
			{
				DebugLocation(121, 6);
				// Grammars\\LavishScript.g:121:6: ^( ObjectDef ^( ID ( $members)* ) ( ^( Inherits ID ) )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(121, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_ObjectDef.NextNode(), root_1);

				DebugLocation(121, 18);
				// Grammars\\LavishScript.g:121:18: ^( ID ( $members)* )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(121, 20);
				root_2 = (CommonTree)adaptor.BecomeRoot(stream_ID.NextNode(), root_2);

				DebugLocation(121, 24);
				// Grammars\\LavishScript.g:121:24: ( $members)*
				while ( stream_members.HasNext )
				{
					DebugLocation(121, 24);
					adaptor.AddChild(root_2, stream_members.NextTree());

				}
				stream_members.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(121, 34);
				// Grammars\\LavishScript.g:121:34: ( ^( Inherits ID ) )?
				if (stream_Inherits.HasNext||stream_ID.HasNext)
				{
					DebugLocation(121, 34);
					// Grammars\\LavishScript.g:121:34: ^( Inherits ID )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(121, 36);
					root_2 = (CommonTree)adaptor.BecomeRoot(stream_Inherits.NextNode(), root_2);

					DebugLocation(121, 45);
					adaptor.AddChild(root_2, stream_ID.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_Inherits.Reset();
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectDef", 25);
			LeaveRule("objectDef", 25);
			LeaveRule_objectDef();
		}
		DebugLocation(122, 1);
		} finally { DebugExitRule(GrammarFileName, "objectDef"); }
		return retval;

	}
	// $ANTLR end "objectDef"

	partial void EnterRule_function();
	partial void LeaveRule_function();
	// $ANTLR start "function"
	// Grammars\\LavishScript.g:123:8: public function : Function ( Colon returnType= ID )? WS name= ID params NewLine codeBlock -> ^( Function $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) ;
	[GrammarRule("function")]
	public AstParserRuleReturnScope<CommonTree, IToken> function()
	{
		EnterRule_function();
		EnterRule("function", 26);
		TraceIn("function", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken returnType = default(IToken);
		IToken name = default(IToken);
		IToken Function137 = default(IToken);
		IToken Colon138 = default(IToken);
		IToken WS139 = default(IToken);
		IToken NewLine141 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> params140 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> codeBlock142 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree returnType_tree = default(CommonTree);
		CommonTree name_tree = default(CommonTree);
		CommonTree Function137_tree = default(CommonTree);
		CommonTree Colon138_tree = default(CommonTree);
		CommonTree WS139_tree = default(CommonTree);
		CommonTree NewLine141_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Function=new RewriteRuleITokenStream(adaptor,"token Function");
		RewriteRuleITokenStream stream_Colon=new RewriteRuleITokenStream(adaptor,"token Colon");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"rule params");
		RewriteRuleSubtreeStream stream_codeBlock=new RewriteRuleSubtreeStream(adaptor,"rule codeBlock");
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(123, 1);
		try
		{
			// Grammars\\LavishScript.g:124:2: ( Function ( Colon returnType= ID )? WS name= ID params NewLine codeBlock -> ^( Function $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:124:4: Function ( Colon returnType= ID )? WS name= ID params NewLine codeBlock
			{
			DebugLocation(124, 4);
			Function137=(IToken)Match(input,Function,Follow._Function_in_function1010); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Function.Add(Function137);

			DebugLocation(124, 12);
			// Grammars\\LavishScript.g:124:12: ( Colon returnType= ID )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1==Colon))
			{
				alt46 = 1;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:124:13: Colon returnType= ID
				{
				DebugLocation(124, 13);
				Colon138=(IToken)Match(input,Colon,Follow._Colon_in_function1012); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Colon.Add(Colon138);

				DebugLocation(124, 29);
				returnType=(IToken)Match(input,ID,Follow._ID_in_function1016); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(returnType);


				}
				break;

			}
			} finally { DebugExitSubRule(46); }

			DebugLocation(124, 34);
			WS139=(IToken)Match(input,WS,Follow._WS_in_function1019); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS139);

			DebugLocation(124, 41);
			name=(IToken)Match(input,ID,Follow._ID_in_function1023); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(124, 45);
			PushFollow(Follow._params_in_function1025);
			params140=@params();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_params.Add(params140.Tree);
			DebugLocation(124, 52);
			NewLine141=(IToken)Match(input,NewLine,Follow._NewLine_in_function1027); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine141);

			DebugLocation(124, 60);
			PushFollow(Follow._codeBlock_in_function1029);
			codeBlock142=codeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_codeBlock.Add(codeBlock142.Tree);


			{
			// AST REWRITE
			// elements: Function, name, returnType, params, codeBlock
			// token labels: name, returnType
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleITokenStream stream_returnType=new RewriteRuleITokenStream(adaptor,"token returnType",returnType);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 125:4: -> ^( Function $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
			{
				DebugLocation(125, 6);
				// Grammars\\LavishScript.g:125:6: ^( Function $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(125, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Function.NextNode(), root_1);

				DebugLocation(125, 18);
				adaptor.AddChild(root_1, stream_name.NextNode());
				DebugLocation(125, 23);
				// Grammars\\LavishScript.g:125:23: ^( Returns ( $returnType)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(125, 25);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Returns, "Returns"), root_2);

				DebugLocation(125, 34);
				// Grammars\\LavishScript.g:125:34: ( $returnType)?
				if (stream_returnType.HasNext)
				{
					DebugLocation(125, 34);
					adaptor.AddChild(root_2, stream_returnType.NextNode());

				}
				stream_returnType.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(125, 48);
				// Grammars\\LavishScript.g:125:48: ( params )?
				if (stream_params.HasNext)
				{
					DebugLocation(125, 48);
					adaptor.AddChild(root_1, stream_params.NextTree());

				}
				stream_params.Reset();
				DebugLocation(125, 56);
				adaptor.AddChild(root_1, stream_codeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function", 26);
			LeaveRule("function", 26);
			LeaveRule_function();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return retval;

	}
	// $ANTLR end "function"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\LavishScript.g:127:8: public atom : Atom ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock -> ^( Atom $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) ;
	[GrammarRule("atom")]
	public AstParserRuleReturnScope<CommonTree, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 27);
		TraceIn("atom", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken returnType = default(IToken);
		IToken name = default(IToken);
		IToken Atom143 = default(IToken);
		IToken Colon144 = default(IToken);
		IToken LParen145 = default(IToken);
		IToken RParen147 = default(IToken);
		IToken NewLine148 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> params146 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> codeBlock149 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree returnType_tree = default(CommonTree);
		CommonTree name_tree = default(CommonTree);
		CommonTree Atom143_tree = default(CommonTree);
		CommonTree Colon144_tree = default(CommonTree);
		CommonTree LParen145_tree = default(CommonTree);
		CommonTree RParen147_tree = default(CommonTree);
		CommonTree NewLine148_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Atom=new RewriteRuleITokenStream(adaptor,"token Atom");
		RewriteRuleITokenStream stream_Colon=new RewriteRuleITokenStream(adaptor,"token Colon");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"rule params");
		RewriteRuleSubtreeStream stream_codeBlock=new RewriteRuleSubtreeStream(adaptor,"rule codeBlock");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(127, 1);
		try
		{
			// Grammars\\LavishScript.g:128:2: ( Atom ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock -> ^( Atom $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:128:4: Atom ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock
			{
			DebugLocation(128, 4);
			Atom143=(IToken)Match(input,Atom,Follow._Atom_in_atom1066); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Atom.Add(Atom143);

			DebugLocation(128, 8);
			// Grammars\\LavishScript.g:128:8: ( Colon returnType= ID )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1==Colon))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:128:9: Colon returnType= ID
				{
				DebugLocation(128, 9);
				Colon144=(IToken)Match(input,Colon,Follow._Colon_in_atom1068); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Colon.Add(Colon144);

				DebugLocation(128, 25);
				returnType=(IToken)Match(input,ID,Follow._ID_in_atom1072); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(returnType);


				}
				break;

			}
			} finally { DebugExitSubRule(47); }

			DebugLocation(128, 35);
			name=(IToken)Match(input,ID,Follow._ID_in_atom1078); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(128, 39);
			LParen145=(IToken)Match(input,LParen,Follow._LParen_in_atom1080); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LParen.Add(LParen145);

			DebugLocation(128, 46);
			// Grammars\\LavishScript.g:128:46: ( params )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1==LParen))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:128:46: params
				{
				DebugLocation(128, 46);
				PushFollow(Follow._params_in_atom1082);
				params146=@params();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_params.Add(params146.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }

			DebugLocation(128, 54);
			RParen147=(IToken)Match(input,RParen,Follow._RParen_in_atom1085); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RParen.Add(RParen147);

			DebugLocation(128, 61);
			NewLine148=(IToken)Match(input,NewLine,Follow._NewLine_in_atom1087); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine148);

			DebugLocation(128, 69);
			PushFollow(Follow._codeBlock_in_atom1089);
			codeBlock149=codeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_codeBlock.Add(codeBlock149.Tree);


			{
			// AST REWRITE
			// elements: Atom, name, returnType, params, codeBlock
			// token labels: name, returnType
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleITokenStream stream_returnType=new RewriteRuleITokenStream(adaptor,"token returnType",returnType);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 129:4: -> ^( Atom $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
			{
				DebugLocation(129, 6);
				// Grammars\\LavishScript.g:129:6: ^( Atom $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(129, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Atom.NextNode(), root_1);

				DebugLocation(129, 14);
				adaptor.AddChild(root_1, stream_name.NextNode());
				DebugLocation(129, 19);
				// Grammars\\LavishScript.g:129:19: ^( Returns ( $returnType)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(129, 21);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Returns, "Returns"), root_2);

				DebugLocation(129, 30);
				// Grammars\\LavishScript.g:129:30: ( $returnType)?
				if (stream_returnType.HasNext)
				{
					DebugLocation(129, 30);
					adaptor.AddChild(root_2, stream_returnType.NextNode());

				}
				stream_returnType.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(129, 43);
				// Grammars\\LavishScript.g:129:43: ( params )?
				if (stream_params.HasNext)
				{
					DebugLocation(129, 43);
					adaptor.AddChild(root_1, stream_params.NextTree());

				}
				stream_params.Reset();
				DebugLocation(129, 51);
				adaptor.AddChild(root_1, stream_codeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 27);
			LeaveRule("atom", 27);
			LeaveRule_atom();
		}
		DebugLocation(130, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_objectMember();
	partial void LeaveRule_objectMember();
	// $ANTLR start "objectMember"
	// Grammars\\LavishScript.g:131:8: public objectMember : Member ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock -> ^( Member $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) ;
	[GrammarRule("objectMember")]
	public AstParserRuleReturnScope<CommonTree, IToken> objectMember()
	{
		EnterRule_objectMember();
		EnterRule("objectMember", 28);
		TraceIn("objectMember", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken returnType = default(IToken);
		IToken name = default(IToken);
		IToken Member150 = default(IToken);
		IToken Colon151 = default(IToken);
		IToken LParen152 = default(IToken);
		IToken RParen154 = default(IToken);
		IToken NewLine155 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> params153 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> codeBlock156 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree returnType_tree = default(CommonTree);
		CommonTree name_tree = default(CommonTree);
		CommonTree Member150_tree = default(CommonTree);
		CommonTree Colon151_tree = default(CommonTree);
		CommonTree LParen152_tree = default(CommonTree);
		CommonTree RParen154_tree = default(CommonTree);
		CommonTree NewLine155_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Member=new RewriteRuleITokenStream(adaptor,"token Member");
		RewriteRuleITokenStream stream_Colon=new RewriteRuleITokenStream(adaptor,"token Colon");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"rule params");
		RewriteRuleSubtreeStream stream_codeBlock=new RewriteRuleSubtreeStream(adaptor,"rule codeBlock");
		try { DebugEnterRule(GrammarFileName, "objectMember");
		DebugLocation(131, 1);
		try
		{
			// Grammars\\LavishScript.g:132:2: ( Member ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock -> ^( Member $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:132:4: Member ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock
			{
			DebugLocation(132, 4);
			Member150=(IToken)Match(input,Member,Follow._Member_in_objectMember1125); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Member.Add(Member150);

			DebugLocation(132, 10);
			// Grammars\\LavishScript.g:132:10: ( Colon returnType= ID )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==Colon))
			{
				alt49 = 1;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:132:11: Colon returnType= ID
				{
				DebugLocation(132, 11);
				Colon151=(IToken)Match(input,Colon,Follow._Colon_in_objectMember1127); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Colon.Add(Colon151);

				DebugLocation(132, 27);
				returnType=(IToken)Match(input,ID,Follow._ID_in_objectMember1131); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(returnType);


				}
				break;

			}
			} finally { DebugExitSubRule(49); }

			DebugLocation(132, 37);
			name=(IToken)Match(input,ID,Follow._ID_in_objectMember1137); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(132, 41);
			LParen152=(IToken)Match(input,LParen,Follow._LParen_in_objectMember1139); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LParen.Add(LParen152);

			DebugLocation(132, 48);
			// Grammars\\LavishScript.g:132:48: ( params )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			int LA50_1 = input.LA(1);

			if ((LA50_1==LParen))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:132:48: params
				{
				DebugLocation(132, 48);
				PushFollow(Follow._params_in_objectMember1141);
				params153=@params();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_params.Add(params153.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(50); }

			DebugLocation(132, 56);
			RParen154=(IToken)Match(input,RParen,Follow._RParen_in_objectMember1144); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RParen.Add(RParen154);

			DebugLocation(132, 63);
			NewLine155=(IToken)Match(input,NewLine,Follow._NewLine_in_objectMember1146); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine155);

			DebugLocation(132, 71);
			PushFollow(Follow._codeBlock_in_objectMember1148);
			codeBlock156=codeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_codeBlock.Add(codeBlock156.Tree);


			{
			// AST REWRITE
			// elements: Member, name, returnType, params, codeBlock
			// token labels: name, returnType
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleITokenStream stream_returnType=new RewriteRuleITokenStream(adaptor,"token returnType",returnType);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 133:4: -> ^( Member $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
			{
				DebugLocation(133, 6);
				// Grammars\\LavishScript.g:133:6: ^( Member $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(133, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Member.NextNode(), root_1);

				DebugLocation(133, 16);
				adaptor.AddChild(root_1, stream_name.NextNode());
				DebugLocation(133, 21);
				// Grammars\\LavishScript.g:133:21: ^( Returns ( $returnType)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(133, 23);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Returns, "Returns"), root_2);

				DebugLocation(133, 32);
				// Grammars\\LavishScript.g:133:32: ( $returnType)?
				if (stream_returnType.HasNext)
				{
					DebugLocation(133, 32);
					adaptor.AddChild(root_2, stream_returnType.NextNode());

				}
				stream_returnType.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(133, 45);
				// Grammars\\LavishScript.g:133:45: ( params )?
				if (stream_params.HasNext)
				{
					DebugLocation(133, 45);
					adaptor.AddChild(root_1, stream_params.NextTree());

				}
				stream_params.Reset();
				DebugLocation(133, 53);
				adaptor.AddChild(root_1, stream_codeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectMember", 28);
			LeaveRule("objectMember", 28);
			LeaveRule_objectMember();
		}
		DebugLocation(134, 1);
		} finally { DebugExitRule(GrammarFileName, "objectMember"); }
		return retval;

	}
	// $ANTLR end "objectMember"

	partial void EnterRule_objectMethod();
	partial void LeaveRule_objectMethod();
	// $ANTLR start "objectMethod"
	// Grammars\\LavishScript.g:135:8: public objectMethod : Method ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock -> ^( Method $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) ;
	[GrammarRule("objectMethod")]
	public AstParserRuleReturnScope<CommonTree, IToken> objectMethod()
	{
		EnterRule_objectMethod();
		EnterRule("objectMethod", 29);
		TraceIn("objectMethod", 29);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken returnType = default(IToken);
		IToken name = default(IToken);
		IToken Method157 = default(IToken);
		IToken Colon158 = default(IToken);
		IToken LParen159 = default(IToken);
		IToken RParen161 = default(IToken);
		IToken NewLine162 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> params160 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> codeBlock163 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree returnType_tree = default(CommonTree);
		CommonTree name_tree = default(CommonTree);
		CommonTree Method157_tree = default(CommonTree);
		CommonTree Colon158_tree = default(CommonTree);
		CommonTree LParen159_tree = default(CommonTree);
		CommonTree RParen161_tree = default(CommonTree);
		CommonTree NewLine162_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Method=new RewriteRuleITokenStream(adaptor,"token Method");
		RewriteRuleITokenStream stream_Colon=new RewriteRuleITokenStream(adaptor,"token Colon");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleSubtreeStream stream_params=new RewriteRuleSubtreeStream(adaptor,"rule params");
		RewriteRuleSubtreeStream stream_codeBlock=new RewriteRuleSubtreeStream(adaptor,"rule codeBlock");
		try { DebugEnterRule(GrammarFileName, "objectMethod");
		DebugLocation(135, 1);
		try
		{
			// Grammars\\LavishScript.g:136:2: ( Method ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock -> ^( Method $name ^( Returns ( $returnType)? ) ( params )? codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:136:4: Method ( Colon returnType= ID )? name= ID LParen ( params )? RParen NewLine codeBlock
			{
			DebugLocation(136, 4);
			Method157=(IToken)Match(input,Method,Follow._Method_in_objectMethod1184); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Method.Add(Method157);

			DebugLocation(136, 10);
			// Grammars\\LavishScript.g:136:10: ( Colon returnType= ID )?
			int alt51=2;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			int LA51_1 = input.LA(1);

			if ((LA51_1==Colon))
			{
				alt51 = 1;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:136:11: Colon returnType= ID
				{
				DebugLocation(136, 11);
				Colon158=(IToken)Match(input,Colon,Follow._Colon_in_objectMethod1186); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Colon.Add(Colon158);

				DebugLocation(136, 27);
				returnType=(IToken)Match(input,ID,Follow._ID_in_objectMethod1190); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(returnType);


				}
				break;

			}
			} finally { DebugExitSubRule(51); }

			DebugLocation(136, 37);
			name=(IToken)Match(input,ID,Follow._ID_in_objectMethod1196); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(136, 41);
			LParen159=(IToken)Match(input,LParen,Follow._LParen_in_objectMethod1198); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LParen.Add(LParen159);

			DebugLocation(136, 48);
			// Grammars\\LavishScript.g:136:48: ( params )?
			int alt52=2;
			try { DebugEnterSubRule(52);
			try { DebugEnterDecision(52, false);
			int LA52_1 = input.LA(1);

			if ((LA52_1==LParen))
			{
				alt52 = 1;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:136:48: params
				{
				DebugLocation(136, 48);
				PushFollow(Follow._params_in_objectMethod1200);
				params160=@params();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_params.Add(params160.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(52); }

			DebugLocation(136, 56);
			RParen161=(IToken)Match(input,RParen,Follow._RParen_in_objectMethod1203); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RParen.Add(RParen161);

			DebugLocation(136, 63);
			NewLine162=(IToken)Match(input,NewLine,Follow._NewLine_in_objectMethod1205); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine162);

			DebugLocation(136, 71);
			PushFollow(Follow._codeBlock_in_objectMethod1207);
			codeBlock163=codeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_codeBlock.Add(codeBlock163.Tree);


			{
			// AST REWRITE
			// elements: Method, name, returnType, params, codeBlock
			// token labels: name, returnType
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleITokenStream stream_returnType=new RewriteRuleITokenStream(adaptor,"token returnType",returnType);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 137:4: -> ^( Method $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
			{
				DebugLocation(137, 6);
				// Grammars\\LavishScript.g:137:6: ^( Method $name ^( Returns ( $returnType)? ) ( params )? codeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(137, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Method.NextNode(), root_1);

				DebugLocation(137, 16);
				adaptor.AddChild(root_1, stream_name.NextNode());
				DebugLocation(137, 21);
				// Grammars\\LavishScript.g:137:21: ^( Returns ( $returnType)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(137, 23);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Returns, "Returns"), root_2);

				DebugLocation(137, 32);
				// Grammars\\LavishScript.g:137:32: ( $returnType)?
				if (stream_returnType.HasNext)
				{
					DebugLocation(137, 32);
					adaptor.AddChild(root_2, stream_returnType.NextNode());

				}
				stream_returnType.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(137, 45);
				// Grammars\\LavishScript.g:137:45: ( params )?
				if (stream_params.HasNext)
				{
					DebugLocation(137, 45);
					adaptor.AddChild(root_1, stream_params.NextTree());

				}
				stream_params.Reset();
				DebugLocation(137, 53);
				adaptor.AddChild(root_1, stream_codeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectMethod", 29);
			LeaveRule("objectMethod", 29);
			LeaveRule_objectMethod();
		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "objectMethod"); }
		return retval;

	}
	// $ANTLR end "objectMethod"

	partial void EnterRule_command();
	partial void LeaveRule_command();
	// $ANTLR start "command"
	// Grammars\\LavishScript.g:140:8: public command : ( ( dataCommand )=> dataCommand ( Semi command )? -> ^( DataCommand dataCommand ) ( command )? | ( ID )=> ( ID WS ) ( commandArg )* ( Semi command )? -> ^( COMMAND ID ^( ARG ( commandArg )* ) ) ( command )? | ( dataSequence WS )=> ( dataSequence ) ( commandArg )* ( Semi command )? -> ^( COMMAND dataSequence ^( ARG ( commandArg )* ) ) ( command )? );
	[GrammarRule("command")]
	public AstParserRuleReturnScope<CommonTree, IToken> command()
	{
		EnterRule_command();
		EnterRule("command", 30);
		TraceIn("command", 30);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Semi165 = default(IToken);
		IToken ID167 = default(IToken);
		IToken WS168 = default(IToken);
		IToken Semi170 = default(IToken);
		IToken Semi174 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> dataCommand164 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command166 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> commandArg169 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command171 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence172 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> commandArg173 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command175 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Semi165_tree = default(CommonTree);
		CommonTree ID167_tree = default(CommonTree);
		CommonTree WS168_tree = default(CommonTree);
		CommonTree Semi170_tree = default(CommonTree);
		CommonTree Semi174_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Semi=new RewriteRuleITokenStream(adaptor,"token Semi");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_dataCommand=new RewriteRuleSubtreeStream(adaptor,"rule dataCommand");
		RewriteRuleSubtreeStream stream_command=new RewriteRuleSubtreeStream(adaptor,"rule command");
		RewriteRuleSubtreeStream stream_commandArg=new RewriteRuleSubtreeStream(adaptor,"rule commandArg");
		RewriteRuleSubtreeStream stream_dataSequence=new RewriteRuleSubtreeStream(adaptor,"rule dataSequence");
		try { DebugEnterRule(GrammarFileName, "command");
		DebugLocation(140, 1);
		try
		{
			// Grammars\\LavishScript.g:141:2: ( ( dataCommand )=> dataCommand ( Semi command )? -> ^( DataCommand dataCommand ) ( command )? | ( ID )=> ( ID WS ) ( commandArg )* ( Semi command )? -> ^( COMMAND ID ^( ARG ( commandArg )* ) ) ( command )? | ( dataSequence WS )=> ( dataSequence ) ( commandArg )* ( Semi command )? -> ^( COMMAND dataSequence ^( ARG ( commandArg )* ) ) ( command )? )
			int alt58=3;
			try { DebugEnterDecision(58, false);
			int LA58_1 = input.LA(1);

			if ((LA58_1==ID))
			{
				int LA58_2 = input.LA(2);

				if ((EvaluatePredicate(synpred5_LavishScript_fragment)))
				{
					alt58 = 1;
				}
				else if ((EvaluatePredicate(synpred6_LavishScript_fragment)))
				{
					alt58 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 58, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA58_1==Dollar))
			{
				int LA58_2 = input.LA(2);

				if ((EvaluatePredicate(synpred5_LavishScript_fragment)))
				{
					alt58 = 1;
				}
				else if ((EvaluatePredicate(synpred7_LavishScript_fragment)))
				{
					alt58 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 58, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:141:4: ( dataCommand )=> dataCommand ( Semi command )?
				{
				DebugLocation(141, 19);
				PushFollow(Follow._dataCommand_in_command1248);
				dataCommand164=dataCommand();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dataCommand.Add(dataCommand164.Tree);
				DebugLocation(141, 31);
				// Grammars\\LavishScript.g:141:31: ( Semi command )?
				int alt53=2;
				try { DebugEnterSubRule(53);
				try { DebugEnterDecision(53, false);
				int LA53_1 = input.LA(1);

				if ((LA53_1==Semi))
				{
					alt53 = 1;
				}
				} finally { DebugExitDecision(53); }
				switch (alt53)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:141:32: Semi command
					{
					DebugLocation(141, 32);
					Semi165=(IToken)Match(input,Semi,Follow._Semi_in_command1251); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_Semi.Add(Semi165);

					DebugLocation(141, 37);
					PushFollow(Follow._command_in_command1253);
					command166=command();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_command.Add(command166.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(53); }



				{
				// AST REWRITE
				// elements: dataCommand, command
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 141:46: -> ^( DataCommand dataCommand ) ( command )?
				{
					DebugLocation(141, 48);
					// Grammars\\LavishScript.g:141:48: ^( DataCommand dataCommand )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(141, 50);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DataCommand, "DataCommand"), root_1);

					DebugLocation(141, 62);
					adaptor.AddChild(root_1, stream_dataCommand.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(141, 74);
					// Grammars\\LavishScript.g:141:74: ( command )?
					if (stream_command.HasNext)
					{
						DebugLocation(141, 74);
						adaptor.AddChild(root_0, stream_command.NextTree());

					}
					stream_command.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:142:4: ( ID )=> ( ID WS ) ( commandArg )* ( Semi command )?
				{
				DebugLocation(142, 10);
				// Grammars\\LavishScript.g:142:10: ( ID WS )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:142:11: ID WS
				{
				DebugLocation(142, 11);
				ID167=(IToken)Match(input,ID,Follow._ID_in_command1273); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID167);

				DebugLocation(142, 14);
				WS168=(IToken)Match(input,WS,Follow._WS_in_command1275); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS168);


				}

				DebugLocation(142, 18);
				// Grammars\\LavishScript.g:142:18: ( commandArg )*
				try { DebugEnterSubRule(54);
				while (true)
				{
					int alt54=2;
					try { DebugEnterDecision(54, false);
					switch (input.LA(1))
					{
					case WS:
						{
						alt54 = 1;
						}
						break;
					case EndMac:
						{
						alt54 = 1;
						}
						break;
					case ARG:
					case And:
					case Assign:
					case Atom:
					case Band:
					case Bnegate:
					case Bor:
					case COMMAND:
					case COMMENT:
					case CONDITION:
					case Case:
					case CodeBlock:
					case Colon:
					case Comma:
					case Comparer:
					case DataCommand:
					case DeclareVariable:
					case Default:
					case Define:
					case Div:
					case Do:
					case Dollar:
					case Dot:
					case ESC_SEQ:
					case EXPONENT:
					case Echo:
					case Elipse:
					case Else:
					case ElseIf:
					case EndIf:
					case EqualTo:
					case Error:
					case FLOAT:
					case For:
					case Function:
					case GreaterThan:
					case GreaterThanEqual:
					case HEX_DIGIT:
					case ID:
					case INT:
					case If:
					case IfDef:
					case IfNDef:
					case Include:
					case Inherits:
					case LCurly:
					case LParen:
					case LSquare:
					case LeftShift:
					case LessThan:
					case LessThanEqual:
					case MATH:
					case Macro:
					case Member:
					case Method:
					case Minus:
					case Modu:
					case Mult:
					case Negate:
					case NotEqualTo:
					case OCTAL_ESC:
					case ObjectDef:
					case Or:
					case Other:
					case Param:
					case Params:
					case Plus:
					case PreElse:
					case PreElseIf:
					case PreIf:
					case Quote:
					case RCurly:
					case RSquare:
					case Returns:
					case RightShift:
					case STRING:
					case Scope:
					case Script:
					case Switch:
					case Type:
					case UNICODE_ESC:
					case Unmac:
					case Variable:
					case VariableCase:
					case While:
					case Xor:
						{
						alt54 = 1;
						}
						break;
					case RParen:
						{
						switch (input.LA(2))
						{
						case WS:
							{
							int LA54_3 = input.LA(3);

							if ((LA54_3==EOF||(LA54_3>=ARG && LA54_3<=Xor)))
							{
								alt54 = 1;
							}


							}
							break;
						case ARG:
						case And:
						case Assign:
						case Atom:
						case Band:
						case Bnegate:
						case Bor:
						case COMMAND:
						case COMMENT:
						case CONDITION:
						case Case:
						case CodeBlock:
						case Colon:
						case Comma:
						case Comparer:
						case DataCommand:
						case DeclareVariable:
						case Default:
						case Define:
						case Div:
						case Do:
						case Dollar:
						case Dot:
						case ESC_SEQ:
						case EXPONENT:
						case Echo:
						case Elipse:
						case Else:
						case ElseIf:
						case EndIf:
						case EndMac:
						case EqualTo:
						case Error:
						case FLOAT:
						case For:
						case Function:
						case GreaterThan:
						case GreaterThanEqual:
						case HEX_DIGIT:
						case ID:
						case INT:
						case If:
						case IfDef:
						case IfNDef:
						case Include:
						case Inherits:
						case LCurly:
						case LParen:
						case LSquare:
						case LeftShift:
						case LessThan:
						case LessThanEqual:
						case MATH:
						case Macro:
						case Member:
						case Method:
						case Minus:
						case Modu:
						case Mult:
						case Negate:
						case NewLine:
						case NotEqualTo:
						case OCTAL_ESC:
						case ObjectDef:
						case Or:
						case Other:
						case Param:
						case Params:
						case Plus:
						case PreElse:
						case PreElseIf:
						case PreIf:
						case Quote:
						case RCurly:
						case RParen:
						case RSquare:
						case Returns:
						case RightShift:
						case STRING:
						case Scope:
						case Script:
						case Semi:
						case Switch:
						case Type:
						case UNICODE_ESC:
						case Unmac:
						case Variable:
						case VariableCase:
						case While:
						case Xor:
							{
							alt54 = 1;
							}
							break;
						case EOF:
							{
							alt54 = 1;
							}
							break;
						}

						}
						break;
					}

					} finally { DebugExitDecision(54); }
					switch ( alt54 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:142:18: commandArg
						{
						DebugLocation(142, 18);
						PushFollow(Follow._commandArg_in_command1278);
						commandArg169=commandArg();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_commandArg.Add(commandArg169.Tree);

						}
						break;

					default:
						goto loop54;
					}
				}

				loop54:
					;

				} finally { DebugExitSubRule(54); }

				DebugLocation(142, 30);
				// Grammars\\LavishScript.g:142:30: ( Semi command )?
				int alt55=2;
				try { DebugEnterSubRule(55);
				try { DebugEnterDecision(55, false);
				int LA55_1 = input.LA(1);

				if ((LA55_1==Semi))
				{
					alt55 = 1;
				}
				} finally { DebugExitDecision(55); }
				switch (alt55)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:142:31: Semi command
					{
					DebugLocation(142, 31);
					Semi170=(IToken)Match(input,Semi,Follow._Semi_in_command1282); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_Semi.Add(Semi170);

					DebugLocation(142, 36);
					PushFollow(Follow._command_in_command1284);
					command171=command();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_command.Add(command171.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(55); }



				{
				// AST REWRITE
				// elements: ID, commandArg, command
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 142:45: -> ^( COMMAND ID ^( ARG ( commandArg )* ) ) ( command )?
				{
					DebugLocation(142, 47);
					// Grammars\\LavishScript.g:142:47: ^( COMMAND ID ^( ARG ( commandArg )* ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(142, 49);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(COMMAND, "COMMAND"), root_1);

					DebugLocation(142, 57);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(142, 60);
					// Grammars\\LavishScript.g:142:60: ^( ARG ( commandArg )* )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(142, 62);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARG, "ARG"), root_2);

					DebugLocation(142, 66);
					// Grammars\\LavishScript.g:142:66: ( commandArg )*
					while ( stream_commandArg.HasNext )
					{
						DebugLocation(142, 66);
						adaptor.AddChild(root_2, stream_commandArg.NextTree());

					}
					stream_commandArg.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(142, 80);
					// Grammars\\LavishScript.g:142:80: ( command )?
					if (stream_command.HasNext)
					{
						DebugLocation(142, 80);
						adaptor.AddChild(root_0, stream_command.NextTree());

					}
					stream_command.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:143:4: ( dataSequence WS )=> ( dataSequence ) ( commandArg )* ( Semi command )?
				{
				DebugLocation(143, 23);
				// Grammars\\LavishScript.g:143:23: ( dataSequence )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:143:24: dataSequence
				{
				DebugLocation(143, 24);
				PushFollow(Follow._dataSequence_in_command1314);
				dataSequence172=dataSequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_dataSequence.Add(dataSequence172.Tree);

				}

				DebugLocation(143, 38);
				// Grammars\\LavishScript.g:143:38: ( commandArg )*
				try { DebugEnterSubRule(56);
				while (true)
				{
					int alt56=2;
					try { DebugEnterDecision(56, false);
					switch (input.LA(1))
					{
					case WS:
						{
						alt56 = 1;
						}
						break;
					case EndMac:
						{
						alt56 = 1;
						}
						break;
					case ARG:
					case And:
					case Assign:
					case Atom:
					case Band:
					case Bnegate:
					case Bor:
					case COMMAND:
					case COMMENT:
					case CONDITION:
					case Case:
					case CodeBlock:
					case Colon:
					case Comma:
					case Comparer:
					case DataCommand:
					case DeclareVariable:
					case Default:
					case Define:
					case Div:
					case Do:
					case Dollar:
					case Dot:
					case ESC_SEQ:
					case EXPONENT:
					case Echo:
					case Elipse:
					case Else:
					case ElseIf:
					case EndIf:
					case EqualTo:
					case Error:
					case FLOAT:
					case For:
					case Function:
					case GreaterThan:
					case GreaterThanEqual:
					case HEX_DIGIT:
					case ID:
					case INT:
					case If:
					case IfDef:
					case IfNDef:
					case Include:
					case Inherits:
					case LCurly:
					case LParen:
					case LSquare:
					case LeftShift:
					case LessThan:
					case LessThanEqual:
					case MATH:
					case Macro:
					case Member:
					case Method:
					case Minus:
					case Modu:
					case Mult:
					case Negate:
					case NotEqualTo:
					case OCTAL_ESC:
					case ObjectDef:
					case Or:
					case Other:
					case Param:
					case Params:
					case Plus:
					case PreElse:
					case PreElseIf:
					case PreIf:
					case Quote:
					case RCurly:
					case RSquare:
					case Returns:
					case RightShift:
					case STRING:
					case Scope:
					case Script:
					case Switch:
					case Type:
					case UNICODE_ESC:
					case Unmac:
					case Variable:
					case VariableCase:
					case While:
					case Xor:
						{
						alt56 = 1;
						}
						break;
					case RParen:
						{
						switch (input.LA(2))
						{
						case WS:
							{
							int LA56_3 = input.LA(3);

							if ((LA56_3==EOF||(LA56_3>=ARG && LA56_3<=Xor)))
							{
								alt56 = 1;
							}


							}
							break;
						case ARG:
						case And:
						case Assign:
						case Atom:
						case Band:
						case Bnegate:
						case Bor:
						case COMMAND:
						case COMMENT:
						case CONDITION:
						case Case:
						case CodeBlock:
						case Colon:
						case Comma:
						case Comparer:
						case DataCommand:
						case DeclareVariable:
						case Default:
						case Define:
						case Div:
						case Do:
						case Dollar:
						case Dot:
						case ESC_SEQ:
						case EXPONENT:
						case Echo:
						case Elipse:
						case Else:
						case ElseIf:
						case EndIf:
						case EndMac:
						case EqualTo:
						case Error:
						case FLOAT:
						case For:
						case Function:
						case GreaterThan:
						case GreaterThanEqual:
						case HEX_DIGIT:
						case ID:
						case INT:
						case If:
						case IfDef:
						case IfNDef:
						case Include:
						case Inherits:
						case LCurly:
						case LParen:
						case LSquare:
						case LeftShift:
						case LessThan:
						case LessThanEqual:
						case MATH:
						case Macro:
						case Member:
						case Method:
						case Minus:
						case Modu:
						case Mult:
						case Negate:
						case NewLine:
						case NotEqualTo:
						case OCTAL_ESC:
						case ObjectDef:
						case Or:
						case Other:
						case Param:
						case Params:
						case Plus:
						case PreElse:
						case PreElseIf:
						case PreIf:
						case Quote:
						case RCurly:
						case RParen:
						case RSquare:
						case Returns:
						case RightShift:
						case STRING:
						case Scope:
						case Script:
						case Semi:
						case Switch:
						case Type:
						case UNICODE_ESC:
						case Unmac:
						case Variable:
						case VariableCase:
						case While:
						case Xor:
							{
							alt56 = 1;
							}
							break;
						case EOF:
							{
							alt56 = 1;
							}
							break;
						}

						}
						break;
					}

					} finally { DebugExitDecision(56); }
					switch ( alt56 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:143:38: commandArg
						{
						DebugLocation(143, 38);
						PushFollow(Follow._commandArg_in_command1317);
						commandArg173=commandArg();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_commandArg.Add(commandArg173.Tree);

						}
						break;

					default:
						goto loop56;
					}
				}

				loop56:
					;

				} finally { DebugExitSubRule(56); }

				DebugLocation(143, 50);
				// Grammars\\LavishScript.g:143:50: ( Semi command )?
				int alt57=2;
				try { DebugEnterSubRule(57);
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==Semi))
				{
					alt57 = 1;
				}
				} finally { DebugExitDecision(57); }
				switch (alt57)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:143:51: Semi command
					{
					DebugLocation(143, 51);
					Semi174=(IToken)Match(input,Semi,Follow._Semi_in_command1321); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_Semi.Add(Semi174);

					DebugLocation(143, 56);
					PushFollow(Follow._command_in_command1323);
					command175=command();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_command.Add(command175.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(57); }



				{
				// AST REWRITE
				// elements: dataSequence, commandArg, command
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 143:65: -> ^( COMMAND dataSequence ^( ARG ( commandArg )* ) ) ( command )?
				{
					DebugLocation(143, 67);
					// Grammars\\LavishScript.g:143:67: ^( COMMAND dataSequence ^( ARG ( commandArg )* ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(143, 69);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(COMMAND, "COMMAND"), root_1);

					DebugLocation(143, 77);
					adaptor.AddChild(root_1, stream_dataSequence.NextTree());
					DebugLocation(143, 90);
					// Grammars\\LavishScript.g:143:90: ^( ARG ( commandArg )* )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(143, 92);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARG, "ARG"), root_2);

					DebugLocation(143, 96);
					// Grammars\\LavishScript.g:143:96: ( commandArg )*
					while ( stream_commandArg.HasNext )
					{
						DebugLocation(143, 96);
						adaptor.AddChild(root_2, stream_commandArg.NextTree());

					}
					stream_commandArg.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(143, 110);
					// Grammars\\LavishScript.g:143:110: ( command )?
					if (stream_command.HasNext)
					{
						DebugLocation(143, 110);
						adaptor.AddChild(root_0, stream_command.NextTree());

					}
					stream_command.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("command", 30);
			LeaveRule("command", 30);
			LeaveRule_command();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "command"); }
		return retval;

	}
	// $ANTLR end "command"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Grammars\\LavishScript.g:147:8: public expression : NewLine ! ( WS !)? ( command | declareVariable | preProcessor | variableDeclare | forStatement | doStatement | whileStatement | ifStatement | switchStatement | codeBlock )? ( WS !)? ;
	[GrammarRule("expression")]
	public AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 31);
		TraceIn("expression", 31);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NewLine176 = default(IToken);
		IToken WS177 = default(IToken);
		IToken WS188 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> command178 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> declareVariable179 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> preProcessor180 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclare181 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forStatement182 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> doStatement183 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement184 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement185 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> switchStatement186 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> codeBlock187 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NewLine176_tree = default(CommonTree);
		CommonTree WS177_tree = default(CommonTree);
		CommonTree WS188_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(147, 1);
		try
		{
			// Grammars\\LavishScript.g:148:2: ( NewLine ! ( WS !)? ( command | declareVariable | preProcessor | variableDeclare | forStatement | doStatement | whileStatement | ifStatement | switchStatement | codeBlock )? ( WS !)? )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:148:4: NewLine ! ( WS !)? ( command | declareVariable | preProcessor | variableDeclare | forStatement | doStatement | whileStatement | ifStatement | switchStatement | codeBlock )? ( WS !)?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(148, 11);
			NewLine176=(IToken)Match(input,NewLine,Follow._NewLine_in_expression1357); if (state.failed) return retval;
			DebugLocation(148, 15);
			// Grammars\\LavishScript.g:148:15: ( WS !)?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_1 = input.LA(1);

			if ((LA59_1==WS))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:148:15: WS !
				{
				DebugLocation(148, 15);
				WS177=(IToken)Match(input,WS,Follow._WS_in_expression1360); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(149, 3);
			// Grammars\\LavishScript.g:149:3: ( command | declareVariable | preProcessor | variableDeclare | forStatement | doStatement | whileStatement | ifStatement | switchStatement | codeBlock )?
			int alt60=11;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			switch (input.LA(1))
			{
			case Dollar:
			case ID:
				{
				alt60 = 1;
				}
				break;
			case DeclareVariable:
				{
				alt60 = 2;
				}
				break;
			case Define:
			case Echo:
			case Error:
			case IfDef:
			case IfNDef:
			case Include:
			case Macro:
			case PreIf:
			case Unmac:
				{
				alt60 = 3;
				}
				break;
			case Variable:
				{
				alt60 = 4;
				}
				break;
			case For:
				{
				alt60 = 5;
				}
				break;
			case Do:
				{
				alt60 = 6;
				}
				break;
			case While:
				{
				alt60 = 7;
				}
				break;
			case If:
				{
				alt60 = 8;
				}
				break;
			case Switch:
				{
				alt60 = 9;
				}
				break;
			case LCurly:
				{
				alt60 = 10;
				}
				break;
			}

			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:150:3: command
				{
				DebugLocation(150, 3);
				PushFollow(Follow._command_in_expression1371);
				command178=command();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, command178.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:151:4: declareVariable
				{
				DebugLocation(151, 4);
				PushFollow(Follow._declareVariable_in_expression1376);
				declareVariable179=declareVariable();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declareVariable179.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:152:4: preProcessor
				{
				DebugLocation(152, 4);
				PushFollow(Follow._preProcessor_in_expression1381);
				preProcessor180=preProcessor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, preProcessor180.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:153:4: variableDeclare
				{
				DebugLocation(153, 4);
				PushFollow(Follow._variableDeclare_in_expression1386);
				variableDeclare181=variableDeclare();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclare181.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishScript.g:154:4: forStatement
				{
				DebugLocation(154, 4);
				PushFollow(Follow._forStatement_in_expression1391);
				forStatement182=forStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forStatement182.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishScript.g:155:4: doStatement
				{
				DebugLocation(155, 4);
				PushFollow(Follow._doStatement_in_expression1396);
				doStatement183=doStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doStatement183.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LavishScript.g:156:4: whileStatement
				{
				DebugLocation(156, 4);
				PushFollow(Follow._whileStatement_in_expression1401);
				whileStatement184=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement184.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LavishScript.g:157:4: ifStatement
				{
				DebugLocation(157, 4);
				PushFollow(Follow._ifStatement_in_expression1406);
				ifStatement185=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement185.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LavishScript.g:158:4: switchStatement
				{
				DebugLocation(158, 4);
				PushFollow(Follow._switchStatement_in_expression1411);
				switchStatement186=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement186.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\LavishScript.g:159:4: codeBlock
				{
				DebugLocation(159, 4);
				PushFollow(Follow._codeBlock_in_expression1416);
				codeBlock187=codeBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, codeBlock187.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(60); }

			DebugLocation(161, 5);
			// Grammars\\LavishScript.g:161:5: ( WS !)?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_1 = input.LA(1);

			if ((LA61_1==WS))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:161:5: WS !
				{
				DebugLocation(161, 5);
				WS188=(IToken)Match(input,WS,Follow._WS_in_expression1425); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(61); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 31);
			LeaveRule("expression", 31);
			LeaveRule_expression();
		}
		DebugLocation(162, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_params();
	partial void LeaveRule_params();
	// $ANTLR start "params"
	// Grammars\\LavishScript.g:163:8: public params : ( LParen ws Elipse WS ID ws RParen -> ^( Params ^( Param Elipse ID ) ) | LParen ws ( param ( ws Comma ws param )* )? ws RParen -> ^( Params ( param )* ) );
	[GrammarRule("params")]
	public AstParserRuleReturnScope<CommonTree, IToken> @params()
	{
		EnterRule_params();
		EnterRule("params", 32);
		TraceIn("params", 32);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LParen189 = default(IToken);
		IToken Elipse191 = default(IToken);
		IToken WS192 = default(IToken);
		IToken ID193 = default(IToken);
		IToken RParen195 = default(IToken);
		IToken LParen196 = default(IToken);
		IToken Comma200 = default(IToken);
		IToken RParen204 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ws190 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws194 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws197 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> param198 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws199 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws201 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> param202 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws203 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LParen189_tree = default(CommonTree);
		CommonTree Elipse191_tree = default(CommonTree);
		CommonTree WS192_tree = default(CommonTree);
		CommonTree ID193_tree = default(CommonTree);
		CommonTree RParen195_tree = default(CommonTree);
		CommonTree LParen196_tree = default(CommonTree);
		CommonTree Comma200_tree = default(CommonTree);
		CommonTree RParen204_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_Elipse=new RewriteRuleITokenStream(adaptor,"token Elipse");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_Comma=new RewriteRuleITokenStream(adaptor,"token Comma");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_param=new RewriteRuleSubtreeStream(adaptor,"rule param");
		try { DebugEnterRule(GrammarFileName, "params");
		DebugLocation(163, 1);
		try
		{
			// Grammars\\LavishScript.g:164:2: ( LParen ws Elipse WS ID ws RParen -> ^( Params ^( Param Elipse ID ) ) | LParen ws ( param ( ws Comma ws param )* )? ws RParen -> ^( Params ( param )* ) )
			int alt64=2;
			try { DebugEnterDecision(64, false);
			int LA64_1 = input.LA(1);

			if ((LA64_1==LParen))
			{
				switch (input.LA(2))
				{
				case NewLine:
					{
					switch (input.LA(3))
					{
					case WS:
						{
						int LA64_4 = input.LA(4);

						if ((LA64_4==Elipse))
						{
							alt64 = 1;
						}
						else if ((LA64_4==ID||LA64_4==NewLine||LA64_4==RParen||LA64_4==WS))
						{
							alt64 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 64, 3, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case Elipse:
						{
						alt64 = 1;
						}
						break;
					case ID:
					case NewLine:
					case RParen:
						{
						alt64 = 2;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 64, 2, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					}
					break;
				case WS:
					{
					int LA64_3 = input.LA(3);

					if ((LA64_3==Elipse))
					{
						alt64 = 1;
					}
					else if ((LA64_3==ID||LA64_3==NewLine||LA64_3==RParen||LA64_3==WS))
					{
						alt64 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 64, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case Elipse:
					{
					alt64 = 1;
					}
					break;
				case ID:
				case RParen:
					{
					alt64 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 64, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 64, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:164:4: LParen ws Elipse WS ID ws RParen
				{
				DebugLocation(164, 4);
				LParen189=(IToken)Match(input,LParen,Follow._LParen_in_params1439); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen189);

				DebugLocation(164, 11);
				PushFollow(Follow._ws_in_params1441);
				ws190=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws190.Tree);
				DebugLocation(164, 14);
				Elipse191=(IToken)Match(input,Elipse,Follow._Elipse_in_params1443); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Elipse.Add(Elipse191);

				DebugLocation(164, 21);
				WS192=(IToken)Match(input,WS,Follow._WS_in_params1445); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS192);

				DebugLocation(164, 24);
				ID193=(IToken)Match(input,ID,Follow._ID_in_params1447); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID193);

				DebugLocation(164, 27);
				PushFollow(Follow._ws_in_params1449);
				ws194=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws194.Tree);
				DebugLocation(164, 30);
				RParen195=(IToken)Match(input,RParen,Follow._RParen_in_params1451); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen195);



				{
				// AST REWRITE
				// elements: Elipse, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 164:36: -> ^( Params ^( Param Elipse ID ) )
				{
					DebugLocation(164, 38);
					// Grammars\\LavishScript.g:164:38: ^( Params ^( Param Elipse ID ) )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(164, 40);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Params, "Params"), root_1);

					DebugLocation(164, 47);
					// Grammars\\LavishScript.g:164:47: ^( Param Elipse ID )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(164, 49);
					root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Param, "Param"), root_2);

					DebugLocation(164, 55);
					adaptor.AddChild(root_2, stream_Elipse.NextNode());
					DebugLocation(164, 62);
					adaptor.AddChild(root_2, stream_ID.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:165:4: LParen ws ( param ( ws Comma ws param )* )? ws RParen
				{
				DebugLocation(165, 4);
				LParen196=(IToken)Match(input,LParen,Follow._LParen_in_params1468); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen196);

				DebugLocation(165, 11);
				PushFollow(Follow._ws_in_params1470);
				ws197=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws197.Tree);
				DebugLocation(165, 14);
				// Grammars\\LavishScript.g:165:14: ( param ( ws Comma ws param )* )?
				int alt63=2;
				try { DebugEnterSubRule(63);
				try { DebugEnterDecision(63, false);
				int LA63_1 = input.LA(1);

				if ((LA63_1==ID))
				{
					alt63 = 1;
				}
				} finally { DebugExitDecision(63); }
				switch (alt63)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:165:15: param ( ws Comma ws param )*
					{
					DebugLocation(165, 15);
					PushFollow(Follow._param_in_params1473);
					param198=param();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_param.Add(param198.Tree);
					DebugLocation(165, 21);
					// Grammars\\LavishScript.g:165:21: ( ws Comma ws param )*
					try { DebugEnterSubRule(62);
					while (true)
					{
						int alt62=2;
						try { DebugEnterDecision(62, false);
						switch (input.LA(1))
						{
						case NewLine:
							{
							int LA62_2 = input.LA(2);

							if ((LA62_2==WS))
							{
								int LA62_3 = input.LA(3);

								if ((LA62_3==Comma))
								{
									alt62 = 1;
								}


							}
							else if ((LA62_2==Comma))
							{
								alt62 = 1;
							}


							}
							break;
						case WS:
							{
							int LA62_2 = input.LA(2);

							if ((LA62_2==Comma))
							{
								alt62 = 1;
							}


							}
							break;
						case Comma:
							{
							alt62 = 1;
							}
							break;
						}

						} finally { DebugExitDecision(62); }
						switch ( alt62 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LavishScript.g:165:22: ws Comma ws param
							{
							DebugLocation(165, 22);
							PushFollow(Follow._ws_in_params1476);
							ws199=ws();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_ws.Add(ws199.Tree);
							DebugLocation(165, 25);
							Comma200=(IToken)Match(input,Comma,Follow._Comma_in_params1478); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_Comma.Add(Comma200);

							DebugLocation(165, 31);
							PushFollow(Follow._ws_in_params1480);
							ws201=ws();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_ws.Add(ws201.Tree);
							DebugLocation(165, 34);
							PushFollow(Follow._param_in_params1482);
							param202=param();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) stream_param.Add(param202.Tree);

							}
							break;

						default:
							goto loop62;
						}
					}

					loop62:
						;

					} finally { DebugExitSubRule(62); }


					}
					break;

				}
				} finally { DebugExitSubRule(63); }

				DebugLocation(165, 44);
				PushFollow(Follow._ws_in_params1488);
				ws203=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws203.Tree);
				DebugLocation(165, 47);
				RParen204=(IToken)Match(input,RParen,Follow._RParen_in_params1490); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen204);



				{
				// AST REWRITE
				// elements: param
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 165:53: -> ^( Params ( param )* )
				{
					DebugLocation(165, 55);
					// Grammars\\LavishScript.g:165:55: ^( Params ( param )* )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(165, 57);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Params, "Params"), root_1);

					DebugLocation(165, 64);
					// Grammars\\LavishScript.g:165:64: ( param )*
					while ( stream_param.HasNext )
					{
						DebugLocation(165, 64);
						adaptor.AddChild(root_1, stream_param.NextTree());

					}
					stream_param.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("params", 32);
			LeaveRule("params", 32);
			LeaveRule_params();
		}
		DebugLocation(167, 1);
		} finally { DebugExitRule(GrammarFileName, "params"); }
		return retval;

	}
	// $ANTLR end "params"

	partial void EnterRule_param();
	partial void LeaveRule_param();
	// $ANTLR start "param"
	// Grammars\\LavishScript.g:168:8: public param : ( (type= ID WS name= ID ) |name= ID ) ( ws Assign ws value )? -> ^( Param ^( Type ( $type)? ) ^( $name ( ^( Assign value ) )? ) ) ;
	[GrammarRule("param")]
	public AstParserRuleReturnScope<CommonTree, IToken> param()
	{
		EnterRule_param();
		EnterRule("param", 33);
		TraceIn("param", 33);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken type = default(IToken);
		IToken name = default(IToken);
		IToken WS205 = default(IToken);
		IToken Assign207 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ws206 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws208 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> value209 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree type_tree = default(CommonTree);
		CommonTree name_tree = default(CommonTree);
		CommonTree WS205_tree = default(CommonTree);
		CommonTree Assign207_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_Assign=new RewriteRuleITokenStream(adaptor,"token Assign");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");
		try { DebugEnterRule(GrammarFileName, "param");
		DebugLocation(168, 1);
		try
		{
			// Grammars\\LavishScript.g:169:2: ( ( (type= ID WS name= ID ) |name= ID ) ( ws Assign ws value )? -> ^( Param ^( Type ( $type)? ) ^( $name ( ^( Assign value ) )? ) ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:169:4: ( (type= ID WS name= ID ) |name= ID ) ( ws Assign ws value )?
			{
			DebugLocation(169, 4);
			// Grammars\\LavishScript.g:169:4: ( (type= ID WS name= ID ) |name= ID )
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==ID))
			{
				int LA65_2 = input.LA(2);

				if ((LA65_2==WS))
				{
					int LA65_3 = input.LA(3);

					if ((LA65_3==ID))
					{
						alt65 = 1;
					}
					else if ((LA65_3==Assign||LA65_3==Comma||LA65_3==RParen))
					{
						alt65 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 65, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA65_2==Assign||LA65_2==Comma||LA65_2==NewLine||LA65_2==RParen))
				{
					alt65 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 65, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 65, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:169:5: (type= ID WS name= ID )
				{
				DebugLocation(169, 5);
				// Grammars\\LavishScript.g:169:5: (type= ID WS name= ID )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:169:6: type= ID WS name= ID
				{
				DebugLocation(169, 10);
				type=(IToken)Match(input,ID,Follow._ID_in_param1516); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(type);

				DebugLocation(169, 14);
				WS205=(IToken)Match(input,WS,Follow._WS_in_param1518); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS205);

				DebugLocation(169, 21);
				name=(IToken)Match(input,ID,Follow._ID_in_param1522); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(name);


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:169:26: name= ID
				{
				DebugLocation(169, 30);
				name=(IToken)Match(input,ID,Follow._ID_in_param1527); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(name);


				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(169, 34);
			// Grammars\\LavishScript.g:169:34: ( ws Assign ws value )?
			int alt66=2;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			switch (input.LA(1))
			{
			case NewLine:
				{
				int LA66_2 = input.LA(2);

				if ((LA66_2==WS))
				{
					int LA66_3 = input.LA(3);

					if ((LA66_3==Assign))
					{
						alt66 = 1;
					}
				}
				else if ((LA66_2==Assign))
				{
					alt66 = 1;
				}
				}
				break;
			case WS:
				{
				int LA66_2 = input.LA(2);

				if ((LA66_2==Assign))
				{
					alt66 = 1;
				}
				}
				break;
			case Assign:
				{
				alt66 = 1;
				}
				break;
			}

			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:169:35: ws Assign ws value
				{
				DebugLocation(169, 35);
				PushFollow(Follow._ws_in_param1530);
				ws206=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws206.Tree);
				DebugLocation(169, 38);
				Assign207=(IToken)Match(input,Assign,Follow._Assign_in_param1532); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Assign.Add(Assign207);

				DebugLocation(169, 45);
				PushFollow(Follow._ws_in_param1534);
				ws208=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws208.Tree);
				DebugLocation(169, 48);
				PushFollow(Follow._value_in_param1536);
				value209=value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_value.Add(value209.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(66); }



			{
			// AST REWRITE
			// elements: type, name, Assign, value
			// token labels: type, name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_type=new RewriteRuleITokenStream(adaptor,"token type",type);
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 170:4: -> ^( Param ^( Type ( $type)? ) ^( $name ( ^( Assign value ) )? ) )
			{
				DebugLocation(170, 6);
				// Grammars\\LavishScript.g:170:6: ^( Param ^( Type ( $type)? ) ^( $name ( ^( Assign value ) )? ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(170, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Param, "Param"), root_1);

				DebugLocation(170, 14);
				// Grammars\\LavishScript.g:170:14: ^( Type ( $type)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(170, 16);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Type, "Type"), root_2);

				DebugLocation(170, 22);
				// Grammars\\LavishScript.g:170:22: ( $type)?
				if (stream_type.HasNext)
				{
					DebugLocation(170, 22);
					adaptor.AddChild(root_2, stream_type.NextNode());

				}
				stream_type.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(170, 28);
				// Grammars\\LavishScript.g:170:28: ^( $name ( ^( Assign value ) )? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(170, 31);
				root_2 = (CommonTree)adaptor.BecomeRoot(stream_name.NextNode(), root_2);

				DebugLocation(170, 36);
				// Grammars\\LavishScript.g:170:36: ( ^( Assign value ) )?
				if (stream_Assign.HasNext||stream_value.HasNext)
				{
					DebugLocation(170, 36);
					// Grammars\\LavishScript.g:170:36: ^( Assign value )
					{
					CommonTree root_3 = (CommonTree)adaptor.Nil();
					DebugLocation(170, 38);
					root_3 = (CommonTree)adaptor.BecomeRoot(stream_Assign.NextNode(), root_3);

					DebugLocation(170, 45);
					adaptor.AddChild(root_3, stream_value.NextTree());

					adaptor.AddChild(root_2, root_3);
					}

				}
				stream_Assign.Reset();
				stream_value.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("param", 33);
			LeaveRule("param", 33);
			LeaveRule_param();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "param"); }
		return retval;

	}
	// $ANTLR end "param"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// Grammars\\LavishScript.g:173:8: public ifStatement : If ws ifCondition= condition ( WS )? ifExpression= expression ( ( NewLine ElseIf )=> NewLine elseIfs+= ElseIf elseifCondition+= condition elseifexpression+= expression )* ( ( NewLine Else )=> NewLine Else elseexpression+= expression )? -> ^( If $ifCondition $ifExpression ( ^( $elseIfs $elseifCondition $elseifexpression) )* ( ^( Else $elseexpression) )? ) ;
	[GrammarRule("ifStatement")]
	public AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 34);
		TraceIn("ifStatement", 34);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken If210 = default(IToken);
		IToken WS212 = default(IToken);
		IToken NewLine213 = default(IToken);
		IToken NewLine214 = default(IToken);
		IToken Else215 = default(IToken);
		IToken elseIfs = default(IToken);
		List<IToken> list_elseIfs = null;
		List<CommonTree> list_elseifCondition = null;
		List<CommonTree> list_elseifexpression = null;
		List<CommonTree> list_elseexpression = null;
		AstParserRuleReturnScope<CommonTree, IToken> ifCondition = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifExpression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws211 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elseifCondition = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elseifexpression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elseexpression = default(AstParserRuleReturnScope<CommonTree, IToken>);
		CommonTree If210_tree = default(CommonTree);
		CommonTree WS212_tree = default(CommonTree);
		CommonTree NewLine213_tree = default(CommonTree);
		CommonTree NewLine214_tree = default(CommonTree);
		CommonTree Else215_tree = default(CommonTree);
		CommonTree elseIfs_tree = default(CommonTree);
		RewriteRuleITokenStream stream_If=new RewriteRuleITokenStream(adaptor,"token If");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleITokenStream stream_ElseIf=new RewriteRuleITokenStream(adaptor,"token ElseIf");
		RewriteRuleITokenStream stream_Else=new RewriteRuleITokenStream(adaptor,"token Else");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(173, 1);
		try
		{
			// Grammars\\LavishScript.g:174:2: ( If ws ifCondition= condition ( WS )? ifExpression= expression ( ( NewLine ElseIf )=> NewLine elseIfs+= ElseIf elseifCondition+= condition elseifexpression+= expression )* ( ( NewLine Else )=> NewLine Else elseexpression+= expression )? -> ^( If $ifCondition $ifExpression ( ^( $elseIfs $elseifCondition $elseifexpression) )* ( ^( Else $elseexpression) )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:174:4: If ws ifCondition= condition ( WS )? ifExpression= expression ( ( NewLine ElseIf )=> NewLine elseIfs+= ElseIf elseifCondition+= condition elseifexpression+= expression )* ( ( NewLine Else )=> NewLine Else elseexpression+= expression )?
			{
			DebugLocation(174, 4);
			If210=(IToken)Match(input,If,Follow._If_in_ifStatement1578); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_If.Add(If210);

			DebugLocation(174, 7);
			PushFollow(Follow._ws_in_ifStatement1580);
			ws211=ws();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ws.Add(ws211.Tree);
			DebugLocation(174, 21);
			PushFollow(Follow._condition_in_ifStatement1584);
			ifCondition=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(ifCondition.Tree);
			DebugLocation(174, 32);
			// Grammars\\LavishScript.g:174:32: ( WS )?
			int alt67=2;
			try { DebugEnterSubRule(67);
			try { DebugEnterDecision(67, false);
			int LA67_1 = input.LA(1);

			if ((LA67_1==WS))
			{
				alt67 = 1;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:174:32: WS
				{
				DebugLocation(174, 32);
				WS212=(IToken)Match(input,WS,Follow._WS_in_ifStatement1586); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WS.Add(WS212);


				}
				break;

			}
			} finally { DebugExitSubRule(67); }

			DebugLocation(174, 48);
			PushFollow(Follow._expression_in_ifStatement1591);
			ifExpression=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(ifExpression.Tree);
			DebugLocation(175, 3);
			// Grammars\\LavishScript.g:175:3: ( ( NewLine ElseIf )=> NewLine elseIfs+= ElseIf elseifCondition+= condition elseifexpression+= expression )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==NewLine))
				{
					int LA68_2 = input.LA(2);

					if ((EvaluatePredicate(synpred8_LavishScript_fragment)))
					{
						alt68 = 1;
					}


				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:175:4: ( NewLine ElseIf )=> NewLine elseIfs+= ElseIf elseifCondition+= condition elseifexpression+= expression
					{
					DebugLocation(175, 22);
					NewLine213=(IToken)Match(input,NewLine,Follow._NewLine_in_ifStatement1602); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_NewLine.Add(NewLine213);

					DebugLocation(175, 37);
					elseIfs=(IToken)Match(input,ElseIf,Follow._ElseIf_in_ifStatement1606); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ElseIf.Add(elseIfs);

					if (list_elseIfs==null) list_elseIfs=new List<IToken>();
					list_elseIfs.Add(elseIfs);

					DebugLocation(175, 61);
					PushFollow(Follow._condition_in_ifStatement1610);
					elseifCondition=condition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_condition.Add(elseifCondition.Tree);
					if (list_elseifCondition==null) list_elseifCondition=new List<CommonTree>();
					list_elseifCondition.Add(elseifCondition.Tree);

					DebugLocation(175, 89);
					PushFollow(Follow._expression_in_ifStatement1614);
					elseifexpression=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(elseifexpression.Tree);
					if (list_elseifexpression==null) list_elseifexpression=new List<CommonTree>();
					list_elseifexpression.Add(elseifexpression.Tree);


					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }

			DebugLocation(176, 3);
			// Grammars\\LavishScript.g:176:3: ( ( NewLine Else )=> NewLine Else elseexpression+= expression )?
			int alt69=2;
			try { DebugEnterSubRule(69);
			try { DebugEnterDecision(69, false);
			int LA69_1 = input.LA(1);

			if ((LA69_1==NewLine))
			{
				int LA69_2 = input.LA(2);

				if ((EvaluatePredicate(synpred9_LavishScript_fragment)))
				{
					alt69 = 1;
				}
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:176:4: ( NewLine Else )=> NewLine Else elseexpression+= expression
				{
				DebugLocation(176, 20);
				NewLine214=(IToken)Match(input,NewLine,Follow._NewLine_in_ifStatement1627); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NewLine.Add(NewLine214);

				DebugLocation(176, 28);
				Else215=(IToken)Match(input,Else,Follow._Else_in_ifStatement1629); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Else.Add(Else215);

				DebugLocation(176, 47);
				PushFollow(Follow._expression_in_ifStatement1633);
				elseexpression=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(elseexpression.Tree);
				if (list_elseexpression==null) list_elseexpression=new List<CommonTree>();
				list_elseexpression.Add(elseexpression.Tree);


				}
				break;

			}
			} finally { DebugExitSubRule(69); }



			{
			// AST REWRITE
			// elements: If, ifCondition, ifExpression, elseIfs, elseifCondition, elseifexpression, Else, elseexpression
			// token labels: 
			// rule labels: ifCondition, ifExpression, retval
			// token list labels: elseIfs
			// rule list labels: elseifCondition, elseifexpression, elseexpression
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_elseIfs=new RewriteRuleITokenStream(adaptor,"token elseIfs", list_elseIfs);
			RewriteRuleSubtreeStream stream_ifCondition=new RewriteRuleSubtreeStream(adaptor,"rule ifCondition",ifCondition!=null?ifCondition.Tree:null);
			RewriteRuleSubtreeStream stream_ifExpression=new RewriteRuleSubtreeStream(adaptor,"rule ifExpression",ifExpression!=null?ifExpression.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_elseifCondition=new RewriteRuleSubtreeStream(adaptor,"token elseifCondition",list_elseifCondition);
			RewriteRuleSubtreeStream stream_elseifexpression=new RewriteRuleSubtreeStream(adaptor,"token elseifexpression",list_elseifexpression);
			RewriteRuleSubtreeStream stream_elseexpression=new RewriteRuleSubtreeStream(adaptor,"token elseexpression",list_elseexpression);
			root_0 = (CommonTree)adaptor.Nil();
			// 177:4: -> ^( If $ifCondition $ifExpression ( ^( $elseIfs $elseifCondition $elseifexpression) )* ( ^( Else $elseexpression) )? )
			{
				DebugLocation(177, 6);
				// Grammars\\LavishScript.g:177:6: ^( If $ifCondition $ifExpression ( ^( $elseIfs $elseifCondition $elseifexpression) )* ( ^( Else $elseexpression) )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(177, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_If.NextNode(), root_1);

				DebugLocation(177, 12);
				adaptor.AddChild(root_1, stream_ifCondition.NextTree());
				DebugLocation(177, 25);
				adaptor.AddChild(root_1, stream_ifExpression.NextTree());
				DebugLocation(177, 38);
				// Grammars\\LavishScript.g:177:38: ( ^( $elseIfs $elseifCondition $elseifexpression) )*
				while ( stream_elseIfs.HasNext||stream_elseifCondition.HasNext||stream_elseifexpression.HasNext )
				{
					DebugLocation(177, 38);
					// Grammars\\LavishScript.g:177:38: ^( $elseIfs $elseifCondition $elseifexpression)
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(177, 41);
					root_2 = (CommonTree)adaptor.BecomeRoot(stream_elseIfs.NextNode(), root_2);

					DebugLocation(177, 50);
					adaptor.AddChild(root_2, stream_elseifCondition.NextTree());
					DebugLocation(177, 67);
					adaptor.AddChild(root_2, stream_elseifexpression.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_elseIfs.Reset();
				stream_elseifCondition.Reset();
				stream_elseifexpression.Reset();
				DebugLocation(177, 86);
				// Grammars\\LavishScript.g:177:86: ( ^( Else $elseexpression) )?
				if (stream_Else.HasNext||stream_elseexpression.HasNext)
				{
					DebugLocation(177, 86);
					// Grammars\\LavishScript.g:177:86: ^( Else $elseexpression)
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(177, 88);
					root_2 = (CommonTree)adaptor.BecomeRoot(stream_Else.NextNode(), root_2);

					DebugLocation(177, 94);
					adaptor.AddChild(root_2, stream_elseexpression.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_Else.Reset();
				stream_elseexpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 34);
			LeaveRule("ifStatement", 34);
			LeaveRule_ifStatement();
		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_doStatement();
	partial void LeaveRule_doStatement();
	// $ANTLR start "doStatement"
	// Grammars\\LavishScript.g:179:8: public doStatement : Do expression NewLine While condition -> ^( Do expression condition ) ;
	[GrammarRule("doStatement")]
	public AstParserRuleReturnScope<CommonTree, IToken> doStatement()
	{
		EnterRule_doStatement();
		EnterRule("doStatement", 35);
		TraceIn("doStatement", 35);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Do216 = default(IToken);
		IToken NewLine218 = default(IToken);
		IToken While219 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression217 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition220 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Do216_tree = default(CommonTree);
		CommonTree NewLine218_tree = default(CommonTree);
		CommonTree While219_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Do=new RewriteRuleITokenStream(adaptor,"token Do");
		RewriteRuleITokenStream stream_NewLine=new RewriteRuleITokenStream(adaptor,"token NewLine");
		RewriteRuleITokenStream stream_While=new RewriteRuleITokenStream(adaptor,"token While");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "doStatement");
		DebugLocation(179, 1);
		try
		{
			// Grammars\\LavishScript.g:180:2: ( Do expression NewLine While condition -> ^( Do expression condition ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:180:4: Do expression NewLine While condition
			{
			DebugLocation(180, 4);
			Do216=(IToken)Match(input,Do,Follow._Do_in_doStatement1682); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Do.Add(Do216);

			DebugLocation(180, 7);
			PushFollow(Follow._expression_in_doStatement1684);
			expression217=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression217.Tree);
			DebugLocation(180, 18);
			NewLine218=(IToken)Match(input,NewLine,Follow._NewLine_in_doStatement1686); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NewLine.Add(NewLine218);

			DebugLocation(180, 26);
			While219=(IToken)Match(input,While,Follow._While_in_doStatement1688); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_While.Add(While219);

			DebugLocation(180, 32);
			PushFollow(Follow._condition_in_doStatement1690);
			condition220=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition220.Tree);


			{
			// AST REWRITE
			// elements: Do, expression, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 180:41: -> ^( Do expression condition )
			{
				DebugLocation(180, 43);
				// Grammars\\LavishScript.g:180:43: ^( Do expression condition )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(180, 45);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Do.NextNode(), root_1);

				DebugLocation(180, 48);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(180, 59);
				adaptor.AddChild(root_1, stream_condition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doStatement", 35);
			LeaveRule("doStatement", 35);
			LeaveRule_doStatement();
		}
		DebugLocation(181, 1);
		} finally { DebugExitRule(GrammarFileName, "doStatement"); }
		return retval;

	}
	// $ANTLR end "doStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// Grammars\\LavishScript.g:182:8: public whileStatement : While condition expression -> ^( While condition expression ) ;
	[GrammarRule("whileStatement")]
	public AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 36);
		TraceIn("whileStatement", 36);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken While221 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition222 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression223 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree While221_tree = default(CommonTree);
		RewriteRuleITokenStream stream_While=new RewriteRuleITokenStream(adaptor,"token While");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(182, 1);
		try
		{
			// Grammars\\LavishScript.g:183:2: ( While condition expression -> ^( While condition expression ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:183:4: While condition expression
			{
			DebugLocation(183, 4);
			While221=(IToken)Match(input,While,Follow._While_in_whileStatement1710); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_While.Add(While221);

			DebugLocation(183, 10);
			PushFollow(Follow._condition_in_whileStatement1712);
			condition222=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition222.Tree);
			DebugLocation(183, 20);
			PushFollow(Follow._expression_in_whileStatement1714);
			expression223=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression223.Tree);


			{
			// AST REWRITE
			// elements: While, condition, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 183:30: -> ^( While condition expression )
			{
				DebugLocation(183, 32);
				// Grammars\\LavishScript.g:183:32: ^( While condition expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(183, 34);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_While.NextNode(), root_1);

				DebugLocation(183, 40);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(183, 50);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 36);
			LeaveRule("whileStatement", 36);
			LeaveRule_whileStatement();
		}
		DebugLocation(184, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// Grammars\\LavishScript.g:185:8: public forStatement : ( ( For ws LParen ws command ws Semi ws condition ws Semi ws command RParen )=> ( For ws LParen ws command ws Semi ws condition ws Semi ws command ws RParen ) ( WS )? expression -> ^( For command condition command ) | ( For ws LParen ws condition ws Semi ws command ws RParen )=> ( For ws LParen ws condition ws Semi ws command ws RParen ) ( WS )? expression -> ^( For COMMAND condition command ) | ( For ws LParen ws command ws Semi ws command ws RParen ) ( WS )? expression -> ^( For command CONDITION command ) );
	[GrammarRule("forStatement")]
	public AstParserRuleReturnScope<CommonTree, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 37);
		TraceIn("forStatement", 37);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken For224 = default(IToken);
		IToken LParen226 = default(IToken);
		IToken Semi230 = default(IToken);
		IToken Semi234 = default(IToken);
		IToken RParen238 = default(IToken);
		IToken WS239 = default(IToken);
		IToken For241 = default(IToken);
		IToken LParen243 = default(IToken);
		IToken Semi247 = default(IToken);
		IToken RParen251 = default(IToken);
		IToken WS252 = default(IToken);
		IToken For254 = default(IToken);
		IToken LParen256 = default(IToken);
		IToken Semi260 = default(IToken);
		IToken RParen264 = default(IToken);
		IToken WS265 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ws225 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws227 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command228 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws229 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws231 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition232 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws233 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws235 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command236 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws237 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression240 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws242 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws244 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition245 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws246 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws248 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command249 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws250 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression253 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws255 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws257 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command258 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws259 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws261 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> command262 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws263 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression266 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree For224_tree = default(CommonTree);
		CommonTree LParen226_tree = default(CommonTree);
		CommonTree Semi230_tree = default(CommonTree);
		CommonTree Semi234_tree = default(CommonTree);
		CommonTree RParen238_tree = default(CommonTree);
		CommonTree WS239_tree = default(CommonTree);
		CommonTree For241_tree = default(CommonTree);
		CommonTree LParen243_tree = default(CommonTree);
		CommonTree Semi247_tree = default(CommonTree);
		CommonTree RParen251_tree = default(CommonTree);
		CommonTree WS252_tree = default(CommonTree);
		CommonTree For254_tree = default(CommonTree);
		CommonTree LParen256_tree = default(CommonTree);
		CommonTree Semi260_tree = default(CommonTree);
		CommonTree RParen264_tree = default(CommonTree);
		CommonTree WS265_tree = default(CommonTree);
		RewriteRuleITokenStream stream_For=new RewriteRuleITokenStream(adaptor,"token For");
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_Semi=new RewriteRuleITokenStream(adaptor,"token Semi");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_command=new RewriteRuleSubtreeStream(adaptor,"rule command");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(185, 1);
		try
		{
			// Grammars\\LavishScript.g:186:2: ( ( For ws LParen ws command ws Semi ws condition ws Semi ws command RParen )=> ( For ws LParen ws command ws Semi ws condition ws Semi ws command ws RParen ) ( WS )? expression -> ^( For command condition command ) | ( For ws LParen ws condition ws Semi ws command ws RParen )=> ( For ws LParen ws condition ws Semi ws command ws RParen ) ( WS )? expression -> ^( For COMMAND condition command ) | ( For ws LParen ws command ws Semi ws command ws RParen ) ( WS )? expression -> ^( For command CONDITION command ) )
			int alt73=3;
			try { DebugEnterDecision(73, false);
			int LA73_1 = input.LA(1);

			if ((LA73_1==For))
			{
				int LA73_2 = input.LA(2);

				if ((EvaluatePredicate(synpred10_LavishScript_fragment)))
				{
					alt73 = 1;
				}
				else if ((EvaluatePredicate(synpred11_LavishScript_fragment)))
				{
					alt73 = 2;
				}
				else if ((true))
				{
					alt73 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 73, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 73, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:186:4: ( For ws LParen ws command ws Semi ws condition ws Semi ws command RParen )=> ( For ws LParen ws command ws Semi ws condition ws Semi ws command ws RParen ) ( WS )? expression
				{
				DebugLocation(186, 79);
				// Grammars\\LavishScript.g:186:79: ( For ws LParen ws command ws Semi ws condition ws Semi ws command ws RParen )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:186:80: For ws LParen ws command ws Semi ws condition ws Semi ws command ws RParen
				{
				DebugLocation(186, 80);
				For224=(IToken)Match(input,For,Follow._For_in_forStatement1765); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_For.Add(For224);

				DebugLocation(186, 84);
				PushFollow(Follow._ws_in_forStatement1767);
				ws225=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws225.Tree);
				DebugLocation(186, 87);
				LParen226=(IToken)Match(input,LParen,Follow._LParen_in_forStatement1769); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen226);

				DebugLocation(186, 94);
				PushFollow(Follow._ws_in_forStatement1771);
				ws227=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws227.Tree);
				DebugLocation(186, 97);
				PushFollow(Follow._command_in_forStatement1773);
				command228=command();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_command.Add(command228.Tree);
				DebugLocation(186, 105);
				PushFollow(Follow._ws_in_forStatement1775);
				ws229=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws229.Tree);
				DebugLocation(186, 108);
				Semi230=(IToken)Match(input,Semi,Follow._Semi_in_forStatement1777); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Semi.Add(Semi230);

				DebugLocation(186, 113);
				PushFollow(Follow._ws_in_forStatement1779);
				ws231=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws231.Tree);
				DebugLocation(186, 116);
				PushFollow(Follow._condition_in_forStatement1781);
				condition232=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition232.Tree);
				DebugLocation(186, 126);
				PushFollow(Follow._ws_in_forStatement1783);
				ws233=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws233.Tree);
				DebugLocation(186, 129);
				Semi234=(IToken)Match(input,Semi,Follow._Semi_in_forStatement1785); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Semi.Add(Semi234);

				DebugLocation(186, 134);
				PushFollow(Follow._ws_in_forStatement1787);
				ws235=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws235.Tree);
				DebugLocation(186, 137);
				PushFollow(Follow._command_in_forStatement1789);
				command236=command();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_command.Add(command236.Tree);
				DebugLocation(186, 145);
				PushFollow(Follow._ws_in_forStatement1791);
				ws237=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws237.Tree);
				DebugLocation(186, 148);
				RParen238=(IToken)Match(input,RParen,Follow._RParen_in_forStatement1793); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen238);


				}

				DebugLocation(186, 155);
				// Grammars\\LavishScript.g:186:155: ( WS )?
				int alt70=2;
				try { DebugEnterSubRule(70);
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==WS))
				{
					alt70 = 1;
				}
				} finally { DebugExitDecision(70); }
				switch (alt70)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:186:155: WS
					{
					DebugLocation(186, 155);
					WS239=(IToken)Match(input,WS,Follow._WS_in_forStatement1795); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_WS.Add(WS239);


					}
					break;

				}
				} finally { DebugExitSubRule(70); }

				DebugLocation(186, 159);
				PushFollow(Follow._expression_in_forStatement1798);
				expression240=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression240.Tree);


				{
				// AST REWRITE
				// elements: For, command, condition, command
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 187:4: -> ^( For command condition command )
				{
					DebugLocation(187, 6);
					// Grammars\\LavishScript.g:187:6: ^( For command condition command )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(187, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_For.NextNode(), root_1);

					DebugLocation(187, 12);
					adaptor.AddChild(root_1, stream_command.NextTree());
					DebugLocation(187, 20);
					adaptor.AddChild(root_1, stream_condition.NextTree());
					DebugLocation(187, 30);
					adaptor.AddChild(root_1, stream_command.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:188:4: ( For ws LParen ws condition ws Semi ws command ws RParen )=> ( For ws LParen ws condition ws Semi ws command ws RParen ) ( WS )? expression
				{
				DebugLocation(188, 63);
				// Grammars\\LavishScript.g:188:63: ( For ws LParen ws condition ws Semi ws command ws RParen )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:188:64: For ws LParen ws condition ws Semi ws command ws RParen
				{
				DebugLocation(188, 64);
				For241=(IToken)Match(input,For,Follow._For_in_forStatement1842); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_For.Add(For241);

				DebugLocation(188, 68);
				PushFollow(Follow._ws_in_forStatement1844);
				ws242=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws242.Tree);
				DebugLocation(188, 71);
				LParen243=(IToken)Match(input,LParen,Follow._LParen_in_forStatement1846); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen243);

				DebugLocation(188, 78);
				PushFollow(Follow._ws_in_forStatement1848);
				ws244=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws244.Tree);
				DebugLocation(188, 81);
				PushFollow(Follow._condition_in_forStatement1850);
				condition245=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition245.Tree);
				DebugLocation(188, 91);
				PushFollow(Follow._ws_in_forStatement1852);
				ws246=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws246.Tree);
				DebugLocation(188, 94);
				Semi247=(IToken)Match(input,Semi,Follow._Semi_in_forStatement1854); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Semi.Add(Semi247);

				DebugLocation(188, 99);
				PushFollow(Follow._ws_in_forStatement1856);
				ws248=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws248.Tree);
				DebugLocation(188, 102);
				PushFollow(Follow._command_in_forStatement1858);
				command249=command();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_command.Add(command249.Tree);
				DebugLocation(188, 110);
				PushFollow(Follow._ws_in_forStatement1860);
				ws250=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws250.Tree);
				DebugLocation(188, 113);
				RParen251=(IToken)Match(input,RParen,Follow._RParen_in_forStatement1862); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen251);


				}

				DebugLocation(188, 120);
				// Grammars\\LavishScript.g:188:120: ( WS )?
				int alt71=2;
				try { DebugEnterSubRule(71);
				try { DebugEnterDecision(71, false);
				int LA71_1 = input.LA(1);

				if ((LA71_1==WS))
				{
					alt71 = 1;
				}
				} finally { DebugExitDecision(71); }
				switch (alt71)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:188:120: WS
					{
					DebugLocation(188, 120);
					WS252=(IToken)Match(input,WS,Follow._WS_in_forStatement1864); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_WS.Add(WS252);


					}
					break;

				}
				} finally { DebugExitSubRule(71); }

				DebugLocation(188, 123);
				PushFollow(Follow._expression_in_forStatement1866);
				expression253=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression253.Tree);


				{
				// AST REWRITE
				// elements: For, condition, command
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 189:4: -> ^( For COMMAND condition command )
				{
					DebugLocation(189, 6);
					// Grammars\\LavishScript.g:189:6: ^( For COMMAND condition command )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(189, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_For.NextNode(), root_1);

					DebugLocation(189, 12);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(COMMAND, "COMMAND"));
					DebugLocation(189, 20);
					adaptor.AddChild(root_1, stream_condition.NextTree());
					DebugLocation(189, 30);
					adaptor.AddChild(root_1, stream_command.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:190:4: ( For ws LParen ws command ws Semi ws command ws RParen ) ( WS )? expression
				{
				DebugLocation(190, 4);
				// Grammars\\LavishScript.g:190:4: ( For ws LParen ws command ws Semi ws command ws RParen )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:190:5: For ws LParen ws command ws Semi ws command ws RParen
				{
				DebugLocation(190, 5);
				For254=(IToken)Match(input,For,Follow._For_in_forStatement1886); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_For.Add(For254);

				DebugLocation(190, 9);
				PushFollow(Follow._ws_in_forStatement1888);
				ws255=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws255.Tree);
				DebugLocation(190, 12);
				LParen256=(IToken)Match(input,LParen,Follow._LParen_in_forStatement1890); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen256);

				DebugLocation(190, 19);
				PushFollow(Follow._ws_in_forStatement1892);
				ws257=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws257.Tree);
				DebugLocation(190, 22);
				PushFollow(Follow._command_in_forStatement1894);
				command258=command();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_command.Add(command258.Tree);
				DebugLocation(190, 30);
				PushFollow(Follow._ws_in_forStatement1896);
				ws259=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws259.Tree);
				DebugLocation(190, 33);
				Semi260=(IToken)Match(input,Semi,Follow._Semi_in_forStatement1898); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Semi.Add(Semi260);

				DebugLocation(190, 38);
				PushFollow(Follow._ws_in_forStatement1900);
				ws261=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws261.Tree);
				DebugLocation(190, 41);
				PushFollow(Follow._command_in_forStatement1902);
				command262=command();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_command.Add(command262.Tree);
				DebugLocation(190, 49);
				PushFollow(Follow._ws_in_forStatement1904);
				ws263=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws263.Tree);
				DebugLocation(190, 52);
				RParen264=(IToken)Match(input,RParen,Follow._RParen_in_forStatement1906); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen264);


				}

				DebugLocation(190, 59);
				// Grammars\\LavishScript.g:190:59: ( WS )?
				int alt72=2;
				try { DebugEnterSubRule(72);
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==WS))
				{
					alt72 = 1;
				}
				} finally { DebugExitDecision(72); }
				switch (alt72)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:190:59: WS
					{
					DebugLocation(190, 59);
					WS265=(IToken)Match(input,WS,Follow._WS_in_forStatement1908); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_WS.Add(WS265);


					}
					break;

				}
				} finally { DebugExitSubRule(72); }

				DebugLocation(190, 63);
				PushFollow(Follow._expression_in_forStatement1911);
				expression266=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression266.Tree);


				{
				// AST REWRITE
				// elements: For, command, command
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 191:4: -> ^( For command CONDITION command )
				{
					DebugLocation(191, 6);
					// Grammars\\LavishScript.g:191:6: ^( For command CONDITION command )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(191, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_For.NextNode(), root_1);

					DebugLocation(191, 12);
					adaptor.AddChild(root_1, stream_command.NextTree());
					DebugLocation(191, 20);
					adaptor.AddChild(root_1, (CommonTree)adaptor.Create(CONDITION, "CONDITION"));
					DebugLocation(191, 30);
					adaptor.AddChild(root_1, stream_command.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 37);
			LeaveRule("forStatement", 37);
			LeaveRule_forStatement();
		}
		DebugLocation(192, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_conditionValue();
	partial void LeaveRule_conditionValue();
	// $ANTLR start "conditionValue"
	// Grammars\\LavishScript.g:194:8: public conditionValue : ( ( ( Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString ) -> ^( Negate conditionString ) ) ) | ( ( ID | string | ( math )=> math | conditionString ) ) );
	[GrammarRule("conditionValue")]
	public AstParserRuleReturnScope<CommonTree, IToken> conditionValue()
	{
		EnterRule_conditionValue();
		EnterRule("conditionValue", 38);
		TraceIn("conditionValue", 38);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Negate267 = default(IToken);
		IToken ID268 = default(IToken);
		IToken ID272 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> string269 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> math270 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionString271 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> string273 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> math274 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionString275 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Negate267_tree = default(CommonTree);
		CommonTree ID268_tree = default(CommonTree);
		CommonTree ID272_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Negate=new RewriteRuleITokenStream(adaptor,"token Negate");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_string=new RewriteRuleSubtreeStream(adaptor,"rule string");
		RewriteRuleSubtreeStream stream_math=new RewriteRuleSubtreeStream(adaptor,"rule math");
		RewriteRuleSubtreeStream stream_conditionString=new RewriteRuleSubtreeStream(adaptor,"rule conditionString");
		try { DebugEnterRule(GrammarFileName, "conditionValue");
		DebugLocation(194, 1);
		try
		{
			// Grammars\\LavishScript.g:195:2: ( ( ( Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString ) -> ^( Negate conditionString ) ) ) | ( ( ID | string | ( math )=> math | conditionString ) ) )
			int alt76=2;
			try { DebugEnterDecision(76, false);
			int LA76_1 = input.LA(1);

			if ((LA76_1==Negate))
			{
				alt76 = 1;
			}
			else if (((LA76_1>=ARG && LA76_1<=Comma)||(LA76_1>=DataCommand && LA76_1<=Mult)||(LA76_1>=NotEqualTo && LA76_1<=RCurly)||(LA76_1>=RSquare && LA76_1<=Xor)))
			{
				alt76 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 76, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:195:4: ( ( Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString ) -> ^( Negate conditionString ) ) )
				{
				DebugLocation(195, 4);
				// Grammars\\LavishScript.g:195:4: ( ( Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString ) -> ^( Negate conditionString ) ) )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:196:4: ( Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString ) -> ^( Negate conditionString ) )
				{
				DebugLocation(196, 4);
				// Grammars\\LavishScript.g:196:4: ( Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString ) -> ^( Negate conditionString ) )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:196:5: Negate ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString )
				{
				DebugLocation(196, 5);
				Negate267=(IToken)Match(input,Negate,Follow._Negate_in_conditionValue1944); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Negate.Add(Negate267);

				DebugLocation(197, 4);
				// Grammars\\LavishScript.g:197:4: ( ID -> ^( Negate ID ) | string -> ^( Negate string ) | ( math )=> math -> ^( Negate math ) | conditionString )
				int alt74=4;
				try { DebugEnterSubRule(74);
				try { DebugEnterDecision(74, false);
				int LA74_1 = input.LA(1);

				if ((LA74_1==ID))
				{
					alt74 = 1;
				}
				else if ((LA74_1==Quote))
				{
					alt74 = 2;
				}
				else if ((LA74_1==LParen) && (EvaluatePredicate(synpred12_LavishScript_fragment)))
				{
					alt74 = 3;
				}
				else if ((LA74_1==INT))
				{
					int LA74_2 = input.LA(2);

					if ((EvaluatePredicate(synpred12_LavishScript_fragment)))
					{
						alt74 = 3;
					}
					else if ((true))
					{
						alt74 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 74, 4, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA74_1==FLOAT))
				{
					int LA74_2 = input.LA(2);

					if ((EvaluatePredicate(synpred12_LavishScript_fragment)))
					{
						alt74 = 3;
					}
					else if ((true))
					{
						alt74 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 74, 5, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA74_1==Dollar))
				{
					int LA74_2 = input.LA(2);

					if ((EvaluatePredicate(synpred12_LavishScript_fragment)))
					{
						alt74 = 3;
					}
					else if ((true))
					{
						alt74 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 74, 6, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if (((LA74_1>=ARG && LA74_1<=Comma)||(LA74_1>=DataCommand && LA74_1<=Do)||(LA74_1>=Dot && LA74_1<=Error)||(LA74_1>=For && LA74_1<=HEX_DIGIT)||(LA74_1>=If && LA74_1<=LCurly)||(LA74_1>=LSquare && LA74_1<=Negate)||(LA74_1>=NotEqualTo && LA74_1<=PreIf)||LA74_1==RCurly||(LA74_1>=RSquare && LA74_1<=Xor)))
				{
					alt74 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 74, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(74); }
				switch (alt74)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:197:5: ID
					{
					DebugLocation(197, 5);
					ID268=(IToken)Match(input,ID,Follow._ID_in_conditionValue1950); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID268);



					{
					// AST REWRITE
					// elements: Negate, ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 197:7: -> ^( Negate ID )
					{
						DebugLocation(197, 9);
						// Grammars\\LavishScript.g:197:9: ^( Negate ID )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(197, 11);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_Negate.NextNode(), root_1);

						DebugLocation(197, 18);
						adaptor.AddChild(root_1, stream_ID.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:198:5: string
					{
					DebugLocation(198, 5);
					PushFollow(Follow._string_in_conditionValue1962);
					string269=@string();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_string.Add(string269.Tree);


					{
					// AST REWRITE
					// elements: Negate, string
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 198:11: -> ^( Negate string )
					{
						DebugLocation(198, 13);
						// Grammars\\LavishScript.g:198:13: ^( Negate string )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(198, 15);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_Negate.NextNode(), root_1);

						DebugLocation(198, 22);
						adaptor.AddChild(root_1, stream_string.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\LavishScript.g:199:5: ( math )=> math
					{
					DebugLocation(199, 13);
					PushFollow(Follow._math_in_conditionValue1978);
					math270=math();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_math.Add(math270.Tree);


					{
					// AST REWRITE
					// elements: Negate, math
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 199:17: -> ^( Negate math )
					{
						DebugLocation(199, 19);
						// Grammars\\LavishScript.g:199:19: ^( Negate math )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(199, 21);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_Negate.NextNode(), root_1);

						DebugLocation(199, 28);
						adaptor.AddChild(root_1, stream_math.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammars\\LavishScript.g:200:5: conditionString
					{
					DebugLocation(200, 5);
					PushFollow(Follow._conditionString_in_conditionValue1990);
					conditionString271=conditionString();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_conditionString.Add(conditionString271.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(74); }



				{
				// AST REWRITE
				// elements: Negate, conditionString
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 200:21: -> ^( Negate conditionString )
				{
					DebugLocation(200, 23);
					// Grammars\\LavishScript.g:200:23: ^( Negate conditionString )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(200, 25);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_Negate.NextNode(), root_1);

					DebugLocation(200, 32);
					adaptor.AddChild(root_1, stream_conditionString.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:203:3: ( ( ID | string | ( math )=> math | conditionString ) )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(203, 3);
				// Grammars\\LavishScript.g:203:3: ( ( ID | string | ( math )=> math | conditionString ) )
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:204:4: ( ID | string | ( math )=> math | conditionString )
				{
				DebugLocation(204, 4);
				// Grammars\\LavishScript.g:204:4: ( ID | string | ( math )=> math | conditionString )
				int alt75=4;
				try { DebugEnterSubRule(75);
				try { DebugEnterDecision(75, false);
				int LA75_1 = input.LA(1);

				if ((LA75_1==ID))
				{
					alt75 = 1;
				}
				else if ((LA75_1==Quote))
				{
					alt75 = 2;
				}
				else if ((LA75_1==LParen) && (EvaluatePredicate(synpred13_LavishScript_fragment)))
				{
					alt75 = 3;
				}
				else if ((LA75_1==INT))
				{
					int LA75_2 = input.LA(2);

					if ((EvaluatePredicate(synpred13_LavishScript_fragment)))
					{
						alt75 = 3;
					}
					else if ((true))
					{
						alt75 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 75, 4, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA75_1==FLOAT))
				{
					int LA75_2 = input.LA(2);

					if ((EvaluatePredicate(synpred13_LavishScript_fragment)))
					{
						alt75 = 3;
					}
					else if ((true))
					{
						alt75 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 75, 5, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA75_1==Dollar))
				{
					int LA75_2 = input.LA(2);

					if ((EvaluatePredicate(synpred13_LavishScript_fragment)))
					{
						alt75 = 3;
					}
					else if ((true))
					{
						alt75 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 75, 6, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if (((LA75_1>=ARG && LA75_1<=Comma)||(LA75_1>=DataCommand && LA75_1<=Do)||(LA75_1>=Dot && LA75_1<=Error)||(LA75_1>=For && LA75_1<=HEX_DIGIT)||(LA75_1>=If && LA75_1<=LCurly)||(LA75_1>=LSquare && LA75_1<=Negate)||(LA75_1>=NotEqualTo && LA75_1<=PreIf)||LA75_1==RCurly||(LA75_1>=RSquare && LA75_1<=Xor)))
				{
					alt75 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 75, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(75); }
				switch (alt75)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:204:5: ID
					{
					DebugLocation(204, 5);
					ID272=(IToken)Match(input,ID,Follow._ID_in_conditionValue2016); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID272_tree = (CommonTree)adaptor.Create(ID272);
					adaptor.AddChild(root_0, ID272_tree);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:205:5: string
					{
					DebugLocation(205, 5);
					PushFollow(Follow._string_in_conditionValue2022);
					string273=@string();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, string273.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\LavishScript.g:206:5: ( math )=> math
					{
					DebugLocation(206, 13);
					PushFollow(Follow._math_in_conditionValue2032);
					math274=math();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, math274.Tree);

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammars\\LavishScript.g:207:5: conditionString
					{
					DebugLocation(207, 5);
					PushFollow(Follow._conditionString_in_conditionValue2038);
					conditionString275=conditionString();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, conditionString275.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(75); }


				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionValue", 38);
			LeaveRule("conditionValue", 38);
			LeaveRule_conditionValue();
		}
		DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionValue"); }
		return retval;

	}
	// $ANTLR end "conditionValue"

	partial void EnterRule_conditionString();
	partial void LeaveRule_conditionString();
	// $ANTLR start "conditionString"
	// Grammars\\LavishScript.g:210:8: public conditionString : ~ ( Comparer | LParen | RParen | NewLine ) ;
	[GrammarRule("conditionString")]
	public AstParserRuleReturnScope<CommonTree, IToken> conditionString()
	{
		EnterRule_conditionString();
		EnterRule("conditionString", 39);
		TraceIn("conditionString", 39);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set276 = default(IToken);

		CommonTree set276_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "conditionString");
		DebugLocation(210, 1);
		try
		{
			// Grammars\\LavishScript.g:211:2: (~ ( Comparer | LParen | RParen | NewLine ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(211, 2);

			set276=(IToken)input.LT(1);
			if ((input.LA(1)>=ARG && input.LA(1)<=Comma)||(input.LA(1)>=DataCommand && input.LA(1)<=LCurly)||(input.LA(1)>=LSquare && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=RCurly)||(input.LA(1)>=RSquare && input.LA(1)<=Xor))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set276));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionString", 39);
			LeaveRule("conditionString", 39);
			LeaveRule_conditionString();
		}
		DebugLocation(212, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionString"); }
		return retval;

	}
	// $ANTLR end "conditionString"

	partial void EnterRule_math();
	partial void LeaveRule_math();
	// $ANTLR start "math"
	// Grammars\\LavishScript.g:213:8: public math : bitXor ( Bor ^ bitXor )* ;
	[GrammarRule("math")]
	public AstParserRuleReturnScope<CommonTree, IToken> math()
	{
		EnterRule_math();
		EnterRule("math", 40);
		TraceIn("math", 40);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Bor278 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitXor277 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitXor279 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Bor278_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "math");
		DebugLocation(213, 1);
		try
		{
			// Grammars\\LavishScript.g:214:2: ( bitXor ( Bor ^ bitXor )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:214:4: bitXor ( Bor ^ bitXor )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(214, 4);
			PushFollow(Follow._bitXor_in_math2076);
			bitXor277=bitXor();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitXor277.Tree);
			DebugLocation(214, 11);
			// Grammars\\LavishScript.g:214:11: ( Bor ^ bitXor )*
			try { DebugEnterSubRule(77);
			while (true)
			{
				int alt77=2;
				try { DebugEnterDecision(77, false);
				int LA77_1 = input.LA(1);

				if ((LA77_1==Bor))
				{
					alt77 = 1;
				}


				} finally { DebugExitDecision(77); }
				switch ( alt77 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:214:12: Bor ^ bitXor
					{
					DebugLocation(214, 15);
					Bor278=(IToken)Match(input,Bor,Follow._Bor_in_math2079); if (state.failed) return retval;
					if (state.backtracking == 0) {
					Bor278_tree = (CommonTree)adaptor.Create(Bor278);
					root_0 = (CommonTree)adaptor.BecomeRoot(Bor278_tree, root_0);
					}
					DebugLocation(214, 17);
					PushFollow(Follow._bitXor_in_math2082);
					bitXor279=bitXor();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitXor279.Tree);

					}
					break;

				default:
					goto loop77;
				}
			}

			loop77:
				;

			} finally { DebugExitSubRule(77); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("math", 40);
			LeaveRule("math", 40);
			LeaveRule_math();
		}
		DebugLocation(215, 1);
		} finally { DebugExitRule(GrammarFileName, "math"); }
		return retval;

	}
	// $ANTLR end "math"

	partial void EnterRule_bitXor();
	partial void LeaveRule_bitXor();
	// $ANTLR start "bitXor"
	// Grammars\\LavishScript.g:216:8: public bitXor : bitAnd ( Xor ^ bitAnd )* ;
	[GrammarRule("bitXor")]
	public AstParserRuleReturnScope<CommonTree, IToken> bitXor()
	{
		EnterRule_bitXor();
		EnterRule("bitXor", 41);
		TraceIn("bitXor", 41);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Xor281 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitAnd280 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitAnd282 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Xor281_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bitXor");
		DebugLocation(216, 1);
		try
		{
			// Grammars\\LavishScript.g:217:2: ( bitAnd ( Xor ^ bitAnd )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:217:4: bitAnd ( Xor ^ bitAnd )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(217, 4);
			PushFollow(Follow._bitAnd_in_bitXor2096);
			bitAnd280=bitAnd();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitAnd280.Tree);
			DebugLocation(217, 11);
			// Grammars\\LavishScript.g:217:11: ( Xor ^ bitAnd )*
			try { DebugEnterSubRule(78);
			while (true)
			{
				int alt78=2;
				try { DebugEnterDecision(78, false);
				int LA78_1 = input.LA(1);

				if ((LA78_1==Xor))
				{
					alt78 = 1;
				}


				} finally { DebugExitDecision(78); }
				switch ( alt78 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:217:12: Xor ^ bitAnd
					{
					DebugLocation(217, 15);
					Xor281=(IToken)Match(input,Xor,Follow._Xor_in_bitXor2099); if (state.failed) return retval;
					if (state.backtracking == 0) {
					Xor281_tree = (CommonTree)adaptor.Create(Xor281);
					root_0 = (CommonTree)adaptor.BecomeRoot(Xor281_tree, root_0);
					}
					DebugLocation(217, 17);
					PushFollow(Follow._bitAnd_in_bitXor2102);
					bitAnd282=bitAnd();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitAnd282.Tree);

					}
					break;

				default:
					goto loop78;
				}
			}

			loop78:
				;

			} finally { DebugExitSubRule(78); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitXor", 41);
			LeaveRule("bitXor", 41);
			LeaveRule_bitXor();
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "bitXor"); }
		return retval;

	}
	// $ANTLR end "bitXor"

	partial void EnterRule_bitAnd();
	partial void LeaveRule_bitAnd();
	// $ANTLR start "bitAnd"
	// Grammars\\LavishScript.g:219:8: public bitAnd : shift ( Band ^ shift )* ;
	[GrammarRule("bitAnd")]
	public AstParserRuleReturnScope<CommonTree, IToken> bitAnd()
	{
		EnterRule_bitAnd();
		EnterRule("bitAnd", 42);
		TraceIn("bitAnd", 42);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Band284 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> shift283 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift285 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Band284_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bitAnd");
		DebugLocation(219, 1);
		try
		{
			// Grammars\\LavishScript.g:220:2: ( shift ( Band ^ shift )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:220:4: shift ( Band ^ shift )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(220, 4);
			PushFollow(Follow._shift_in_bitAnd2116);
			shift283=shift();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shift283.Tree);
			DebugLocation(220, 10);
			// Grammars\\LavishScript.g:220:10: ( Band ^ shift )*
			try { DebugEnterSubRule(79);
			while (true)
			{
				int alt79=2;
				try { DebugEnterDecision(79, false);
				int LA79_1 = input.LA(1);

				if ((LA79_1==Band))
				{
					alt79 = 1;
				}


				} finally { DebugExitDecision(79); }
				switch ( alt79 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:220:11: Band ^ shift
					{
					DebugLocation(220, 15);
					Band284=(IToken)Match(input,Band,Follow._Band_in_bitAnd2119); if (state.failed) return retval;
					if (state.backtracking == 0) {
					Band284_tree = (CommonTree)adaptor.Create(Band284);
					root_0 = (CommonTree)adaptor.BecomeRoot(Band284_tree, root_0);
					}
					DebugLocation(220, 17);
					PushFollow(Follow._shift_in_bitAnd2122);
					shift285=shift();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shift285.Tree);

					}
					break;

				default:
					goto loop79;
				}
			}

			loop79:
				;

			} finally { DebugExitSubRule(79); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitAnd", 42);
			LeaveRule("bitAnd", 42);
			LeaveRule_bitAnd();
		}
		DebugLocation(221, 1);
		} finally { DebugExitRule(GrammarFileName, "bitAnd"); }
		return retval;

	}
	// $ANTLR end "bitAnd"

	partial void EnterRule_shift();
	partial void LeaveRule_shift();
	// $ANTLR start "shift"
	// Grammars\\LavishScript.g:222:8: public shift : addSub ( ( LeftShift ^| RightShift ^) addSub )* ;
	[GrammarRule("shift")]
	public AstParserRuleReturnScope<CommonTree, IToken> shift()
	{
		EnterRule_shift();
		EnterRule("shift", 43);
		TraceIn("shift", 43);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LeftShift287 = default(IToken);
		IToken RightShift288 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> addSub286 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> addSub289 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LeftShift287_tree = default(CommonTree);
		CommonTree RightShift288_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "shift");
		DebugLocation(222, 1);
		try
		{
			// Grammars\\LavishScript.g:223:2: ( addSub ( ( LeftShift ^| RightShift ^) addSub )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:223:4: addSub ( ( LeftShift ^| RightShift ^) addSub )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(223, 4);
			PushFollow(Follow._addSub_in_shift2136);
			addSub286=addSub();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, addSub286.Tree);
			DebugLocation(223, 11);
			// Grammars\\LavishScript.g:223:11: ( ( LeftShift ^| RightShift ^) addSub )*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=2;
				try { DebugEnterDecision(81, false);
				int LA81_1 = input.LA(1);

				if ((LA81_1==LeftShift))
				{
					alt81 = 1;
				}
				else if ((LA81_1==RightShift))
				{
					alt81 = 1;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:223:12: ( LeftShift ^| RightShift ^) addSub
					{
					DebugLocation(223, 12);
					// Grammars\\LavishScript.g:223:12: ( LeftShift ^| RightShift ^)
					int alt80=2;
					try { DebugEnterSubRule(80);
					try { DebugEnterDecision(80, false);
					int LA80_1 = input.LA(1);

					if ((LA80_1==LeftShift))
					{
						alt80 = 1;
					}
					else if ((LA80_1==RightShift))
					{
						alt80 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 80, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(80); }
					switch (alt80)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:223:13: LeftShift ^
						{
						DebugLocation(223, 22);
						LeftShift287=(IToken)Match(input,LeftShift,Follow._LeftShift_in_shift2140); if (state.failed) return retval;
						if (state.backtracking == 0) {
						LeftShift287_tree = (CommonTree)adaptor.Create(LeftShift287);
						root_0 = (CommonTree)adaptor.BecomeRoot(LeftShift287_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishScript.g:223:24: RightShift ^
						{
						DebugLocation(223, 34);
						RightShift288=(IToken)Match(input,RightShift,Follow._RightShift_in_shift2143); if (state.failed) return retval;
						if (state.backtracking == 0) {
						RightShift288_tree = (CommonTree)adaptor.Create(RightShift288);
						root_0 = (CommonTree)adaptor.BecomeRoot(RightShift288_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(80); }

					DebugLocation(223, 37);
					PushFollow(Follow._addSub_in_shift2147);
					addSub289=addSub();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, addSub289.Tree);

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift", 43);
			LeaveRule("shift", 43);
			LeaveRule_shift();
		}
		DebugLocation(224, 1);
		} finally { DebugExitRule(GrammarFileName, "shift"); }
		return retval;

	}
	// $ANTLR end "shift"

	partial void EnterRule_addSub();
	partial void LeaveRule_addSub();
	// $ANTLR start "addSub"
	// Grammars\\LavishScript.g:225:8: public addSub : multDiv ( ( Plus ^| Minus ^) multDiv )* ;
	[GrammarRule("addSub")]
	public AstParserRuleReturnScope<CommonTree, IToken> addSub()
	{
		EnterRule_addSub();
		EnterRule("addSub", 44);
		TraceIn("addSub", 44);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Plus291 = default(IToken);
		IToken Minus292 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multDiv290 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multDiv293 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Plus291_tree = default(CommonTree);
		CommonTree Minus292_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "addSub");
		DebugLocation(225, 1);
		try
		{
			// Grammars\\LavishScript.g:226:2: ( multDiv ( ( Plus ^| Minus ^) multDiv )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:226:4: multDiv ( ( Plus ^| Minus ^) multDiv )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(226, 4);
			PushFollow(Follow._multDiv_in_addSub2161);
			multDiv290=multDiv();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multDiv290.Tree);
			DebugLocation(226, 12);
			// Grammars\\LavishScript.g:226:12: ( ( Plus ^| Minus ^) multDiv )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==Plus))
				{
					alt83 = 1;
				}
				else if ((LA83_1==Minus))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:226:13: ( Plus ^| Minus ^) multDiv
					{
					DebugLocation(226, 13);
					// Grammars\\LavishScript.g:226:13: ( Plus ^| Minus ^)
					int alt82=2;
					try { DebugEnterSubRule(82);
					try { DebugEnterDecision(82, false);
					int LA82_1 = input.LA(1);

					if ((LA82_1==Plus))
					{
						alt82 = 1;
					}
					else if ((LA82_1==Minus))
					{
						alt82 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 82, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(82); }
					switch (alt82)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:226:14: Plus ^
						{
						DebugLocation(226, 18);
						Plus291=(IToken)Match(input,Plus,Follow._Plus_in_addSub2165); if (state.failed) return retval;
						if (state.backtracking == 0) {
						Plus291_tree = (CommonTree)adaptor.Create(Plus291);
						root_0 = (CommonTree)adaptor.BecomeRoot(Plus291_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishScript.g:226:20: Minus ^
						{
						DebugLocation(226, 25);
						Minus292=(IToken)Match(input,Minus,Follow._Minus_in_addSub2168); if (state.failed) return retval;
						if (state.backtracking == 0) {
						Minus292_tree = (CommonTree)adaptor.Create(Minus292);
						root_0 = (CommonTree)adaptor.BecomeRoot(Minus292_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(82); }

					DebugLocation(226, 28);
					PushFollow(Follow._multDiv_in_addSub2172);
					multDiv293=multDiv();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multDiv293.Tree);

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("addSub", 44);
			LeaveRule("addSub", 44);
			LeaveRule_addSub();
		}
		DebugLocation(227, 1);
		} finally { DebugExitRule(GrammarFileName, "addSub"); }
		return retval;

	}
	// $ANTLR end "addSub"

	partial void EnterRule_multDiv();
	partial void LeaveRule_multDiv();
	// $ANTLR start "multDiv"
	// Grammars\\LavishScript.g:228:8: public multDiv : bitNegate ( ( Mult ^| Div ^| Modu ^) bitNegate )* ;
	[GrammarRule("multDiv")]
	public AstParserRuleReturnScope<CommonTree, IToken> multDiv()
	{
		EnterRule_multDiv();
		EnterRule("multDiv", 45);
		TraceIn("multDiv", 45);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Mult295 = default(IToken);
		IToken Div296 = default(IToken);
		IToken Modu297 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitNegate294 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitNegate298 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Mult295_tree = default(CommonTree);
		CommonTree Div296_tree = default(CommonTree);
		CommonTree Modu297_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multDiv");
		DebugLocation(228, 1);
		try
		{
			// Grammars\\LavishScript.g:229:2: ( bitNegate ( ( Mult ^| Div ^| Modu ^) bitNegate )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:229:4: bitNegate ( ( Mult ^| Div ^| Modu ^) bitNegate )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(229, 4);
			PushFollow(Follow._bitNegate_in_multDiv2186);
			bitNegate294=bitNegate();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitNegate294.Tree);
			DebugLocation(229, 14);
			// Grammars\\LavishScript.g:229:14: ( ( Mult ^| Div ^| Modu ^) bitNegate )*
			try { DebugEnterSubRule(85);
			while (true)
			{
				int alt85=2;
				try { DebugEnterDecision(85, false);
				switch (input.LA(1))
				{
				case Mult:
					{
					alt85 = 1;
					}
					break;
				case Div:
					{
					alt85 = 1;
					}
					break;
				case Modu:
					{
					alt85 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(85); }
				switch ( alt85 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:229:15: ( Mult ^| Div ^| Modu ^) bitNegate
					{
					DebugLocation(229, 15);
					// Grammars\\LavishScript.g:229:15: ( Mult ^| Div ^| Modu ^)
					int alt84=3;
					try { DebugEnterSubRule(84);
					try { DebugEnterDecision(84, false);
					switch (input.LA(1))
					{
					case Mult:
						{
						alt84 = 1;
						}
						break;
					case Div:
						{
						alt84 = 2;
						}
						break;
					case Modu:
						{
						alt84 = 3;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 84, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(84); }
					switch (alt84)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:229:16: Mult ^
						{
						DebugLocation(229, 20);
						Mult295=(IToken)Match(input,Mult,Follow._Mult_in_multDiv2190); if (state.failed) return retval;
						if (state.backtracking == 0) {
						Mult295_tree = (CommonTree)adaptor.Create(Mult295);
						root_0 = (CommonTree)adaptor.BecomeRoot(Mult295_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishScript.g:229:22: Div ^
						{
						DebugLocation(229, 25);
						Div296=(IToken)Match(input,Div,Follow._Div_in_multDiv2193); if (state.failed) return retval;
						if (state.backtracking == 0) {
						Div296_tree = (CommonTree)adaptor.Create(Div296);
						root_0 = (CommonTree)adaptor.BecomeRoot(Div296_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Grammars\\LavishScript.g:229:27: Modu ^
						{
						DebugLocation(229, 31);
						Modu297=(IToken)Match(input,Modu,Follow._Modu_in_multDiv2196); if (state.failed) return retval;
						if (state.backtracking == 0) {
						Modu297_tree = (CommonTree)adaptor.Create(Modu297);
						root_0 = (CommonTree)adaptor.BecomeRoot(Modu297_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(84); }

					DebugLocation(229, 34);
					PushFollow(Follow._bitNegate_in_multDiv2200);
					bitNegate298=bitNegate();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitNegate298.Tree);

					}
					break;

				default:
					goto loop85;
				}
			}

			loop85:
				;

			} finally { DebugExitSubRule(85); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multDiv", 45);
			LeaveRule("multDiv", 45);
			LeaveRule_multDiv();
		}
		DebugLocation(230, 1);
		} finally { DebugExitRule(GrammarFileName, "multDiv"); }
		return retval;

	}
	// $ANTLR end "multDiv"

	partial void EnterRule_bitNegate();
	partial void LeaveRule_bitNegate();
	// $ANTLR start "bitNegate"
	// Grammars\\LavishScript.g:231:8: public bitNegate : mathVal ( Bnegate ^ mathVal )* ;
	[GrammarRule("bitNegate")]
	public AstParserRuleReturnScope<CommonTree, IToken> bitNegate()
	{
		EnterRule_bitNegate();
		EnterRule("bitNegate", 46);
		TraceIn("bitNegate", 46);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Bnegate300 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> mathVal299 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> mathVal301 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Bnegate300_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bitNegate");
		DebugLocation(231, 1);
		try
		{
			// Grammars\\LavishScript.g:232:2: ( mathVal ( Bnegate ^ mathVal )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:232:4: mathVal ( Bnegate ^ mathVal )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(232, 4);
			PushFollow(Follow._mathVal_in_bitNegate2214);
			mathVal299=mathVal();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mathVal299.Tree);
			DebugLocation(232, 12);
			// Grammars\\LavishScript.g:232:12: ( Bnegate ^ mathVal )*
			try { DebugEnterSubRule(86);
			while (true)
			{
				int alt86=2;
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==Bnegate))
				{
					alt86 = 1;
				}


				} finally { DebugExitDecision(86); }
				switch ( alt86 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:232:13: Bnegate ^ mathVal
					{
					DebugLocation(232, 20);
					Bnegate300=(IToken)Match(input,Bnegate,Follow._Bnegate_in_bitNegate2217); if (state.failed) return retval;
					if (state.backtracking == 0) {
					Bnegate300_tree = (CommonTree)adaptor.Create(Bnegate300);
					root_0 = (CommonTree)adaptor.BecomeRoot(Bnegate300_tree, root_0);
					}
					DebugLocation(232, 22);
					PushFollow(Follow._mathVal_in_bitNegate2220);
					mathVal301=mathVal();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mathVal301.Tree);

					}
					break;

				default:
					goto loop86;
				}
			}

			loop86:
				;

			} finally { DebugExitSubRule(86); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitNegate", 46);
			LeaveRule("bitNegate", 46);
			LeaveRule_bitNegate();
		}
		DebugLocation(233, 1);
		} finally { DebugExitRule(GrammarFileName, "bitNegate"); }
		return retval;

	}
	// $ANTLR end "bitNegate"

	partial void EnterRule_mathVal();
	partial void LeaveRule_mathVal();
	// $ANTLR start "mathVal"
	// Grammars\\LavishScript.g:234:8: public mathVal : ( LParen ! math RParen !| ( INT | FLOAT | dataSequence ) );
	[GrammarRule("mathVal")]
	public AstParserRuleReturnScope<CommonTree, IToken> mathVal()
	{
		EnterRule_mathVal();
		EnterRule("mathVal", 47);
		TraceIn("mathVal", 47);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LParen302 = default(IToken);
		IToken RParen304 = default(IToken);
		IToken INT305 = default(IToken);
		IToken FLOAT306 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> math303 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence307 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LParen302_tree = default(CommonTree);
		CommonTree RParen304_tree = default(CommonTree);
		CommonTree INT305_tree = default(CommonTree);
		CommonTree FLOAT306_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "mathVal");
		DebugLocation(234, 1);
		try
		{
			// Grammars\\LavishScript.g:235:2: ( LParen ! math RParen !| ( INT | FLOAT | dataSequence ) )
			int alt88=2;
			try { DebugEnterDecision(88, false);
			int LA88_1 = input.LA(1);

			if ((LA88_1==LParen))
			{
				alt88 = 1;
			}
			else if ((LA88_1==Dollar||LA88_1==FLOAT||LA88_1==INT))
			{
				alt88 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 88, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:235:4: LParen ! math RParen !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(235, 10);
				LParen302=(IToken)Match(input,LParen,Follow._LParen_in_mathVal2234); if (state.failed) return retval;
				DebugLocation(235, 12);
				PushFollow(Follow._math_in_mathVal2237);
				math303=math();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, math303.Tree);
				DebugLocation(235, 23);
				RParen304=(IToken)Match(input,RParen,Follow._RParen_in_mathVal2239); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:236:4: ( INT | FLOAT | dataSequence )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(236, 4);
				// Grammars\\LavishScript.g:236:4: ( INT | FLOAT | dataSequence )
				int alt87=3;
				try { DebugEnterSubRule(87);
				try { DebugEnterDecision(87, false);
				switch (input.LA(1))
				{
				case INT:
					{
					alt87 = 1;
					}
					break;
				case FLOAT:
					{
					alt87 = 2;
					}
					break;
				case Dollar:
					{
					alt87 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 87, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(87); }
				switch (alt87)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:236:5: INT
					{
					DebugLocation(236, 5);
					INT305=(IToken)Match(input,INT,Follow._INT_in_mathVal2246); if (state.failed) return retval;
					if (state.backtracking == 0) {
					INT305_tree = (CommonTree)adaptor.Create(INT305);
					adaptor.AddChild(root_0, INT305_tree);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:236:9: FLOAT
					{
					DebugLocation(236, 9);
					FLOAT306=(IToken)Match(input,FLOAT,Follow._FLOAT_in_mathVal2248); if (state.failed) return retval;
					if (state.backtracking == 0) {
					FLOAT306_tree = (CommonTree)adaptor.Create(FLOAT306);
					adaptor.AddChild(root_0, FLOAT306_tree);
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\LavishScript.g:236:15: dataSequence
					{
					DebugLocation(236, 15);
					PushFollow(Follow._dataSequence_in_mathVal2250);
					dataSequence307=dataSequence();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, dataSequence307.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(87); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mathVal", 47);
			LeaveRule("mathVal", 47);
			LeaveRule_mathVal();
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "mathVal"); }
		return retval;

	}
	// $ANTLR end "mathVal"

	partial void EnterRule_ws();
	partial void LeaveRule_ws();
	// $ANTLR start "ws"
	// Grammars\\LavishScript.g:238:8: public ws : ( NewLine !)? ( WS !)? ;
	[GrammarRule("ws")]
	public AstParserRuleReturnScope<CommonTree, IToken> ws()
	{
		EnterRule_ws();
		EnterRule("ws", 48);
		TraceIn("ws", 48);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NewLine308 = default(IToken);
		IToken WS309 = default(IToken);

		CommonTree NewLine308_tree = default(CommonTree);
		CommonTree WS309_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "ws");
		DebugLocation(238, 1);
		try
		{
			// Grammars\\LavishScript.g:239:2: ( ( NewLine !)? ( WS !)? )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:239:4: ( NewLine !)? ( WS !)?
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(239, 11);
			// Grammars\\LavishScript.g:239:11: ( NewLine !)?
			int alt89=2;
			try { DebugEnterSubRule(89);
			try { DebugEnterDecision(89, false);
			int LA89_1 = input.LA(1);

			if ((LA89_1==NewLine))
			{
				alt89 = 1;
			}
			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:239:11: NewLine !
				{
				DebugLocation(239, 11);
				NewLine308=(IToken)Match(input,NewLine,Follow._NewLine_in_ws2263); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(89); }

			DebugLocation(239, 16);
			// Grammars\\LavishScript.g:239:16: ( WS !)?
			int alt90=2;
			try { DebugEnterSubRule(90);
			try { DebugEnterDecision(90, false);
			int LA90_1 = input.LA(1);

			if ((LA90_1==WS))
			{
				alt90 = 1;
			}
			} finally { DebugExitDecision(90); }
			switch (alt90)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:239:16: WS !
				{
				DebugLocation(239, 16);
				WS309=(IToken)Match(input,WS,Follow._WS_in_ws2267); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(90); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ws", 48);
			LeaveRule("ws", 48);
			LeaveRule_ws();
		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "ws"); }
		return retval;

	}
	// $ANTLR end "ws"

	partial void EnterRule_lineArg();
	partial void LeaveRule_lineArg();
	// $ANTLR start "lineArg"
	// Grammars\\LavishScript.g:241:8: public lineArg : ( ID | string | ( math )=> math | (~ NewLine ) );
	[GrammarRule("lineArg")]
	public AstParserRuleReturnScope<CommonTree, IToken> lineArg()
	{
		EnterRule_lineArg();
		EnterRule("lineArg", 49);
		TraceIn("lineArg", 49);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID310 = default(IToken);
		IToken set313 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> string311 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> math312 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ID310_tree = default(CommonTree);
		CommonTree set313_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "lineArg");
		DebugLocation(241, 1);
		try
		{
			// Grammars\\LavishScript.g:242:2: ( ID | string | ( math )=> math | (~ NewLine ) )
			int alt91=4;
			try { DebugEnterDecision(91, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt91 = 1;
				}
				break;
			case Quote:
				{
				alt91 = 2;
				}
				break;
			case LParen:
				{
				int LA91_2 = input.LA(2);

				if ((EvaluatePredicate(synpred14_LavishScript_fragment)))
				{
					alt91 = 3;
				}
				else if ((true))
				{
					alt91 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				int LA91_2 = input.LA(2);

				if ((EvaluatePredicate(synpred14_LavishScript_fragment)))
				{
					alt91 = 3;
				}
				else if ((true))
				{
					alt91 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FLOAT:
				{
				int LA91_2 = input.LA(2);

				if ((EvaluatePredicate(synpred14_LavishScript_fragment)))
				{
					alt91 = 3;
				}
				else if ((true))
				{
					alt91 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Dollar:
				{
				int LA91_2 = input.LA(2);

				if ((EvaluatePredicate(synpred14_LavishScript_fragment)))
				{
					alt91 = 3;
				}
				else if ((true))
				{
					alt91 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case Band:
			case Bnegate:
			case Bor:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Div:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LSquare:
			case LeftShift:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Minus:
			case Modu:
			case Mult:
			case Negate:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case Plus:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case RCurly:
			case RParen:
			case RSquare:
			case Returns:
			case RightShift:
			case STRING:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
			case Xor:
				{
				alt91 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(91); }
			switch (alt91)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:242:4: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(242, 4);
				ID310=(IToken)Match(input,ID,Follow._ID_in_lineArg2281); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID310_tree = (CommonTree)adaptor.Create(ID310);
				adaptor.AddChild(root_0, ID310_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:243:4: string
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(243, 4);
				PushFollow(Follow._string_in_lineArg2286);
				string311=@string();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, string311.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:244:4: ( math )=> math
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(244, 12);
				PushFollow(Follow._math_in_lineArg2295);
				math312=math();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, math312.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:245:4: (~ NewLine )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(245, 4);

				set313=(IToken)input.LT(1);
				if ((input.LA(1)>=ARG && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=Xor))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set313));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lineArg", 49);
			LeaveRule("lineArg", 49);
			LeaveRule_lineArg();
		}
		DebugLocation(246, 1);
		} finally { DebugExitRule(GrammarFileName, "lineArg"); }
		return retval;

	}
	// $ANTLR end "lineArg"

	partial void EnterRule_commaArg();
	partial void LeaveRule_commaArg();
	// $ANTLR start "commaArg"
	// Grammars\\LavishScript.g:247:8: public commaArg : ( ID | string | ( math )=> math | (~ ( Comma | RSquare ) ) );
	[GrammarRule("commaArg")]
	public AstParserRuleReturnScope<CommonTree, IToken> commaArg()
	{
		EnterRule_commaArg();
		EnterRule("commaArg", 50);
		TraceIn("commaArg", 50);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID314 = default(IToken);
		IToken set317 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> string315 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> math316 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ID314_tree = default(CommonTree);
		CommonTree set317_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "commaArg");
		DebugLocation(247, 1);
		try
		{
			// Grammars\\LavishScript.g:248:2: ( ID | string | ( math )=> math | (~ ( Comma | RSquare ) ) )
			int alt92=4;
			try { DebugEnterDecision(92, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt92 = 1;
				}
				break;
			case Quote:
				{
				alt92 = 2;
				}
				break;
			case LParen:
				{
				int LA92_2 = input.LA(2);

				if ((EvaluatePredicate(synpred15_LavishScript_fragment)))
				{
					alt92 = 3;
				}
				else if ((true))
				{
					alt92 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				int LA92_2 = input.LA(2);

				if ((EvaluatePredicate(synpred15_LavishScript_fragment)))
				{
					alt92 = 3;
				}
				else if ((true))
				{
					alt92 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FLOAT:
				{
				int LA92_2 = input.LA(2);

				if ((EvaluatePredicate(synpred15_LavishScript_fragment)))
				{
					alt92 = 3;
				}
				else if ((true))
				{
					alt92 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Dollar:
				{
				int LA92_2 = input.LA(2);

				if ((EvaluatePredicate(synpred15_LavishScript_fragment)))
				{
					alt92 = 3;
				}
				else if ((true))
				{
					alt92 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case Band:
			case Bnegate:
			case Bor:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Div:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LSquare:
			case LeftShift:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Minus:
			case Modu:
			case Mult:
			case Negate:
			case NewLine:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case Plus:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case RCurly:
			case RParen:
			case Returns:
			case RightShift:
			case STRING:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
			case Xor:
				{
				alt92 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(92); }
			switch (alt92)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:248:4: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(248, 4);
				ID314=(IToken)Match(input,ID,Follow._ID_in_commaArg2315); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID314_tree = (CommonTree)adaptor.Create(ID314);
				adaptor.AddChild(root_0, ID314_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:249:4: string
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(249, 4);
				PushFollow(Follow._string_in_commaArg2320);
				string315=@string();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, string315.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:250:4: ( math )=> math
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(250, 12);
				PushFollow(Follow._math_in_commaArg2329);
				math316=math();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, math316.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:251:4: (~ ( Comma | RSquare ) )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(251, 4);

				set317=(IToken)input.LT(1);
				if ((input.LA(1)>=ARG && input.LA(1)<=Colon)||(input.LA(1)>=Comparer && input.LA(1)<=RParen)||(input.LA(1)>=Returns && input.LA(1)<=Xor))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set317));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("commaArg", 50);
			LeaveRule("commaArg", 50);
			LeaveRule_commaArg();
		}
		DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "commaArg"); }
		return retval;

	}
	// $ANTLR end "commaArg"

	partial void EnterRule_commandArg();
	partial void LeaveRule_commandArg();
	// $ANTLR start "commandArg"
	// Grammars\\LavishScript.g:253:8: public commandArg : ( ID | string | ( math )=> math |~ ( NewLine | Semi ) );
	[GrammarRule("commandArg")]
	public AstParserRuleReturnScope<CommonTree, IToken> commandArg()
	{
		EnterRule_commandArg();
		EnterRule("commandArg", 51);
		TraceIn("commandArg", 51);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID318 = default(IToken);
		IToken set321 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> string319 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> math320 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ID318_tree = default(CommonTree);
		CommonTree set321_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "commandArg");
		DebugLocation(253, 1);
		try
		{
			// Grammars\\LavishScript.g:254:2: ( ID | string | ( math )=> math |~ ( NewLine | Semi ) )
			int alt93=4;
			try { DebugEnterDecision(93, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt93 = 1;
				}
				break;
			case Quote:
				{
				alt93 = 2;
				}
				break;
			case LParen:
				{
				int LA93_2 = input.LA(2);

				if ((EvaluatePredicate(synpred16_LavishScript_fragment)))
				{
					alt93 = 3;
				}
				else if ((true))
				{
					alt93 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 93, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				int LA93_2 = input.LA(2);

				if ((EvaluatePredicate(synpred16_LavishScript_fragment)))
				{
					alt93 = 3;
				}
				else if ((true))
				{
					alt93 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 93, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FLOAT:
				{
				int LA93_2 = input.LA(2);

				if ((EvaluatePredicate(synpred16_LavishScript_fragment)))
				{
					alt93 = 3;
				}
				else if ((true))
				{
					alt93 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 93, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Dollar:
				{
				int LA93_2 = input.LA(2);

				if ((EvaluatePredicate(synpred16_LavishScript_fragment)))
				{
					alt93 = 3;
				}
				else if ((true))
				{
					alt93 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 93, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case Band:
			case Bnegate:
			case Bor:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Div:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LSquare:
			case LeftShift:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Minus:
			case Modu:
			case Mult:
			case Negate:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case Plus:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case RCurly:
			case RParen:
			case RSquare:
			case Returns:
			case RightShift:
			case STRING:
			case Scope:
			case Script:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
			case Xor:
				{
				alt93 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 93, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(93); }
			switch (alt93)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:254:4: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(254, 4);
				ID318=(IToken)Match(input,ID,Follow._ID_in_commandArg2353); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID318_tree = (CommonTree)adaptor.Create(ID318);
				adaptor.AddChild(root_0, ID318_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:255:4: string
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(255, 4);
				PushFollow(Follow._string_in_commandArg2358);
				string319=@string();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, string319.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:256:4: ( math )=> math
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(256, 12);
				PushFollow(Follow._math_in_commandArg2367);
				math320=math();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, math320.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:257:4: ~ ( NewLine | Semi )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(257, 4);

				set321=(IToken)input.LT(1);
				if ((input.LA(1)>=ARG && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=Script)||(input.LA(1)>=Switch && input.LA(1)<=Xor))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set321));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("commandArg", 51);
			LeaveRule("commandArg", 51);
			LeaveRule_commandArg();
		}
		DebugLocation(258, 1);
		} finally { DebugExitRule(GrammarFileName, "commandArg"); }
		return retval;

	}
	// $ANTLR end "commandArg"

	partial void EnterRule_condition();
	partial void LeaveRule_condition();
	// $ANTLR start "condition"
	// Grammars\\LavishScript.g:259:8: public condition : ws ( LParen ws condition ws RParen ( orCondition | andCondition )? -> condition ( orCondition )? ( andCondition )? | Negate ws LParen ws condition ws RParen ( orCondition | andCondition )? -> ^( Negate condition ) ( orCondition )? ( andCondition )? | ( conditionValue ws Comparer )=> conditionValue ws Comparer ws conditionValue ( orCondition | andCondition )? -> ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? ) | conditionValue ( orCondition | andCondition )? -> ^( CONDITION conditionValue ( orCondition )? ( andCondition )? ) ) ;
	[GrammarRule("condition")]
	public AstParserRuleReturnScope<CommonTree, IToken> condition()
	{
		EnterRule_condition();
		EnterRule("condition", 52);
		TraceIn("condition", 52);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LParen323 = default(IToken);
		IToken RParen327 = default(IToken);
		IToken Negate330 = default(IToken);
		IToken LParen332 = default(IToken);
		IToken RParen336 = default(IToken);
		IToken Comparer341 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ws322 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws324 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition325 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws326 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> orCondition328 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> andCondition329 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws331 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws333 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition334 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws335 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> orCondition337 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> andCondition338 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionValue339 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws340 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws342 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionValue343 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> orCondition344 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> andCondition345 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionValue346 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> orCondition347 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> andCondition348 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LParen323_tree = default(CommonTree);
		CommonTree RParen327_tree = default(CommonTree);
		CommonTree Negate330_tree = default(CommonTree);
		CommonTree LParen332_tree = default(CommonTree);
		CommonTree RParen336_tree = default(CommonTree);
		CommonTree Comparer341_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_Negate=new RewriteRuleITokenStream(adaptor,"token Negate");
		RewriteRuleITokenStream stream_Comparer=new RewriteRuleITokenStream(adaptor,"token Comparer");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_orCondition=new RewriteRuleSubtreeStream(adaptor,"rule orCondition");
		RewriteRuleSubtreeStream stream_andCondition=new RewriteRuleSubtreeStream(adaptor,"rule andCondition");
		RewriteRuleSubtreeStream stream_conditionValue=new RewriteRuleSubtreeStream(adaptor,"rule conditionValue");
		try { DebugEnterRule(GrammarFileName, "condition");
		DebugLocation(259, 1);
		try
		{
			// Grammars\\LavishScript.g:260:2: ( ws ( LParen ws condition ws RParen ( orCondition | andCondition )? -> condition ( orCondition )? ( andCondition )? | Negate ws LParen ws condition ws RParen ( orCondition | andCondition )? -> ^( Negate condition ) ( orCondition )? ( andCondition )? | ( conditionValue ws Comparer )=> conditionValue ws Comparer ws conditionValue ( orCondition | andCondition )? -> ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? ) | conditionValue ( orCondition | andCondition )? -> ^( CONDITION conditionValue ( orCondition )? ( andCondition )? ) ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:260:4: ws ( LParen ws condition ws RParen ( orCondition | andCondition )? -> condition ( orCondition )? ( andCondition )? | Negate ws LParen ws condition ws RParen ( orCondition | andCondition )? -> ^( Negate condition ) ( orCondition )? ( andCondition )? | ( conditionValue ws Comparer )=> conditionValue ws Comparer ws conditionValue ( orCondition | andCondition )? -> ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? ) | conditionValue ( orCondition | andCondition )? -> ^( CONDITION conditionValue ( orCondition )? ( andCondition )? ) )
			{
			DebugLocation(260, 4);
			PushFollow(Follow._ws_in_condition2389);
			ws322=ws();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ws.Add(ws322.Tree);
			DebugLocation(261, 2);
			// Grammars\\LavishScript.g:261:2: ( LParen ws condition ws RParen ( orCondition | andCondition )? -> condition ( orCondition )? ( andCondition )? | Negate ws LParen ws condition ws RParen ( orCondition | andCondition )? -> ^( Negate condition ) ( orCondition )? ( andCondition )? | ( conditionValue ws Comparer )=> conditionValue ws Comparer ws conditionValue ( orCondition | andCondition )? -> ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? ) | conditionValue ( orCondition | andCondition )? -> ^( CONDITION conditionValue ( orCondition )? ( andCondition )? ) )
			int alt98=4;
			try { DebugEnterSubRule(98);
			try { DebugEnterDecision(98, false);
			switch (input.LA(1))
			{
			case LParen:
				{
				alt98 = 1;
				}
				break;
			case Negate:
				{
				alt98 = 2;
				}
				break;
			case ID:
				{
				int LA98_2 = input.LA(2);

				if ((EvaluatePredicate(synpred17_LavishScript_fragment)))
				{
					alt98 = 3;
				}
				else if ((true))
				{
					alt98 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Quote:
				{
				int LA98_2 = input.LA(2);

				if ((EvaluatePredicate(synpred17_LavishScript_fragment)))
				{
					alt98 = 3;
				}
				else if ((true))
				{
					alt98 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				int LA98_2 = input.LA(2);

				if ((EvaluatePredicate(synpred17_LavishScript_fragment)))
				{
					alt98 = 3;
				}
				else if ((true))
				{
					alt98 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FLOAT:
				{
				int LA98_2 = input.LA(2);

				if ((EvaluatePredicate(synpred17_LavishScript_fragment)))
				{
					alt98 = 3;
				}
				else if ((true))
				{
					alt98 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Dollar:
				{
				int LA98_2 = input.LA(2);

				if ((EvaluatePredicate(synpred17_LavishScript_fragment)))
				{
					alt98 = 3;
				}
				else if ((true))
				{
					alt98 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case Band:
			case Bnegate:
			case Bor:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Div:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LSquare:
			case LeftShift:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Minus:
			case Modu:
			case Mult:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case Plus:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case RCurly:
			case RSquare:
			case Returns:
			case RightShift:
			case STRING:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
			case Xor:
				{
				int LA98_2 = input.LA(2);

				if ((EvaluatePredicate(synpred17_LavishScript_fragment)))
				{
					alt98 = 3;
				}
				else if ((true))
				{
					alt98 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:261:4: LParen ws condition ws RParen ( orCondition | andCondition )?
				{
				DebugLocation(261, 4);
				LParen323=(IToken)Match(input,LParen,Follow._LParen_in_condition2395); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen323);

				DebugLocation(261, 11);
				PushFollow(Follow._ws_in_condition2397);
				ws324=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws324.Tree);
				DebugLocation(261, 14);
				PushFollow(Follow._condition_in_condition2399);
				condition325=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition325.Tree);
				DebugLocation(261, 24);
				PushFollow(Follow._ws_in_condition2401);
				ws326=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws326.Tree);
				DebugLocation(261, 27);
				RParen327=(IToken)Match(input,RParen,Follow._RParen_in_condition2403); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen327);

				DebugLocation(261, 34);
				// Grammars\\LavishScript.g:261:34: ( orCondition | andCondition )?
				int alt94=3;
				try { DebugEnterSubRule(94);
				try { DebugEnterDecision(94, false);
				int LA94_1 = input.LA(1);

				if ((LA94_1==Or))
				{
					alt94 = 1;
				}
				else if ((LA94_1==And))
				{
					alt94 = 2;
				}
				} finally { DebugExitDecision(94); }
				switch (alt94)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:261:35: orCondition
					{
					DebugLocation(261, 35);
					PushFollow(Follow._orCondition_in_condition2406);
					orCondition328=orCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_orCondition.Add(orCondition328.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:261:47: andCondition
					{
					DebugLocation(261, 47);
					PushFollow(Follow._andCondition_in_condition2408);
					andCondition329=andCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_andCondition.Add(andCondition329.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(94); }



				{
				// AST REWRITE
				// elements: condition, orCondition, andCondition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 262:4: -> condition ( orCondition )? ( andCondition )?
				{
					DebugLocation(262, 6);
					adaptor.AddChild(root_0, stream_condition.NextTree());
					DebugLocation(262, 16);
					// Grammars\\LavishScript.g:262:16: ( orCondition )?
					if (stream_orCondition.HasNext)
					{
						DebugLocation(262, 16);
						adaptor.AddChild(root_0, stream_orCondition.NextTree());

					}
					stream_orCondition.Reset();
					DebugLocation(262, 29);
					// Grammars\\LavishScript.g:262:29: ( andCondition )?
					if (stream_andCondition.HasNext)
					{
						DebugLocation(262, 29);
						adaptor.AddChild(root_0, stream_andCondition.NextTree());

					}
					stream_andCondition.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:263:4: Negate ws LParen ws condition ws RParen ( orCondition | andCondition )?
				{
				DebugLocation(263, 4);
				Negate330=(IToken)Match(input,Negate,Follow._Negate_in_condition2427); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Negate.Add(Negate330);

				DebugLocation(263, 11);
				PushFollow(Follow._ws_in_condition2429);
				ws331=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws331.Tree);
				DebugLocation(263, 14);
				LParen332=(IToken)Match(input,LParen,Follow._LParen_in_condition2431); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen332);

				DebugLocation(263, 21);
				PushFollow(Follow._ws_in_condition2433);
				ws333=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws333.Tree);
				DebugLocation(263, 24);
				PushFollow(Follow._condition_in_condition2435);
				condition334=condition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_condition.Add(condition334.Tree);
				DebugLocation(263, 34);
				PushFollow(Follow._ws_in_condition2437);
				ws335=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws335.Tree);
				DebugLocation(263, 37);
				RParen336=(IToken)Match(input,RParen,Follow._RParen_in_condition2439); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen336);

				DebugLocation(263, 44);
				// Grammars\\LavishScript.g:263:44: ( orCondition | andCondition )?
				int alt95=3;
				try { DebugEnterSubRule(95);
				try { DebugEnterDecision(95, false);
				int LA95_1 = input.LA(1);

				if ((LA95_1==Or))
				{
					alt95 = 1;
				}
				else if ((LA95_1==And))
				{
					alt95 = 2;
				}
				} finally { DebugExitDecision(95); }
				switch (alt95)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:263:45: orCondition
					{
					DebugLocation(263, 45);
					PushFollow(Follow._orCondition_in_condition2442);
					orCondition337=orCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_orCondition.Add(orCondition337.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:263:57: andCondition
					{
					DebugLocation(263, 57);
					PushFollow(Follow._andCondition_in_condition2444);
					andCondition338=andCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_andCondition.Add(andCondition338.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(95); }



				{
				// AST REWRITE
				// elements: Negate, condition, orCondition, andCondition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 264:4: -> ^( Negate condition ) ( orCondition )? ( andCondition )?
				{
					DebugLocation(264, 6);
					// Grammars\\LavishScript.g:264:6: ^( Negate condition )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(264, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_Negate.NextNode(), root_1);

					DebugLocation(264, 15);
					adaptor.AddChild(root_1, stream_condition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(264, 26);
					// Grammars\\LavishScript.g:264:26: ( orCondition )?
					if (stream_orCondition.HasNext)
					{
						DebugLocation(264, 26);
						adaptor.AddChild(root_0, stream_orCondition.NextTree());

					}
					stream_orCondition.Reset();
					DebugLocation(264, 39);
					// Grammars\\LavishScript.g:264:39: ( andCondition )?
					if (stream_andCondition.HasNext)
					{
						DebugLocation(264, 39);
						adaptor.AddChild(root_0, stream_andCondition.NextTree());

					}
					stream_andCondition.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:265:4: ( conditionValue ws Comparer )=> conditionValue ws Comparer ws conditionValue ( orCondition | andCondition )?
				{
				DebugLocation(265, 34);
				PushFollow(Follow._conditionValue_in_condition2475);
				conditionValue339=conditionValue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionValue.Add(conditionValue339.Tree);
				DebugLocation(265, 49);
				PushFollow(Follow._ws_in_condition2477);
				ws340=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws340.Tree);
				DebugLocation(265, 52);
				Comparer341=(IToken)Match(input,Comparer,Follow._Comparer_in_condition2479); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Comparer.Add(Comparer341);

				DebugLocation(265, 61);
				PushFollow(Follow._ws_in_condition2481);
				ws342=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws342.Tree);
				DebugLocation(265, 64);
				PushFollow(Follow._conditionValue_in_condition2483);
				conditionValue343=conditionValue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionValue.Add(conditionValue343.Tree);
				DebugLocation(265, 79);
				// Grammars\\LavishScript.g:265:79: ( orCondition | andCondition )?
				int alt96=3;
				try { DebugEnterSubRule(96);
				try { DebugEnterDecision(96, false);
				int LA96_1 = input.LA(1);

				if ((LA96_1==Or))
				{
					alt96 = 1;
				}
				else if ((LA96_1==And))
				{
					alt96 = 2;
				}
				} finally { DebugExitDecision(96); }
				switch (alt96)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:265:80: orCondition
					{
					DebugLocation(265, 80);
					PushFollow(Follow._orCondition_in_condition2486);
					orCondition344=orCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_orCondition.Add(orCondition344.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:265:92: andCondition
					{
					DebugLocation(265, 92);
					PushFollow(Follow._andCondition_in_condition2488);
					andCondition345=andCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_andCondition.Add(andCondition345.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(96); }



				{
				// AST REWRITE
				// elements: Comparer, conditionValue, conditionValue, orCondition, andCondition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 266:4: -> ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? )
				{
					DebugLocation(266, 6);
					// Grammars\\LavishScript.g:266:6: ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(266, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONDITION, "CONDITION"), root_1);

					DebugLocation(266, 18);
					// Grammars\\LavishScript.g:266:18: ^( Comparer conditionValue conditionValue )
					{
					CommonTree root_2 = (CommonTree)adaptor.Nil();
					DebugLocation(266, 20);
					root_2 = (CommonTree)adaptor.BecomeRoot(stream_Comparer.NextNode(), root_2);

					DebugLocation(266, 29);
					adaptor.AddChild(root_2, stream_conditionValue.NextTree());
					DebugLocation(266, 44);
					adaptor.AddChild(root_2, stream_conditionValue.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(266, 60);
					// Grammars\\LavishScript.g:266:60: ( orCondition )?
					if (stream_orCondition.HasNext)
					{
						DebugLocation(266, 60);
						adaptor.AddChild(root_1, stream_orCondition.NextTree());

					}
					stream_orCondition.Reset();
					DebugLocation(266, 73);
					// Grammars\\LavishScript.g:266:73: ( andCondition )?
					if (stream_andCondition.HasNext)
					{
						DebugLocation(266, 73);
						adaptor.AddChild(root_1, stream_andCondition.NextTree());

					}
					stream_andCondition.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:267:4: conditionValue ( orCondition | andCondition )?
				{
				DebugLocation(267, 4);
				PushFollow(Follow._conditionValue_in_condition2517);
				conditionValue346=conditionValue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionValue.Add(conditionValue346.Tree);
				DebugLocation(267, 19);
				// Grammars\\LavishScript.g:267:19: ( orCondition | andCondition )?
				int alt97=3;
				try { DebugEnterSubRule(97);
				try { DebugEnterDecision(97, false);
				int LA97_1 = input.LA(1);

				if ((LA97_1==Or))
				{
					alt97 = 1;
				}
				else if ((LA97_1==And))
				{
					alt97 = 2;
				}
				} finally { DebugExitDecision(97); }
				switch (alt97)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:267:20: orCondition
					{
					DebugLocation(267, 20);
					PushFollow(Follow._orCondition_in_condition2520);
					orCondition347=orCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_orCondition.Add(orCondition347.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:267:32: andCondition
					{
					DebugLocation(267, 32);
					PushFollow(Follow._andCondition_in_condition2522);
					andCondition348=andCondition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_andCondition.Add(andCondition348.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(97); }



				{
				// AST REWRITE
				// elements: conditionValue, orCondition, andCondition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 267:46: -> ^( CONDITION conditionValue ( orCondition )? ( andCondition )? )
				{
					DebugLocation(267, 48);
					// Grammars\\LavishScript.g:267:48: ^( CONDITION conditionValue ( orCondition )? ( andCondition )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(267, 50);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONDITION, "CONDITION"), root_1);

					DebugLocation(267, 60);
					adaptor.AddChild(root_1, stream_conditionValue.NextTree());
					DebugLocation(267, 75);
					// Grammars\\LavishScript.g:267:75: ( orCondition )?
					if (stream_orCondition.HasNext)
					{
						DebugLocation(267, 75);
						adaptor.AddChild(root_1, stream_orCondition.NextTree());

					}
					stream_orCondition.Reset();
					DebugLocation(267, 88);
					// Grammars\\LavishScript.g:267:88: ( andCondition )?
					if (stream_andCondition.HasNext)
					{
						DebugLocation(267, 88);
						adaptor.AddChild(root_1, stream_andCondition.NextTree());

					}
					stream_andCondition.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(98); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condition", 52);
			LeaveRule("condition", 52);
			LeaveRule_condition();
		}
		DebugLocation(269, 1);
		} finally { DebugExitRule(GrammarFileName, "condition"); }
		return retval;

	}
	// $ANTLR end "condition"

	partial void EnterRule_orCondition();
	partial void LeaveRule_orCondition();
	// $ANTLR start "orCondition"
	// Grammars\\LavishScript.g:270:8: public orCondition : Or condition -> ^( Or condition ) ;
	[GrammarRule("orCondition")]
	public AstParserRuleReturnScope<CommonTree, IToken> orCondition()
	{
		EnterRule_orCondition();
		EnterRule("orCondition", 53);
		TraceIn("orCondition", 53);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Or349 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition350 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Or349_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Or=new RewriteRuleITokenStream(adaptor,"token Or");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "orCondition");
		DebugLocation(270, 1);
		try
		{
			// Grammars\\LavishScript.g:271:2: ( Or condition -> ^( Or condition ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:271:4: Or condition
			{
			DebugLocation(271, 4);
			Or349=(IToken)Match(input,Or,Follow._Or_in_orCondition2551); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Or.Add(Or349);

			DebugLocation(271, 7);
			PushFollow(Follow._condition_in_orCondition2553);
			condition350=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition350.Tree);


			{
			// AST REWRITE
			// elements: Or, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 271:16: -> ^( Or condition )
			{
				DebugLocation(271, 18);
				// Grammars\\LavishScript.g:271:18: ^( Or condition )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(271, 20);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Or.NextNode(), root_1);

				DebugLocation(271, 23);
				adaptor.AddChild(root_1, stream_condition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orCondition", 53);
			LeaveRule("orCondition", 53);
			LeaveRule_orCondition();
		}
		DebugLocation(273, 1);
		} finally { DebugExitRule(GrammarFileName, "orCondition"); }
		return retval;

	}
	// $ANTLR end "orCondition"

	partial void EnterRule_andCondition();
	partial void LeaveRule_andCondition();
	// $ANTLR start "andCondition"
	// Grammars\\LavishScript.g:274:8: public andCondition : And condition -> ^( And condition ) ;
	[GrammarRule("andCondition")]
	public AstParserRuleReturnScope<CommonTree, IToken> andCondition()
	{
		EnterRule_andCondition();
		EnterRule("andCondition", 54);
		TraceIn("andCondition", 54);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken And351 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition352 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree And351_tree = default(CommonTree);
		RewriteRuleITokenStream stream_And=new RewriteRuleITokenStream(adaptor,"token And");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "andCondition");
		DebugLocation(274, 1);
		try
		{
			// Grammars\\LavishScript.g:275:2: ( And condition -> ^( And condition ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:275:4: And condition
			{
			DebugLocation(275, 4);
			And351=(IToken)Match(input,And,Follow._And_in_andCondition2574); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_And.Add(And351);

			DebugLocation(275, 8);
			PushFollow(Follow._condition_in_andCondition2576);
			condition352=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition352.Tree);


			{
			// AST REWRITE
			// elements: And, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 275:17: -> ^( And condition )
			{
				DebugLocation(275, 19);
				// Grammars\\LavishScript.g:275:19: ^( And condition )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(275, 21);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_And.NextNode(), root_1);

				DebugLocation(275, 25);
				adaptor.AddChild(root_1, stream_condition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("andCondition", 54);
			LeaveRule("andCondition", 54);
			LeaveRule_andCondition();
		}
		DebugLocation(276, 1);
		} finally { DebugExitRule(GrammarFileName, "andCondition"); }
		return retval;

	}
	// $ANTLR end "andCondition"

	partial void EnterRule_variableDeclare();
	partial void LeaveRule_variableDeclare();
	// $ANTLR start "variableDeclare"
	// Grammars\\LavishScript.g:278:8: public variableDeclare : Variable ( LParen Scope RParen )? WS type= ID WS name= ID ( indexer )? ( ws Assign ws lineArg ( WS lineArg )* )? -> ^( Variable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) ) ;
	[GrammarRule("variableDeclare")]
	public AstParserRuleReturnScope<CommonTree, IToken> variableDeclare()
	{
		EnterRule_variableDeclare();
		EnterRule("variableDeclare", 55);
		TraceIn("variableDeclare", 55);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken type = default(IToken);
		IToken name = default(IToken);
		IToken Variable353 = default(IToken);
		IToken LParen354 = default(IToken);
		IToken Scope355 = default(IToken);
		IToken RParen356 = default(IToken);
		IToken WS357 = default(IToken);
		IToken WS358 = default(IToken);
		IToken Assign361 = default(IToken);
		IToken WS364 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> indexer359 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws360 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ws362 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg363 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg365 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree type_tree = default(CommonTree);
		CommonTree name_tree = default(CommonTree);
		CommonTree Variable353_tree = default(CommonTree);
		CommonTree LParen354_tree = default(CommonTree);
		CommonTree Scope355_tree = default(CommonTree);
		CommonTree RParen356_tree = default(CommonTree);
		CommonTree WS357_tree = default(CommonTree);
		CommonTree WS358_tree = default(CommonTree);
		CommonTree Assign361_tree = default(CommonTree);
		CommonTree WS364_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Variable=new RewriteRuleITokenStream(adaptor,"token Variable");
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_Scope=new RewriteRuleITokenStream(adaptor,"token Scope");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_Assign=new RewriteRuleITokenStream(adaptor,"token Assign");
		RewriteRuleSubtreeStream stream_indexer=new RewriteRuleSubtreeStream(adaptor,"rule indexer");
		RewriteRuleSubtreeStream stream_ws=new RewriteRuleSubtreeStream(adaptor,"rule ws");
		RewriteRuleSubtreeStream stream_lineArg=new RewriteRuleSubtreeStream(adaptor,"rule lineArg");
		try { DebugEnterRule(GrammarFileName, "variableDeclare");
		DebugLocation(278, 1);
		try
		{
			// Grammars\\LavishScript.g:279:2: ( Variable ( LParen Scope RParen )? WS type= ID WS name= ID ( indexer )? ( ws Assign ws lineArg ( WS lineArg )* )? -> ^( Variable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:279:4: Variable ( LParen Scope RParen )? WS type= ID WS name= ID ( indexer )? ( ws Assign ws lineArg ( WS lineArg )* )?
			{
			DebugLocation(279, 4);
			Variable353=(IToken)Match(input,Variable,Follow._Variable_in_variableDeclare2595); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Variable.Add(Variable353);

			DebugLocation(279, 12);
			// Grammars\\LavishScript.g:279:12: ( LParen Scope RParen )?
			int alt99=2;
			try { DebugEnterSubRule(99);
			try { DebugEnterDecision(99, false);
			int LA99_1 = input.LA(1);

			if ((LA99_1==LParen))
			{
				alt99 = 1;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:279:13: LParen Scope RParen
				{
				DebugLocation(279, 13);
				LParen354=(IToken)Match(input,LParen,Follow._LParen_in_variableDeclare2597); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LParen.Add(LParen354);

				DebugLocation(279, 20);
				Scope355=(IToken)Match(input,Scope,Follow._Scope_in_variableDeclare2599); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Scope.Add(Scope355);

				DebugLocation(279, 26);
				RParen356=(IToken)Match(input,RParen,Follow._RParen_in_variableDeclare2601); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RParen.Add(RParen356);


				}
				break;

			}
			} finally { DebugExitSubRule(99); }

			DebugLocation(279, 35);
			WS357=(IToken)Match(input,WS,Follow._WS_in_variableDeclare2605); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS357);

			DebugLocation(279, 42);
			type=(IToken)Match(input,ID,Follow._ID_in_variableDeclare2609); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(type);

			DebugLocation(279, 46);
			WS358=(IToken)Match(input,WS,Follow._WS_in_variableDeclare2611); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS358);

			DebugLocation(279, 53);
			name=(IToken)Match(input,ID,Follow._ID_in_variableDeclare2615); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(279, 57);
			// Grammars\\LavishScript.g:279:57: ( indexer )?
			int alt100=2;
			try { DebugEnterSubRule(100);
			try { DebugEnterDecision(100, false);
			int LA100_1 = input.LA(1);

			if ((LA100_1==LSquare))
			{
				alt100 = 1;
			}
			} finally { DebugExitDecision(100); }
			switch (alt100)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:279:57: indexer
				{
				DebugLocation(279, 57);
				PushFollow(Follow._indexer_in_variableDeclare2617);
				indexer359=indexer();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_indexer.Add(indexer359.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(100); }

			DebugLocation(279, 66);
			// Grammars\\LavishScript.g:279:66: ( ws Assign ws lineArg ( WS lineArg )* )?
			int alt102=2;
			try { DebugEnterSubRule(102);
			try { DebugEnterDecision(102, false);
			switch (input.LA(1))
			{
			case NewLine:
				{
				int LA102_2 = input.LA(2);

				if ((LA102_2==WS))
				{
					int LA102_3 = input.LA(3);

					if ((LA102_3==Assign))
					{
						alt102 = 1;
					}
				}
				else if ((LA102_2==Assign))
				{
					alt102 = 1;
				}
				}
				break;
			case WS:
				{
				int LA102_2 = input.LA(2);

				if ((LA102_2==Assign))
				{
					alt102 = 1;
				}
				}
				break;
			case Assign:
				{
				alt102 = 1;
				}
				break;
			}

			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:279:67: ws Assign ws lineArg ( WS lineArg )*
				{
				DebugLocation(279, 67);
				PushFollow(Follow._ws_in_variableDeclare2621);
				ws360=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws360.Tree);
				DebugLocation(279, 70);
				Assign361=(IToken)Match(input,Assign,Follow._Assign_in_variableDeclare2623); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Assign.Add(Assign361);

				DebugLocation(279, 77);
				PushFollow(Follow._ws_in_variableDeclare2625);
				ws362=ws();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ws.Add(ws362.Tree);
				DebugLocation(279, 80);
				PushFollow(Follow._lineArg_in_variableDeclare2627);
				lineArg363=lineArg();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lineArg.Add(lineArg363.Tree);
				DebugLocation(279, 88);
				// Grammars\\LavishScript.g:279:88: ( WS lineArg )*
				try { DebugEnterSubRule(101);
				while (true)
				{
					int alt101=2;
					try { DebugEnterDecision(101, false);
					int LA101_1 = input.LA(1);

					if ((LA101_1==WS))
					{
						switch (input.LA(2))
						{
						case EndMac:
							{
							alt101 = 1;
							}
							break;
						case WS:
							{
							alt101 = 1;
							}
							break;
						case ARG:
						case And:
						case Assign:
						case Atom:
						case Band:
						case Bnegate:
						case Bor:
						case COMMAND:
						case COMMENT:
						case CONDITION:
						case Case:
						case CodeBlock:
						case Colon:
						case Comma:
						case Comparer:
						case DataCommand:
						case DeclareVariable:
						case Default:
						case Define:
						case Div:
						case Do:
						case Dollar:
						case Dot:
						case ESC_SEQ:
						case EXPONENT:
						case Echo:
						case Elipse:
						case Else:
						case ElseIf:
						case EndIf:
						case EqualTo:
						case Error:
						case FLOAT:
						case For:
						case Function:
						case GreaterThan:
						case GreaterThanEqual:
						case HEX_DIGIT:
						case ID:
						case INT:
						case If:
						case IfDef:
						case IfNDef:
						case Include:
						case Inherits:
						case LCurly:
						case LParen:
						case LSquare:
						case LeftShift:
						case LessThan:
						case LessThanEqual:
						case MATH:
						case Macro:
						case Member:
						case Method:
						case Minus:
						case Modu:
						case Mult:
						case Negate:
						case NotEqualTo:
						case OCTAL_ESC:
						case ObjectDef:
						case Or:
						case Other:
						case Param:
						case Params:
						case Plus:
						case PreElse:
						case PreElseIf:
						case PreIf:
						case Quote:
						case RCurly:
						case RParen:
						case RSquare:
						case Returns:
						case RightShift:
						case STRING:
						case Scope:
						case Script:
						case Semi:
						case Switch:
						case Type:
						case UNICODE_ESC:
						case Unmac:
						case Variable:
						case VariableCase:
						case While:
						case Xor:
							{
							alt101 = 1;
							}
							break;
						}

					}


					} finally { DebugExitDecision(101); }
					switch ( alt101 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:279:89: WS lineArg
						{
						DebugLocation(279, 89);
						WS364=(IToken)Match(input,WS,Follow._WS_in_variableDeclare2630); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_WS.Add(WS364);

						DebugLocation(279, 92);
						PushFollow(Follow._lineArg_in_variableDeclare2632);
						lineArg365=lineArg();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_lineArg.Add(lineArg365.Tree);

						}
						break;

					default:
						goto loop101;
					}
				}

				loop101:
					;

				} finally { DebugExitSubRule(101); }


				}
				break;

			}
			} finally { DebugExitSubRule(102); }



			{
			// AST REWRITE
			// elements: Variable, Scope, type, indexer, name, Assign, lineArg
			// token labels: type, name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_type=new RewriteRuleITokenStream(adaptor,"token type",type);
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 280:4: -> ^( Variable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) )
			{
				DebugLocation(280, 7);
				// Grammars\\LavishScript.g:280:7: ^( Variable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(280, 9);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_Variable.NextNode(), root_1);

				DebugLocation(280, 18);
				// Grammars\\LavishScript.g:280:18: ( Scope )?
				if (stream_Scope.HasNext)
				{
					DebugLocation(280, 18);
					adaptor.AddChild(root_1, stream_Scope.NextNode());

				}
				stream_Scope.Reset();
				DebugLocation(280, 26);
				// Grammars\\LavishScript.g:280:26: ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(280, 29);
				root_2 = (CommonTree)adaptor.BecomeRoot(stream_type.NextNode(), root_2);

				DebugLocation(280, 34);
				// Grammars\\LavishScript.g:280:34: ( indexer )?
				if (stream_indexer.HasNext)
				{
					DebugLocation(280, 34);
					adaptor.AddChild(root_2, stream_indexer.NextTree());

				}
				stream_indexer.Reset();
				DebugLocation(280, 43);
				// Grammars\\LavishScript.g:280:43: ^( $name ( ^( Assign ( lineArg )* ) )? )
				{
				CommonTree root_3 = (CommonTree)adaptor.Nil();
				DebugLocation(280, 46);
				root_3 = (CommonTree)adaptor.BecomeRoot(stream_name.NextNode(), root_3);

				DebugLocation(280, 52);
				// Grammars\\LavishScript.g:280:52: ( ^( Assign ( lineArg )* ) )?
				if (stream_Assign.HasNext||stream_lineArg.HasNext)
				{
					DebugLocation(280, 52);
					// Grammars\\LavishScript.g:280:52: ^( Assign ( lineArg )* )
					{
					CommonTree root_4 = (CommonTree)adaptor.Nil();
					DebugLocation(280, 54);
					root_4 = (CommonTree)adaptor.BecomeRoot(stream_Assign.NextNode(), root_4);

					DebugLocation(280, 61);
					// Grammars\\LavishScript.g:280:61: ( lineArg )*
					while ( stream_lineArg.HasNext )
					{
						DebugLocation(280, 61);
						adaptor.AddChild(root_4, stream_lineArg.NextTree());

					}
					stream_lineArg.Reset();

					adaptor.AddChild(root_3, root_4);
					}

				}
				stream_Assign.Reset();
				stream_lineArg.Reset();

				adaptor.AddChild(root_2, root_3);
				}

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclare", 55);
			LeaveRule("variableDeclare", 55);
			LeaveRule_variableDeclare();
		}
		DebugLocation(281, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclare"); }
		return retval;

	}
	// $ANTLR end "variableDeclare"

	partial void EnterRule_codeBlock();
	partial void LeaveRule_codeBlock();
	// $ANTLR start "codeBlock"
	// Grammars\\LavishScript.g:282:8: public codeBlock : LCurly ( expression )+ RCurly -> ^( CodeBlock ( expression )+ ) ;
	[GrammarRule("codeBlock")]
	public AstParserRuleReturnScope<CommonTree, IToken> codeBlock()
	{
		EnterRule_codeBlock();
		EnterRule("codeBlock", 56);
		TraceIn("codeBlock", 56);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCurly366 = default(IToken);
		IToken RCurly368 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression367 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCurly366_tree = default(CommonTree);
		CommonTree RCurly368_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCurly=new RewriteRuleITokenStream(adaptor,"token LCurly");
		RewriteRuleITokenStream stream_RCurly=new RewriteRuleITokenStream(adaptor,"token RCurly");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "codeBlock");
		DebugLocation(282, 1);
		try
		{
			// Grammars\\LavishScript.g:283:2: ( LCurly ( expression )+ RCurly -> ^( CodeBlock ( expression )+ ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:283:4: LCurly ( expression )+ RCurly
			{
			DebugLocation(283, 4);
			LCurly366=(IToken)Match(input,LCurly,Follow._LCurly_in_codeBlock2683); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCurly.Add(LCurly366);

			DebugLocation(284, 3);
			// Grammars\\LavishScript.g:284:3: ( expression )+
			int cnt103=0;
			try { DebugEnterSubRule(103);
			while (true)
			{
				int alt103=2;
				try { DebugEnterDecision(103, false);
				int LA103_1 = input.LA(1);

				if ((LA103_1==NewLine))
				{
					alt103 = 1;
				}


				} finally { DebugExitDecision(103); }
				switch (alt103)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:284:3: expression
					{
					DebugLocation(284, 3);
					PushFollow(Follow._expression_in_codeBlock2687);
					expression367=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression367.Tree);

					}
					break;

				default:
					if (cnt103 >= 1)
						goto loop103;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee103 = new EarlyExitException( 103, input );
					DebugRecognitionException(eee103);
					throw eee103;
				}
				cnt103++;
			}
			loop103:
				;

			} finally { DebugExitSubRule(103); }

			DebugLocation(285, 4);
			RCurly368=(IToken)Match(input,RCurly,Follow._RCurly_in_codeBlock2693); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCurly.Add(RCurly368);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 285:10: -> ^( CodeBlock ( expression )+ )
			{
				DebugLocation(285, 12);
				// Grammars\\LavishScript.g:285:12: ^( CodeBlock ( expression )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(285, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CodeBlock, "CodeBlock"), root_1);

				DebugLocation(285, 24);
				if (!(stream_expression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.HasNext )
				{
					DebugLocation(285, 24);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("codeBlock", 56);
			LeaveRule("codeBlock", 56);
			LeaveRule_codeBlock();
		}
		DebugLocation(286, 1);
		} finally { DebugExitRule(GrammarFileName, "codeBlock"); }
		return retval;

	}
	// $ANTLR end "codeBlock"

	partial void EnterRule_declareVariable();
	partial void LeaveRule_declareVariable();
	// $ANTLR start "declareVariable"
	// Grammars\\LavishScript.g:287:8: public declareVariable : DeclareVariable WS name= ID ( indexer )? WS type= ID WS ( Scope ( WS lineArg )* )? -> ^( DeclareVariable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) ) ;
	[GrammarRule("declareVariable")]
	public AstParserRuleReturnScope<CommonTree, IToken> declareVariable()
	{
		EnterRule_declareVariable();
		EnterRule("declareVariable", 57);
		TraceIn("declareVariable", 57);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken name = default(IToken);
		IToken type = default(IToken);
		IToken DeclareVariable369 = default(IToken);
		IToken WS370 = default(IToken);
		IToken WS372 = default(IToken);
		IToken WS373 = default(IToken);
		IToken Scope374 = default(IToken);
		IToken WS375 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> indexer371 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> lineArg376 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree name_tree = default(CommonTree);
		CommonTree type_tree = default(CommonTree);
		CommonTree DeclareVariable369_tree = default(CommonTree);
		CommonTree WS370_tree = default(CommonTree);
		CommonTree WS372_tree = default(CommonTree);
		CommonTree WS373_tree = default(CommonTree);
		CommonTree Scope374_tree = default(CommonTree);
		CommonTree WS375_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DeclareVariable=new RewriteRuleITokenStream(adaptor,"token DeclareVariable");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_Scope=new RewriteRuleITokenStream(adaptor,"token Scope");
		RewriteRuleSubtreeStream stream_indexer=new RewriteRuleSubtreeStream(adaptor,"rule indexer");
		RewriteRuleSubtreeStream stream_lineArg=new RewriteRuleSubtreeStream(adaptor,"rule lineArg");
		try { DebugEnterRule(GrammarFileName, "declareVariable");
		DebugLocation(287, 1);
		try
		{
			// Grammars\\LavishScript.g:288:2: ( DeclareVariable WS name= ID ( indexer )? WS type= ID WS ( Scope ( WS lineArg )* )? -> ^( DeclareVariable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:288:4: DeclareVariable WS name= ID ( indexer )? WS type= ID WS ( Scope ( WS lineArg )* )?
			{
			DebugLocation(288, 4);
			DeclareVariable369=(IToken)Match(input,DeclareVariable,Follow._DeclareVariable_in_declareVariable2712); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DeclareVariable.Add(DeclareVariable369);

			DebugLocation(288, 20);
			WS370=(IToken)Match(input,WS,Follow._WS_in_declareVariable2714); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS370);

			DebugLocation(288, 27);
			name=(IToken)Match(input,ID,Follow._ID_in_declareVariable2718); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(288, 31);
			// Grammars\\LavishScript.g:288:31: ( indexer )?
			int alt104=2;
			try { DebugEnterSubRule(104);
			try { DebugEnterDecision(104, false);
			int LA104_1 = input.LA(1);

			if ((LA104_1==LSquare))
			{
				alt104 = 1;
			}
			} finally { DebugExitDecision(104); }
			switch (alt104)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:288:31: indexer
				{
				DebugLocation(288, 31);
				PushFollow(Follow._indexer_in_declareVariable2720);
				indexer371=indexer();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_indexer.Add(indexer371.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(104); }

			DebugLocation(288, 40);
			WS372=(IToken)Match(input,WS,Follow._WS_in_declareVariable2723); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS372);

			DebugLocation(288, 47);
			type=(IToken)Match(input,ID,Follow._ID_in_declareVariable2727); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(type);

			DebugLocation(288, 51);
			WS373=(IToken)Match(input,WS,Follow._WS_in_declareVariable2729); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WS.Add(WS373);

			DebugLocation(288, 53);
			// Grammars\\LavishScript.g:288:53: ( Scope ( WS lineArg )* )?
			int alt106=2;
			try { DebugEnterSubRule(106);
			try { DebugEnterDecision(106, false);
			int LA106_1 = input.LA(1);

			if ((LA106_1==Scope))
			{
				alt106 = 1;
			}
			} finally { DebugExitDecision(106); }
			switch (alt106)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:288:54: Scope ( WS lineArg )*
				{
				DebugLocation(288, 54);
				Scope374=(IToken)Match(input,Scope,Follow._Scope_in_declareVariable2731); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Scope.Add(Scope374);

				DebugLocation(288, 60);
				// Grammars\\LavishScript.g:288:60: ( WS lineArg )*
				try { DebugEnterSubRule(105);
				while (true)
				{
					int alt105=2;
					try { DebugEnterDecision(105, false);
					int LA105_1 = input.LA(1);

					if ((LA105_1==WS))
					{
						switch (input.LA(2))
						{
						case EndMac:
							{
							alt105 = 1;
							}
							break;
						case WS:
							{
							alt105 = 1;
							}
							break;
						case ARG:
						case And:
						case Assign:
						case Atom:
						case Band:
						case Bnegate:
						case Bor:
						case COMMAND:
						case COMMENT:
						case CONDITION:
						case Case:
						case CodeBlock:
						case Colon:
						case Comma:
						case Comparer:
						case DataCommand:
						case DeclareVariable:
						case Default:
						case Define:
						case Div:
						case Do:
						case Dollar:
						case Dot:
						case ESC_SEQ:
						case EXPONENT:
						case Echo:
						case Elipse:
						case Else:
						case ElseIf:
						case EndIf:
						case EqualTo:
						case Error:
						case FLOAT:
						case For:
						case Function:
						case GreaterThan:
						case GreaterThanEqual:
						case HEX_DIGIT:
						case ID:
						case INT:
						case If:
						case IfDef:
						case IfNDef:
						case Include:
						case Inherits:
						case LCurly:
						case LParen:
						case LSquare:
						case LeftShift:
						case LessThan:
						case LessThanEqual:
						case MATH:
						case Macro:
						case Member:
						case Method:
						case Minus:
						case Modu:
						case Mult:
						case Negate:
						case NotEqualTo:
						case OCTAL_ESC:
						case ObjectDef:
						case Or:
						case Other:
						case Param:
						case Params:
						case Plus:
						case PreElse:
						case PreElseIf:
						case PreIf:
						case Quote:
						case RCurly:
						case RParen:
						case RSquare:
						case Returns:
						case RightShift:
						case STRING:
						case Scope:
						case Script:
						case Semi:
						case Switch:
						case Type:
						case UNICODE_ESC:
						case Unmac:
						case Variable:
						case VariableCase:
						case While:
						case Xor:
							{
							alt105 = 1;
							}
							break;
						}

					}


					} finally { DebugExitDecision(105); }
					switch ( alt105 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:288:61: WS lineArg
						{
						DebugLocation(288, 61);
						WS375=(IToken)Match(input,WS,Follow._WS_in_declareVariable2734); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_WS.Add(WS375);

						DebugLocation(288, 64);
						PushFollow(Follow._lineArg_in_declareVariable2736);
						lineArg376=lineArg();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_lineArg.Add(lineArg376.Tree);

						}
						break;

					default:
						goto loop105;
					}
				}

				loop105:
					;

				} finally { DebugExitSubRule(105); }


				}
				break;

			}
			} finally { DebugExitSubRule(106); }



			{
			// AST REWRITE
			// elements: DeclareVariable, Scope, type, indexer, name, lineArg
			// token labels: type, name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_type=new RewriteRuleITokenStream(adaptor,"token type",type);
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 289:4: -> ^( DeclareVariable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) )
			{
				DebugLocation(289, 7);
				// Grammars\\LavishScript.g:289:7: ^( DeclareVariable ( Scope )? ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) ) )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(289, 9);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_DeclareVariable.NextNode(), root_1);

				DebugLocation(289, 25);
				// Grammars\\LavishScript.g:289:25: ( Scope )?
				if (stream_Scope.HasNext)
				{
					DebugLocation(289, 25);
					adaptor.AddChild(root_1, stream_Scope.NextNode());

				}
				stream_Scope.Reset();
				DebugLocation(289, 33);
				// Grammars\\LavishScript.g:289:33: ^( $type ( indexer )? ^( $name ( ^( Assign ( lineArg )* ) )? ) )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(289, 36);
				root_2 = (CommonTree)adaptor.BecomeRoot(stream_type.NextNode(), root_2);

				DebugLocation(289, 41);
				// Grammars\\LavishScript.g:289:41: ( indexer )?
				if (stream_indexer.HasNext)
				{
					DebugLocation(289, 41);
					adaptor.AddChild(root_2, stream_indexer.NextTree());

				}
				stream_indexer.Reset();
				DebugLocation(289, 50);
				// Grammars\\LavishScript.g:289:50: ^( $name ( ^( Assign ( lineArg )* ) )? )
				{
				CommonTree root_3 = (CommonTree)adaptor.Nil();
				DebugLocation(289, 53);
				root_3 = (CommonTree)adaptor.BecomeRoot(stream_name.NextNode(), root_3);

				DebugLocation(289, 59);
				// Grammars\\LavishScript.g:289:59: ( ^( Assign ( lineArg )* ) )?
				if (stream_lineArg.HasNext)
				{
					DebugLocation(289, 59);
					// Grammars\\LavishScript.g:289:59: ^( Assign ( lineArg )* )
					{
					CommonTree root_4 = (CommonTree)adaptor.Nil();
					DebugLocation(289, 61);
					root_4 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Assign, "Assign"), root_4);

					DebugLocation(289, 68);
					// Grammars\\LavishScript.g:289:68: ( lineArg )*
					while ( stream_lineArg.HasNext )
					{
						DebugLocation(289, 68);
						adaptor.AddChild(root_4, stream_lineArg.NextTree());

					}
					stream_lineArg.Reset();

					adaptor.AddChild(root_3, root_4);
					}

				}
				stream_lineArg.Reset();

				adaptor.AddChild(root_2, root_3);
				}

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declareVariable", 57);
			LeaveRule("declareVariable", 57);
			LeaveRule_declareVariable();
		}
		DebugLocation(290, 1);
		} finally { DebugExitRule(GrammarFileName, "declareVariable"); }
		return retval;

	}
	// $ANTLR end "declareVariable"

	partial void EnterRule_value();
	partial void LeaveRule_value();
	// $ANTLR start "value"
	// Grammars\\LavishScript.g:291:8: public value : ( ID | dataSequence | string | INT | FLOAT );
	[GrammarRule("value")]
	public AstParserRuleReturnScope<CommonTree, IToken> value()
	{
		EnterRule_value();
		EnterRule("value", 58);
		TraceIn("value", 58);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ID377 = default(IToken);
		IToken INT380 = default(IToken);
		IToken FLOAT381 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> dataSequence378 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> string379 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ID377_tree = default(CommonTree);
		CommonTree INT380_tree = default(CommonTree);
		CommonTree FLOAT381_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(291, 1);
		try
		{
			// Grammars\\LavishScript.g:291:14: ( ID | dataSequence | string | INT | FLOAT )
			int alt107=5;
			try { DebugEnterDecision(107, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt107 = 1;
				}
				break;
			case Dollar:
				{
				alt107 = 2;
				}
				break;
			case Quote:
				{
				alt107 = 3;
				}
				break;
			case INT:
				{
				alt107 = 4;
				}
				break;
			case FLOAT:
				{
				alt107 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 107, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(107); }
			switch (alt107)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:291:16: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(291, 16);
				ID377=(IToken)Match(input,ID,Follow._ID_in_value2786); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID377_tree = (CommonTree)adaptor.Create(ID377);
				adaptor.AddChild(root_0, ID377_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishScript.g:291:19: dataSequence
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(291, 19);
				PushFollow(Follow._dataSequence_in_value2788);
				dataSequence378=dataSequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, dataSequence378.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishScript.g:291:32: string
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(291, 32);
				PushFollow(Follow._string_in_value2790);
				string379=@string();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, string379.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishScript.g:291:39: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(291, 39);
				INT380=(IToken)Match(input,INT,Follow._INT_in_value2792); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT380_tree = (CommonTree)adaptor.Create(INT380);
				adaptor.AddChild(root_0, INT380_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishScript.g:291:43: FLOAT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(291, 43);
				FLOAT381=(IToken)Match(input,FLOAT,Follow._FLOAT_in_value2794); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FLOAT381_tree = (CommonTree)adaptor.Create(FLOAT381);
				adaptor.AddChild(root_0, FLOAT381_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value", 58);
			LeaveRule("value", 58);
			LeaveRule_value();
		}
		DebugLocation(292, 1);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return retval;

	}
	// $ANTLR end "value"

	partial void EnterRule_accessor();
	partial void LeaveRule_accessor();
	// $ANTLR start "accessor"
	// Grammars\\LavishScript.g:293:8: public accessor : id ( indexer | typeCast )* ;
	[GrammarRule("accessor")]
	public AstParserRuleReturnScope<CommonTree, IToken> accessor()
	{
		EnterRule_accessor();
		EnterRule("accessor", 59);
		TraceIn("accessor", 59);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> id382 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> indexer383 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeCast384 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "accessor");
		DebugLocation(293, 1);
		try
		{
			// Grammars\\LavishScript.g:293:16: ( id ( indexer | typeCast )* )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:293:18: id ( indexer | typeCast )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(293, 18);
			PushFollow(Follow._id_in_accessor2804);
			id382=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id382.Tree);
			DebugLocation(293, 21);
			// Grammars\\LavishScript.g:293:21: ( indexer | typeCast )*
			try { DebugEnterSubRule(108);
			while (true)
			{
				int alt108=3;
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==LSquare))
				{
					alt108 = 1;
				}
				else if ((LA108_1==LParen))
				{
					alt108 = 2;
				}


				} finally { DebugExitDecision(108); }
				switch ( alt108 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:293:22: indexer
					{
					DebugLocation(293, 22);
					PushFollow(Follow._indexer_in_accessor2807);
					indexer383=indexer();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, indexer383.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishScript.g:293:30: typeCast
					{
					DebugLocation(293, 30);
					PushFollow(Follow._typeCast_in_accessor2809);
					typeCast384=typeCast();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, typeCast384.Tree);

					}
					break;

				default:
					goto loop108;
				}
			}

			loop108:
				;

			} finally { DebugExitSubRule(108); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("accessor", 59);
			LeaveRule("accessor", 59);
			LeaveRule_accessor();
		}
		DebugLocation(294, 1);
		} finally { DebugExitRule(GrammarFileName, "accessor"); }
		return retval;

	}
	// $ANTLR end "accessor"

	partial void EnterRule_indexer();
	partial void LeaveRule_indexer();
	// $ANTLR start "indexer"
	// Grammars\\LavishScript.g:295:8: public indexer : LSquare ( commaValue ( Comma commaValue )* )? RSquare -> ^( LSquare ( commaValue )* ) ;
	[GrammarRule("indexer")]
	public AstParserRuleReturnScope<CommonTree, IToken> indexer()
	{
		EnterRule_indexer();
		EnterRule("indexer", 60);
		TraceIn("indexer", 60);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LSquare385 = default(IToken);
		IToken Comma387 = default(IToken);
		IToken RSquare389 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> commaValue386 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> commaValue388 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LSquare385_tree = default(CommonTree);
		CommonTree Comma387_tree = default(CommonTree);
		CommonTree RSquare389_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LSquare=new RewriteRuleITokenStream(adaptor,"token LSquare");
		RewriteRuleITokenStream stream_Comma=new RewriteRuleITokenStream(adaptor,"token Comma");
		RewriteRuleITokenStream stream_RSquare=new RewriteRuleITokenStream(adaptor,"token RSquare");
		RewriteRuleSubtreeStream stream_commaValue=new RewriteRuleSubtreeStream(adaptor,"rule commaValue");
		try { DebugEnterRule(GrammarFileName, "indexer");
		DebugLocation(295, 1);
		try
		{
			// Grammars\\LavishScript.g:295:16: ( LSquare ( commaValue ( Comma commaValue )* )? RSquare -> ^( LSquare ( commaValue )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:295:18: LSquare ( commaValue ( Comma commaValue )* )? RSquare
			{
			DebugLocation(295, 18);
			LSquare385=(IToken)Match(input,LSquare,Follow._LSquare_in_indexer2822); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LSquare.Add(LSquare385);

			DebugLocation(295, 26);
			// Grammars\\LavishScript.g:295:26: ( commaValue ( Comma commaValue )* )?
			int alt110=2;
			try { DebugEnterSubRule(110);
			try { DebugEnterDecision(110, false);
			int LA110_1 = input.LA(1);

			if (((LA110_1>=ARG && LA110_1<=Colon)||(LA110_1>=Comparer && LA110_1<=RParen)||(LA110_1>=Returns && LA110_1<=Xor)))
			{
				alt110 = 1;
			}
			} finally { DebugExitDecision(110); }
			switch (alt110)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishScript.g:295:27: commaValue ( Comma commaValue )*
				{
				DebugLocation(295, 27);
				PushFollow(Follow._commaValue_in_indexer2825);
				commaValue386=commaValue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_commaValue.Add(commaValue386.Tree);
				DebugLocation(295, 38);
				// Grammars\\LavishScript.g:295:38: ( Comma commaValue )*
				try { DebugEnterSubRule(109);
				while (true)
				{
					int alt109=2;
					try { DebugEnterDecision(109, false);
					int LA109_1 = input.LA(1);

					if ((LA109_1==Comma))
					{
						alt109 = 1;
					}


					} finally { DebugExitDecision(109); }
					switch ( alt109 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishScript.g:295:39: Comma commaValue
						{
						DebugLocation(295, 39);
						Comma387=(IToken)Match(input,Comma,Follow._Comma_in_indexer2828); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_Comma.Add(Comma387);

						DebugLocation(295, 45);
						PushFollow(Follow._commaValue_in_indexer2830);
						commaValue388=commaValue();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_commaValue.Add(commaValue388.Tree);

						}
						break;

					default:
						goto loop109;
					}
				}

				loop109:
					;

				} finally { DebugExitSubRule(109); }


				}
				break;

			}
			} finally { DebugExitSubRule(110); }

			DebugLocation(295, 60);
			RSquare389=(IToken)Match(input,RSquare,Follow._RSquare_in_indexer2836); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RSquare.Add(RSquare389);



			{
			// AST REWRITE
			// elements: LSquare, commaValue
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 295:67: -> ^( LSquare ( commaValue )* )
			{
				DebugLocation(295, 69);
				// Grammars\\LavishScript.g:295:69: ^( LSquare ( commaValue )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(295, 71);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_LSquare.NextNode(), root_1);

				DebugLocation(295, 79);
				// Grammars\\LavishScript.g:295:79: ( commaValue )*
				while ( stream_commaValue.HasNext )
				{
					DebugLocation(295, 79);
					adaptor.AddChild(root_1, stream_commaValue.NextTree());

				}
				stream_commaValue.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indexer", 60);
			LeaveRule("indexer", 60);
			LeaveRule_indexer();
		}
		DebugLocation(296, 1);
		} finally { DebugExitRule(GrammarFileName, "indexer"); }
		return retval;

	}
	// $ANTLR end "indexer"

	partial void EnterRule_commaValue();
	partial void LeaveRule_commaValue();
	// $ANTLR start "commaValue"
	// Grammars\\LavishScript.g:297:8: public commaValue : ( commaArg )+ -> ^( ARG ( commaArg )+ ) ;
	[GrammarRule("commaValue")]
	public AstParserRuleReturnScope<CommonTree, IToken> commaValue()
	{
		EnterRule_commaValue();
		EnterRule("commaValue", 61);
		TraceIn("commaValue", 61);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> commaArg390 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_commaArg=new RewriteRuleSubtreeStream(adaptor,"rule commaArg");
		try { DebugEnterRule(GrammarFileName, "commaValue");
		DebugLocation(297, 1);
		try
		{
			// Grammars\\LavishScript.g:298:2: ( ( commaArg )+ -> ^( ARG ( commaArg )+ ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:298:4: ( commaArg )+
			{
			DebugLocation(298, 4);
			// Grammars\\LavishScript.g:298:4: ( commaArg )+
			int cnt111=0;
			try { DebugEnterSubRule(111);
			while (true)
			{
				int alt111=2;
				try { DebugEnterDecision(111, false);
				int LA111_1 = input.LA(1);

				if (((LA111_1>=ARG && LA111_1<=Colon)||(LA111_1>=Comparer && LA111_1<=RParen)||(LA111_1>=Returns && LA111_1<=Xor)))
				{
					alt111 = 1;
				}


				} finally { DebugExitDecision(111); }
				switch (alt111)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishScript.g:298:4: commaArg
					{
					DebugLocation(298, 4);
					PushFollow(Follow._commaArg_in_commaValue2855);
					commaArg390=commaArg();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_commaArg.Add(commaArg390.Tree);

					}
					break;

				default:
					if (cnt111 >= 1)
						goto loop111;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee111 = new EarlyExitException( 111, input );
					DebugRecognitionException(eee111);
					throw eee111;
				}
				cnt111++;
			}
			loop111:
				;

			} finally { DebugExitSubRule(111); }



			{
			// AST REWRITE
			// elements: commaArg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 298:13: -> ^( ARG ( commaArg )+ )
			{
				DebugLocation(298, 15);
				// Grammars\\LavishScript.g:298:15: ^( ARG ( commaArg )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(298, 17);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(298, 21);
				if (!(stream_commaArg.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_commaArg.HasNext )
				{
					DebugLocation(298, 21);
					adaptor.AddChild(root_1, stream_commaArg.NextTree());

				}
				stream_commaArg.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("commaValue", 61);
			LeaveRule("commaValue", 61);
			LeaveRule_commaValue();
		}
		DebugLocation(299, 1);
		} finally { DebugExitRule(GrammarFileName, "commaValue"); }
		return retval;

	}
	// $ANTLR end "commaValue"

	partial void EnterRule_typeCast();
	partial void LeaveRule_typeCast();
	// $ANTLR start "typeCast"
	// Grammars\\LavishScript.g:300:8: public typeCast : LParen id RParen -> ^( LParen id ) ;
	[GrammarRule("typeCast")]
	public AstParserRuleReturnScope<CommonTree, IToken> typeCast()
	{
		EnterRule_typeCast();
		EnterRule("typeCast", 62);
		TraceIn("typeCast", 62);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LParen391 = default(IToken);
		IToken RParen393 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> id392 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LParen391_tree = default(CommonTree);
		CommonTree RParen393_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LParen=new RewriteRuleITokenStream(adaptor,"token LParen");
		RewriteRuleITokenStream stream_RParen=new RewriteRuleITokenStream(adaptor,"token RParen");
		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
		try { DebugEnterRule(GrammarFileName, "typeCast");
		DebugLocation(300, 1);
		try
		{
			// Grammars\\LavishScript.g:300:16: ( LParen id RParen -> ^( LParen id ) )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:300:18: LParen id RParen
			{
			DebugLocation(300, 18);
			LParen391=(IToken)Match(input,LParen,Follow._LParen_in_typeCast2873); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LParen.Add(LParen391);

			DebugLocation(300, 25);
			PushFollow(Follow._id_in_typeCast2875);
			id392=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_id.Add(id392.Tree);
			DebugLocation(300, 28);
			RParen393=(IToken)Match(input,RParen,Follow._RParen_in_typeCast2877); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RParen.Add(RParen393);



			{
			// AST REWRITE
			// elements: LParen, id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 300:35: -> ^( LParen id )
			{
				DebugLocation(300, 38);
				// Grammars\\LavishScript.g:300:38: ^( LParen id )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(300, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_LParen.NextNode(), root_1);

				DebugLocation(300, 47);
				adaptor.AddChild(root_1, stream_id.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeCast", 62);
			LeaveRule("typeCast", 62);
			LeaveRule_typeCast();
		}
		DebugLocation(301, 1);
		} finally { DebugExitRule(GrammarFileName, "typeCast"); }
		return retval;

	}
	// $ANTLR end "typeCast"

	partial void EnterRule_synpred1_LavishScript_fragment();
	partial void LeaveRule_synpred1_LavishScript_fragment();

	// $ANTLR start synpred1_LavishScript
	public void synpred1_LavishScript_fragment()
	{
		EnterRule_synpred1_LavishScript_fragment();
		EnterRule("synpred1_LavishScript_fragment", 63);
		TraceIn("synpred1_LavishScript_fragment", 63);
		try
		{
			// Grammars\\LavishScript.g:16:4: ( include )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:16:5: include
			{
			DebugLocation(16, 5);
			PushFollow(Follow._include_in_synpred1_LavishScript93);
			include();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_LavishScript_fragment", 63);
			LeaveRule("synpred1_LavishScript_fragment", 63);
			LeaveRule_synpred1_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred1_LavishScript

	partial void EnterRule_synpred2_LavishScript_fragment();
	partial void LeaveRule_synpred2_LavishScript_fragment();

	// $ANTLR start synpred2_LavishScript
	public void synpred2_LavishScript_fragment()
	{
		EnterRule_synpred2_LavishScript_fragment();
		EnterRule("synpred2_LavishScript_fragment", 64);
		TraceIn("synpred2_LavishScript_fragment", 64);
		try
		{
			// Grammars\\LavishScript.g:29:6: ( dataSequence )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:29:7: dataSequence
			{
			DebugLocation(29, 7);
			PushFollow(Follow._dataSequence_in_synpred2_LavishScript200);
			dataSequence();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_LavishScript_fragment", 64);
			LeaveRule("synpred2_LavishScript_fragment", 64);
			LeaveRule_synpred2_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred2_LavishScript

	partial void EnterRule_synpred3_LavishScript_fragment();
	partial void LeaveRule_synpred3_LavishScript_fragment();

	// $ANTLR start synpred3_LavishScript
	public void synpred3_LavishScript_fragment()
	{
		EnterRule_synpred3_LavishScript_fragment();
		EnterRule("synpred3_LavishScript_fragment", 65);
		TraceIn("synpred3_LavishScript_fragment", 65);
		try
		{
			// Grammars\\LavishScript.g:30:6: ( command )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:30:7: command
			{
			DebugLocation(30, 7);
			PushFollow(Follow._command_in_synpred3_LavishScript211);
			command();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_LavishScript_fragment", 65);
			LeaveRule("synpred3_LavishScript_fragment", 65);
			LeaveRule_synpred3_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred3_LavishScript

	partial void EnterRule_synpred4_LavishScript_fragment();
	partial void LeaveRule_synpred4_LavishScript_fragment();

	// $ANTLR start synpred4_LavishScript
	public void synpred4_LavishScript_fragment()
	{
		EnterRule_synpred4_LavishScript_fragment();
		EnterRule("synpred4_LavishScript_fragment", 66);
		TraceIn("synpred4_LavishScript_fragment", 66);
		try
		{
			// Grammars\\LavishScript.g:79:10: ( dataSequence )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:79:11: dataSequence
			{
			DebugLocation(79, 11);
			PushFollow(Follow._dataSequence_in_synpred4_LavishScript606);
			dataSequence();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_LavishScript_fragment", 66);
			LeaveRule("synpred4_LavishScript_fragment", 66);
			LeaveRule_synpred4_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred4_LavishScript

	partial void EnterRule_synpred5_LavishScript_fragment();
	partial void LeaveRule_synpred5_LavishScript_fragment();

	// $ANTLR start synpred5_LavishScript
	public void synpred5_LavishScript_fragment()
	{
		EnterRule_synpred5_LavishScript_fragment();
		EnterRule("synpred5_LavishScript_fragment", 67);
		TraceIn("synpred5_LavishScript_fragment", 67);
		try
		{
			// Grammars\\LavishScript.g:141:4: ( dataCommand )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:141:5: dataCommand
			{
			DebugLocation(141, 5);
			PushFollow(Follow._dataCommand_in_synpred5_LavishScript1245);
			dataCommand();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_LavishScript_fragment", 67);
			LeaveRule("synpred5_LavishScript_fragment", 67);
			LeaveRule_synpred5_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred5_LavishScript

	partial void EnterRule_synpred6_LavishScript_fragment();
	partial void LeaveRule_synpred6_LavishScript_fragment();

	// $ANTLR start synpred6_LavishScript
	public void synpred6_LavishScript_fragment()
	{
		EnterRule_synpred6_LavishScript_fragment();
		EnterRule("synpred6_LavishScript_fragment", 68);
		TraceIn("synpred6_LavishScript_fragment", 68);
		try
		{
			// Grammars\\LavishScript.g:142:4: ( ID )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:142:5: ID
			{
			DebugLocation(142, 5);
			Match(input,ID,Follow._ID_in_synpred6_LavishScript1269); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_LavishScript_fragment", 68);
			LeaveRule("synpred6_LavishScript_fragment", 68);
			LeaveRule_synpred6_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred6_LavishScript

	partial void EnterRule_synpred7_LavishScript_fragment();
	partial void LeaveRule_synpred7_LavishScript_fragment();

	// $ANTLR start synpred7_LavishScript
	public void synpred7_LavishScript_fragment()
	{
		EnterRule_synpred7_LavishScript_fragment();
		EnterRule("synpred7_LavishScript_fragment", 69);
		TraceIn("synpred7_LavishScript_fragment", 69);
		try
		{
			// Grammars\\LavishScript.g:143:4: ( dataSequence WS )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:143:5: dataSequence WS
			{
			DebugLocation(143, 5);
			PushFollow(Follow._dataSequence_in_synpred7_LavishScript1308);
			dataSequence();
			PopFollow();
			if (state.failed) return;
			DebugLocation(143, 18);
			Match(input,WS,Follow._WS_in_synpred7_LavishScript1310); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_LavishScript_fragment", 69);
			LeaveRule("synpred7_LavishScript_fragment", 69);
			LeaveRule_synpred7_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred7_LavishScript

	partial void EnterRule_synpred8_LavishScript_fragment();
	partial void LeaveRule_synpred8_LavishScript_fragment();

	// $ANTLR start synpred8_LavishScript
	public void synpred8_LavishScript_fragment()
	{
		EnterRule_synpred8_LavishScript_fragment();
		EnterRule("synpred8_LavishScript_fragment", 70);
		TraceIn("synpred8_LavishScript_fragment", 70);
		try
		{
			// Grammars\\LavishScript.g:175:4: ( NewLine ElseIf )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:175:5: NewLine ElseIf
			{
			DebugLocation(175, 5);
			Match(input,NewLine,Follow._NewLine_in_synpred8_LavishScript1597); if (state.failed) return;
			DebugLocation(175, 13);
			Match(input,ElseIf,Follow._ElseIf_in_synpred8_LavishScript1599); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_LavishScript_fragment", 70);
			LeaveRule("synpred8_LavishScript_fragment", 70);
			LeaveRule_synpred8_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred8_LavishScript

	partial void EnterRule_synpred9_LavishScript_fragment();
	partial void LeaveRule_synpred9_LavishScript_fragment();

	// $ANTLR start synpred9_LavishScript
	public void synpred9_LavishScript_fragment()
	{
		EnterRule_synpred9_LavishScript_fragment();
		EnterRule("synpred9_LavishScript_fragment", 71);
		TraceIn("synpred9_LavishScript_fragment", 71);
		try
		{
			// Grammars\\LavishScript.g:176:4: ( NewLine Else )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:176:5: NewLine Else
			{
			DebugLocation(176, 5);
			Match(input,NewLine,Follow._NewLine_in_synpred9_LavishScript1622); if (state.failed) return;
			DebugLocation(176, 13);
			Match(input,Else,Follow._Else_in_synpred9_LavishScript1624); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_LavishScript_fragment", 71);
			LeaveRule("synpred9_LavishScript_fragment", 71);
			LeaveRule_synpred9_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred9_LavishScript

	partial void EnterRule_synpred10_LavishScript_fragment();
	partial void LeaveRule_synpred10_LavishScript_fragment();

	// $ANTLR start synpred10_LavishScript
	public void synpred10_LavishScript_fragment()
	{
		EnterRule_synpred10_LavishScript_fragment();
		EnterRule("synpred10_LavishScript_fragment", 72);
		TraceIn("synpred10_LavishScript_fragment", 72);
		try
		{
			// Grammars\\LavishScript.g:186:4: ( For ws LParen ws command ws Semi ws condition ws Semi ws command RParen )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:186:5: For ws LParen ws command ws Semi ws condition ws Semi ws command RParen
			{
			DebugLocation(186, 5);
			Match(input,For,Follow._For_in_synpred10_LavishScript1735); if (state.failed) return;
			DebugLocation(186, 9);
			PushFollow(Follow._ws_in_synpred10_LavishScript1737);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 12);
			Match(input,LParen,Follow._LParen_in_synpred10_LavishScript1739); if (state.failed) return;
			DebugLocation(186, 19);
			PushFollow(Follow._ws_in_synpred10_LavishScript1741);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 22);
			PushFollow(Follow._command_in_synpred10_LavishScript1743);
			command();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 30);
			PushFollow(Follow._ws_in_synpred10_LavishScript1745);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 33);
			Match(input,Semi,Follow._Semi_in_synpred10_LavishScript1747); if (state.failed) return;
			DebugLocation(186, 38);
			PushFollow(Follow._ws_in_synpred10_LavishScript1749);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 41);
			PushFollow(Follow._condition_in_synpred10_LavishScript1751);
			condition();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 51);
			PushFollow(Follow._ws_in_synpred10_LavishScript1753);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 54);
			Match(input,Semi,Follow._Semi_in_synpred10_LavishScript1755); if (state.failed) return;
			DebugLocation(186, 59);
			PushFollow(Follow._ws_in_synpred10_LavishScript1757);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 62);
			PushFollow(Follow._command_in_synpred10_LavishScript1759);
			command();
			PopFollow();
			if (state.failed) return;
			DebugLocation(186, 70);
			Match(input,RParen,Follow._RParen_in_synpred10_LavishScript1761); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_LavishScript_fragment", 72);
			LeaveRule("synpred10_LavishScript_fragment", 72);
			LeaveRule_synpred10_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred10_LavishScript

	partial void EnterRule_synpred11_LavishScript_fragment();
	partial void LeaveRule_synpred11_LavishScript_fragment();

	// $ANTLR start synpred11_LavishScript
	public void synpred11_LavishScript_fragment()
	{
		EnterRule_synpred11_LavishScript_fragment();
		EnterRule("synpred11_LavishScript_fragment", 73);
		TraceIn("synpred11_LavishScript_fragment", 73);
		try
		{
			// Grammars\\LavishScript.g:188:4: ( For ws LParen ws condition ws Semi ws command ws RParen )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:188:5: For ws LParen ws condition ws Semi ws command ws RParen
			{
			DebugLocation(188, 5);
			Match(input,For,Follow._For_in_synpred11_LavishScript1818); if (state.failed) return;
			DebugLocation(188, 9);
			PushFollow(Follow._ws_in_synpred11_LavishScript1820);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 12);
			Match(input,LParen,Follow._LParen_in_synpred11_LavishScript1822); if (state.failed) return;
			DebugLocation(188, 19);
			PushFollow(Follow._ws_in_synpred11_LavishScript1824);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 22);
			PushFollow(Follow._condition_in_synpred11_LavishScript1826);
			condition();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 32);
			PushFollow(Follow._ws_in_synpred11_LavishScript1828);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 35);
			Match(input,Semi,Follow._Semi_in_synpred11_LavishScript1830); if (state.failed) return;
			DebugLocation(188, 40);
			PushFollow(Follow._ws_in_synpred11_LavishScript1832);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 43);
			PushFollow(Follow._command_in_synpred11_LavishScript1834);
			command();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 51);
			PushFollow(Follow._ws_in_synpred11_LavishScript1836);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(188, 54);
			Match(input,RParen,Follow._RParen_in_synpred11_LavishScript1838); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_LavishScript_fragment", 73);
			LeaveRule("synpred11_LavishScript_fragment", 73);
			LeaveRule_synpred11_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred11_LavishScript

	partial void EnterRule_synpred12_LavishScript_fragment();
	partial void LeaveRule_synpred12_LavishScript_fragment();

	// $ANTLR start synpred12_LavishScript
	public void synpred12_LavishScript_fragment()
	{
		EnterRule_synpred12_LavishScript_fragment();
		EnterRule("synpred12_LavishScript_fragment", 74);
		TraceIn("synpred12_LavishScript_fragment", 74);
		try
		{
			// Grammars\\LavishScript.g:199:5: ( math )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:199:6: math
			{
			DebugLocation(199, 6);
			PushFollow(Follow._math_in_synpred12_LavishScript1975);
			math();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred12_LavishScript_fragment", 74);
			LeaveRule("synpred12_LavishScript_fragment", 74);
			LeaveRule_synpred12_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred12_LavishScript

	partial void EnterRule_synpred13_LavishScript_fragment();
	partial void LeaveRule_synpred13_LavishScript_fragment();

	// $ANTLR start synpred13_LavishScript
	public void synpred13_LavishScript_fragment()
	{
		EnterRule_synpred13_LavishScript_fragment();
		EnterRule("synpred13_LavishScript_fragment", 75);
		TraceIn("synpred13_LavishScript_fragment", 75);
		try
		{
			// Grammars\\LavishScript.g:206:5: ( math )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:206:6: math
			{
			DebugLocation(206, 6);
			PushFollow(Follow._math_in_synpred13_LavishScript2029);
			math();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_LavishScript_fragment", 75);
			LeaveRule("synpred13_LavishScript_fragment", 75);
			LeaveRule_synpred13_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred13_LavishScript

	partial void EnterRule_synpred14_LavishScript_fragment();
	partial void LeaveRule_synpred14_LavishScript_fragment();

	// $ANTLR start synpred14_LavishScript
	public void synpred14_LavishScript_fragment()
	{
		EnterRule_synpred14_LavishScript_fragment();
		EnterRule("synpred14_LavishScript_fragment", 76);
		TraceIn("synpred14_LavishScript_fragment", 76);
		try
		{
			// Grammars\\LavishScript.g:244:4: ( math )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:244:5: math
			{
			DebugLocation(244, 5);
			PushFollow(Follow._math_in_synpred14_LavishScript2292);
			math();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred14_LavishScript_fragment", 76);
			LeaveRule("synpred14_LavishScript_fragment", 76);
			LeaveRule_synpred14_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred14_LavishScript

	partial void EnterRule_synpred15_LavishScript_fragment();
	partial void LeaveRule_synpred15_LavishScript_fragment();

	// $ANTLR start synpred15_LavishScript
	public void synpred15_LavishScript_fragment()
	{
		EnterRule_synpred15_LavishScript_fragment();
		EnterRule("synpred15_LavishScript_fragment", 77);
		TraceIn("synpred15_LavishScript_fragment", 77);
		try
		{
			// Grammars\\LavishScript.g:250:4: ( math )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:250:5: math
			{
			DebugLocation(250, 5);
			PushFollow(Follow._math_in_synpred15_LavishScript2326);
			math();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred15_LavishScript_fragment", 77);
			LeaveRule("synpred15_LavishScript_fragment", 77);
			LeaveRule_synpred15_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred15_LavishScript

	partial void EnterRule_synpred16_LavishScript_fragment();
	partial void LeaveRule_synpred16_LavishScript_fragment();

	// $ANTLR start synpred16_LavishScript
	public void synpred16_LavishScript_fragment()
	{
		EnterRule_synpred16_LavishScript_fragment();
		EnterRule("synpred16_LavishScript_fragment", 78);
		TraceIn("synpred16_LavishScript_fragment", 78);
		try
		{
			// Grammars\\LavishScript.g:256:4: ( math )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:256:5: math
			{
			DebugLocation(256, 5);
			PushFollow(Follow._math_in_synpred16_LavishScript2364);
			math();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_LavishScript_fragment", 78);
			LeaveRule("synpred16_LavishScript_fragment", 78);
			LeaveRule_synpred16_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred16_LavishScript

	partial void EnterRule_synpred17_LavishScript_fragment();
	partial void LeaveRule_synpred17_LavishScript_fragment();

	// $ANTLR start synpred17_LavishScript
	public void synpred17_LavishScript_fragment()
	{
		EnterRule_synpred17_LavishScript_fragment();
		EnterRule("synpred17_LavishScript_fragment", 79);
		TraceIn("synpred17_LavishScript_fragment", 79);
		try
		{
			// Grammars\\LavishScript.g:265:4: ( conditionValue ws Comparer )
			DebugEnterAlt(1);
			// Grammars\\LavishScript.g:265:5: conditionValue ws Comparer
			{
			DebugLocation(265, 5);
			PushFollow(Follow._conditionValue_in_synpred17_LavishScript2468);
			conditionValue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(265, 20);
			PushFollow(Follow._ws_in_synpred17_LavishScript2470);
			ws();
			PopFollow();
			if (state.failed) return;
			DebugLocation(265, 23);
			Match(input,Comparer,Follow._Comparer_in_synpred17_LavishScript2472); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred17_LavishScript_fragment", 79);
			LeaveRule("synpred17_LavishScript_fragment", 79);
			LeaveRule_synpred17_LavishScript_fragment();
		}
	}
	// $ANTLR end synpred17_LavishScript
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA34 dfa34;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa34 = new DFA34( this );
	}

	private class DFA34 : DFA
	{
		private const string DFA34_eotS =
			"\x5\xFFFF";
		private const string DFA34_eofS =
			"\x5\xFFFF";
		private const string DFA34_minS =
			"\x1\x40\x1\xE\x1\xFFFF\x1\xE\x1\xFFFF";
		private const string DFA34_maxS =
			"\x1\x40\x1\x5B\x1\xFFFF\x1\x5B\x1\xFFFF";
		private const string DFA34_acceptS =
			"\x2\xFFFF\x1\x2\x1\xFFFF\x1\x1";
		private const string DFA34_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA34_transitionS =
			{
				"\x1\x1",
				"\x1\x4\x6\xFFFF\x1\x2\x2A\xFFFF\x1\x3\xC\xFFFF\x1\x2\xD\xFFFF\x1\x4",
				"",
				"\x1\x4\x6\xFFFF\x1\x2\x2A\xFFFF\x1\x3\x1A\xFFFF\x1\x4",
				""
			};

		private static readonly short[] DFA34_eot = DFA.UnpackEncodedString(DFA34_eotS);
		private static readonly short[] DFA34_eof = DFA.UnpackEncodedString(DFA34_eofS);
		private static readonly char[] DFA34_min = DFA.UnpackEncodedStringToUnsignedChars(DFA34_minS);
		private static readonly char[] DFA34_max = DFA.UnpackEncodedStringToUnsignedChars(DFA34_maxS);
		private static readonly short[] DFA34_accept = DFA.UnpackEncodedString(DFA34_acceptS);
		private static readonly short[] DFA34_special = DFA.UnpackEncodedString(DFA34_specialS);
		private static readonly short[][] DFA34_transition;

		static DFA34()
		{
			int numStates = DFA34_transitionS.Length;
			DFA34_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA34_transition[i] = DFA.UnpackEncodedString(DFA34_transitionS[i]);
			}
		}

		public DFA34( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 34;
			this.eot = DFA34_eot;
			this.eof = DFA34_eof;
			this.min = DFA34_min;
			this.max = DFA34_max;
			this.accept = DFA34_accept;
			this.special = DFA34_special;
			this.transition = DFA34_transition;
		}

		public override string Description { get { return "()* loopback of 103:3: ( NewLine ( NewLine )* switchCase )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _NewLine_in_script41 = new BitSet(new ulong[]{0x201C09020400080UL,0x6000809UL});
		public static readonly BitSet _scriptStructure_in_script44 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _NewLine_in_script47 = new BitSet(new ulong[]{0x201C09020400080UL,0x6000809UL});
		public static readonly BitSet _scriptStructure_in_script50 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _NewLine_in_script54 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclare_in_scriptStructure71 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_in_scriptStructure73 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_scriptStructure75 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectDef_in_scriptStructure77 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preProcessor_in_scriptStructure79 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _include_in_preProcessor96 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _define_in_preProcessor98 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _macro_in_preProcessor100 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preIf_in_preProcessor102 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifDef_in_preProcessor104 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifNDef_in_preProcessor106 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _echo_in_preProcessor108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _error_in_preProcessor110 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unmac_in_preProcessor112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Unmac_in_unmac124 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_unmac126 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_unmac128 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Define_in_define146 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_define148 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_define150 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_define157 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ID_in_define171 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _INT_in_define178 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _string_in_define185 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _FLOAT_in_define192 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _dataSequence_in_define203 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _command_in_define214 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _condition_in_define221 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _Macro_in_macro258 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_macro260 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_macro263 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_macro265 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_macro267 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_macro269 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _params_in_macro271 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_macro273 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_macro275 = new BitSet(new ulong[]{0x400000000UL,0x10000001UL});
		public static readonly BitSet _WS_in_macro277 = new BitSet(new ulong[]{0x400000000UL,0x1UL});
		public static readonly BitSet _expression_in_macro284 = new BitSet(new ulong[]{0x400000000UL,0x1UL});
		public static readonly BitSet _EndMac_in_macro290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PreIf_in_preIf319 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_preIf321 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_preIf323 = new BitSet(new ulong[]{0x0UL,0x10000001UL});
		public static readonly BitSet _WS_in_preIf325 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_preIf331 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _preElseIf_in_preIf337 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _preElse_in_preIf343 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _endIf_in_preIf349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NewLine_in_endIf380 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _EndIf_in_endIf383 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NewLine_in_preElse396 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _PreElse_in_preElse398 = new BitSet(new ulong[]{0x2UL,0x10000001UL});
		public static readonly BitSet _WS_in_preElse400 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _expression_in_preElse403 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _NewLine_in_preElseIf424 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _PreElseIf_in_preElseIf426 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _WS_in_preElseIf428 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_preElseIf431 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _expression_in_preElseIf433 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _IfDef_in_ifDef455 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_ifDef457 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_ifDef459 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _preElse_in_ifDef463 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _endIf_in_ifDef468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IfNDef_in_ifNDef490 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_ifNDef492 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_ifNDef494 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _preElse_in_ifNDef498 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _endIf_in_ifNDef503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Echo_in_echo525 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_echo527 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_echo529 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _Error_in_error549 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_error551 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_error553 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _Include_in_include573 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_include575 = new BitSet(new ulong[]{0x0UL,0x1000UL});
		public static readonly BitSet _string_in_include577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Quote_in_string596 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFFUL});
		public static readonly BitSet _dataSequence_in_string609 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFFUL});
		public static readonly BitSet _quoteString_in_string611 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFFUL});
		public static readonly BitSet _Quote_in_string617 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Dollar_in_dataSequence653 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LCurly_in_dataSequence655 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _accessor_in_dataSequence657 = new BitSet(new ulong[]{0x4010000UL,0x2000UL});
		public static readonly BitSet _member_in_dataSequence659 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RCurly_in_dataSequence662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_id684 = new BitSet(new ulong[]{0x80002000002UL});
		public static readonly BitSet _id_in_id686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_id700 = new BitSet(new ulong[]{0x80002000002UL});
		public static readonly BitSet _id_in_id702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Dot_in_member715 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _accessor_in_member717 = new BitSet(new ulong[]{0x4010002UL});
		public static readonly BitSet _member_in_member719 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Colon_in_member735 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _accessor_in_member737 = new BitSet(new ulong[]{0x4010002UL});
		public static readonly BitSet _member_in_member739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessor_in_dataCommand762 = new BitSet(new ulong[]{0x4010000UL});
		public static readonly BitSet _member_in_dataCommand764 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Switch_in_switchStatement776 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_switchStatement779 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFFUL});
		public static readonly BitSet _NewLine_in_switchStatement783 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LCurly_in_switchStatement787 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_switchStatement792 = new BitSet(new ulong[]{0x4000UL,0x8000001UL});
		public static readonly BitSet _NewLine_in_switchStatement794 = new BitSet(new ulong[]{0x4000UL,0x8000001UL});
		public static readonly BitSet _switchCase_in_switchStatement797 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_switchStatement804 = new BitSet(new ulong[]{0x200000UL,0x1UL});
		public static readonly BitSet _NewLine_in_switchStatement806 = new BitSet(new ulong[]{0x200000UL,0x1UL});
		public static readonly BitSet _defaultCase_in_switchStatement809 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_switchStatement815 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RCurly_in_switchStatement817 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Case_in_switchCase849 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_switchCase851 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFFUL});
		public static readonly BitSet _expression_in_switchCase854 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _VariableCase_in_switchCase875 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _dataSequence_in_switchCase877 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _expression_in_switchCase879 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _Default_in_defaultCase901 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _expression_in_defaultCase904 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _ObjectDef_in_objectDef918 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_objectDef920 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_objectDef922 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_objectDef924 = new BitSet(new ulong[]{0x2000000000000UL,0x1UL});
		public static readonly BitSet _Inherits_in_objectDef927 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_objectDef929 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_objectDef931 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_objectDef935 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LCurly_in_objectDef939 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_objectDef945 = new BitSet(new ulong[]{0xC00008000000080UL,0x4002001UL});
		public static readonly BitSet _function_in_objectDef951 = new BitSet(new ulong[]{0x0UL,0x2001UL});
		public static readonly BitSet _atom_in_objectDef955 = new BitSet(new ulong[]{0x0UL,0x2001UL});
		public static readonly BitSet _objectMethod_in_objectDef959 = new BitSet(new ulong[]{0x0UL,0x2001UL});
		public static readonly BitSet _objectMember_in_objectDef963 = new BitSet(new ulong[]{0x0UL,0x2001UL});
		public static readonly BitSet _variableDeclare_in_objectDef967 = new BitSet(new ulong[]{0x0UL,0x2001UL});
		public static readonly BitSet _RCurly_in_objectDef975 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Function_in_function1010 = new BitSet(new ulong[]{0x10000UL,0x10000000UL});
		public static readonly BitSet _Colon_in_function1012 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_function1016 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_function1019 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_function1023 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _params_in_function1025 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_function1027 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _codeBlock_in_function1029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Atom_in_atom1066 = new BitSet(new ulong[]{0x80000010000UL});
		public static readonly BitSet _Colon_in_atom1068 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_atom1072 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_atom1078 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_atom1080 = new BitSet(new ulong[]{0x8000000000000UL,0x4000UL});
		public static readonly BitSet _params_in_atom1082 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_atom1085 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_atom1087 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _codeBlock_in_atom1089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Member_in_objectMember1125 = new BitSet(new ulong[]{0x80000010000UL});
		public static readonly BitSet _Colon_in_objectMember1127 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_objectMember1131 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_objectMember1137 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_objectMember1139 = new BitSet(new ulong[]{0x8000000000000UL,0x4000UL});
		public static readonly BitSet _params_in_objectMember1141 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_objectMember1144 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_objectMember1146 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _codeBlock_in_objectMember1148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Method_in_objectMethod1184 = new BitSet(new ulong[]{0x80000010000UL});
		public static readonly BitSet _Colon_in_objectMethod1186 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_objectMethod1190 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_objectMethod1196 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_objectMethod1198 = new BitSet(new ulong[]{0x8000000000000UL,0x4000UL});
		public static readonly BitSet _params_in_objectMethod1200 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_objectMethod1203 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_objectMethod1205 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _codeBlock_in_objectMethod1207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataCommand_in_command1248 = new BitSet(new ulong[]{0x2UL,0x200000UL});
		public static readonly BitSet _Semi_in_command1251 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_command1253 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_command1273 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_command1275 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _commandArg_in_command1278 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _Semi_in_command1282 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_command1284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_command1314 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _commandArg_in_command1317 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF2UL,0x7FFFFFFEUL});
		public static readonly BitSet _Semi_in_command1321 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_command1323 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NewLine_in_expression1357 = new BitSet(new ulong[]{0x205E85023500002UL,0x36400800UL});
		public static readonly BitSet _WS_in_expression1360 = new BitSet(new ulong[]{0x205E85023500002UL,0x36400800UL});
		public static readonly BitSet _command_in_expression1371 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _declareVariable_in_expression1376 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _preProcessor_in_expression1381 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _variableDeclare_in_expression1386 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _forStatement_in_expression1391 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _doStatement_in_expression1396 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _whileStatement_in_expression1401 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _ifStatement_in_expression1406 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _switchStatement_in_expression1411 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _codeBlock_in_expression1416 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _WS_in_expression1425 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LParen_in_params1439 = new BitSet(new ulong[]{0x40000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_params1441 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _Elipse_in_params1443 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_params1445 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_params1447 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_params1449 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_params1451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LParen_in_params1468 = new BitSet(new ulong[]{0x80000000000UL,0x10004001UL});
		public static readonly BitSet _ws_in_params1470 = new BitSet(new ulong[]{0x80000000000UL,0x10004001UL});
		public static readonly BitSet _param_in_params1473 = new BitSet(new ulong[]{0x20000UL,0x10004001UL});
		public static readonly BitSet _ws_in_params1476 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _Comma_in_params1478 = new BitSet(new ulong[]{0x80000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_params1480 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _param_in_params1482 = new BitSet(new ulong[]{0x20000UL,0x10004001UL});
		public static readonly BitSet _ws_in_params1488 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_params1490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_param1516 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_param1518 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_param1522 = new BitSet(new ulong[]{0x42UL,0x10000001UL});
		public static readonly BitSet _ID_in_param1527 = new BitSet(new ulong[]{0x42UL,0x10000001UL});
		public static readonly BitSet _ws_in_param1530 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_param1532 = new BitSet(new ulong[]{0x182002000000UL,0x10001001UL});
		public static readonly BitSet _ws_in_param1534 = new BitSet(new ulong[]{0x182002000000UL,0x1000UL});
		public static readonly BitSet _value_in_param1536 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _If_in_ifStatement1578 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_ifStatement1580 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_ifStatement1584 = new BitSet(new ulong[]{0x0UL,0x10000001UL});
		public static readonly BitSet _WS_in_ifStatement1586 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_ifStatement1591 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _NewLine_in_ifStatement1602 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _ElseIf_in_ifStatement1606 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_ifStatement1610 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_ifStatement1614 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _NewLine_in_ifStatement1627 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _Else_in_ifStatement1629 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_ifStatement1633 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Do_in_doStatement1682 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_doStatement1684 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _NewLine_in_doStatement1686 = new BitSet(new ulong[]{0x0UL,0x20000000UL});
		public static readonly BitSet _While_in_doStatement1688 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_doStatement1690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _While_in_whileStatement1710 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_whileStatement1712 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_whileStatement1714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _For_in_forStatement1765 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1767 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_forStatement1769 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1771 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_forStatement1773 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_forStatement1775 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_forStatement1777 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_forStatement1779 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_forStatement1781 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_forStatement1783 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_forStatement1785 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1787 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_forStatement1789 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_forStatement1791 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_forStatement1793 = new BitSet(new ulong[]{0x0UL,0x10000001UL});
		public static readonly BitSet _WS_in_forStatement1795 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_forStatement1798 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _For_in_forStatement1842 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1844 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_forStatement1846 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_forStatement1848 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_forStatement1850 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_forStatement1852 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_forStatement1854 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1856 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_forStatement1858 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_forStatement1860 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_forStatement1862 = new BitSet(new ulong[]{0x0UL,0x10000001UL});
		public static readonly BitSet _WS_in_forStatement1864 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_forStatement1866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _For_in_forStatement1886 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1888 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_forStatement1890 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1892 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_forStatement1894 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_forStatement1896 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_forStatement1898 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_forStatement1900 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_forStatement1902 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_forStatement1904 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_forStatement1906 = new BitSet(new ulong[]{0x0UL,0x10000001UL});
		public static readonly BitSet _WS_in_forStatement1908 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_forStatement1911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Negate_in_conditionValue1944 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFEUL});
		public static readonly BitSet _ID_in_conditionValue1950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_conditionValue1962 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_conditionValue1978 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionString_in_conditionValue1990 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_conditionValue2016 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_conditionValue2022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_conditionValue2032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionString_in_conditionValue2038 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitXor_in_math2076 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _Bor_in_math2079 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _bitXor_in_math2082 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _bitAnd_in_bitXor2096 = new BitSet(new ulong[]{0x2UL,0x40000000UL});
		public static readonly BitSet _Xor_in_bitXor2099 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _bitAnd_in_bitXor2102 = new BitSet(new ulong[]{0x2UL,0x40000000UL});
		public static readonly BitSet _shift_in_bitAnd2116 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _Band_in_bitAnd2119 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _shift_in_bitAnd2122 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _addSub_in_shift2136 = new BitSet(new ulong[]{0x20000000000002UL,0x20000UL});
		public static readonly BitSet _LeftShift_in_shift2140 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _RightShift_in_shift2143 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _addSub_in_shift2147 = new BitSet(new ulong[]{0x20000000000002UL,0x20000UL});
		public static readonly BitSet _multDiv_in_addSub2161 = new BitSet(new ulong[]{0x1000000000000002UL,0x100UL});
		public static readonly BitSet _Plus_in_addSub2165 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _Minus_in_addSub2168 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _multDiv_in_addSub2172 = new BitSet(new ulong[]{0x1000000000000002UL,0x100UL});
		public static readonly BitSet _bitNegate_in_multDiv2186 = new BitSet(new ulong[]{0x6000000000800002UL});
		public static readonly BitSet _Mult_in_multDiv2190 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _Div_in_multDiv2193 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _Modu_in_multDiv2196 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _bitNegate_in_multDiv2200 = new BitSet(new ulong[]{0x6000000000800002UL});
		public static readonly BitSet _mathVal_in_bitNegate2214 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _Bnegate_in_bitNegate2217 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _mathVal_in_bitNegate2220 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _LParen_in_mathVal2234 = new BitSet(new ulong[]{0x8102002000000UL});
		public static readonly BitSet _math_in_mathVal2237 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_mathVal2239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_mathVal2246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_mathVal2248 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_mathVal2250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NewLine_in_ws2263 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _WS_in_ws2267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_lineArg2281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_lineArg2286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_lineArg2295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_lineArg2300 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_commaArg2315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_commaArg2320 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_commaArg2329 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_commaArg2334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_commandArg2353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_commandArg2358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_commandArg2367 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_commandArg2372 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ws_in_condition2389 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFEUL});
		public static readonly BitSet _LParen_in_condition2395 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_condition2397 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_condition2399 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_condition2401 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_condition2403 = new BitSet(new ulong[]{0x22UL,0x10UL});
		public static readonly BitSet _orCondition_in_condition2406 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andCondition_in_condition2408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Negate_in_condition2427 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_condition2429 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_condition2431 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_condition2433 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_condition2435 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_condition2437 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_condition2439 = new BitSet(new ulong[]{0x22UL,0x10UL});
		public static readonly BitSet _orCondition_in_condition2442 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andCondition_in_condition2444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionValue_in_condition2475 = new BitSet(new ulong[]{0x40000UL,0x10000001UL});
		public static readonly BitSet _ws_in_condition2477 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _Comparer_in_condition2479 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_condition2481 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFEUL});
		public static readonly BitSet _conditionValue_in_condition2483 = new BitSet(new ulong[]{0x22UL,0x10UL});
		public static readonly BitSet _orCondition_in_condition2486 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andCondition_in_condition2488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionValue_in_condition2517 = new BitSet(new ulong[]{0x22UL,0x10UL});
		public static readonly BitSet _orCondition_in_condition2520 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andCondition_in_condition2522 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Or_in_orCondition2551 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_orCondition2553 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _And_in_andCondition2574 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_andCondition2576 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Variable_in_variableDeclare2595 = new BitSet(new ulong[]{0x8000000000000UL,0x10000000UL});
		public static readonly BitSet _LParen_in_variableDeclare2597 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _Scope_in_variableDeclare2599 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_variableDeclare2601 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_variableDeclare2605 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_variableDeclare2609 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_variableDeclare2611 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_variableDeclare2615 = new BitSet(new ulong[]{0x10000000000042UL,0x10000001UL});
		public static readonly BitSet _indexer_in_variableDeclare2617 = new BitSet(new ulong[]{0x42UL,0x10000001UL});
		public static readonly BitSet _ws_in_variableDeclare2621 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _Assign_in_variableDeclare2623 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFFUL});
		public static readonly BitSet _ws_in_variableDeclare2625 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_variableDeclare2627 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _WS_in_variableDeclare2630 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_variableDeclare2632 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _LCurly_in_codeBlock2683 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _expression_in_codeBlock2687 = new BitSet(new ulong[]{0x0UL,0x2001UL});
		public static readonly BitSet _RCurly_in_codeBlock2693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DeclareVariable_in_declareVariable2712 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_declareVariable2714 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_declareVariable2718 = new BitSet(new ulong[]{0x10000000000000UL,0x10000000UL});
		public static readonly BitSet _indexer_in_declareVariable2720 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_declareVariable2723 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_declareVariable2727 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_declareVariable2729 = new BitSet(new ulong[]{0x2UL,0x80000UL});
		public static readonly BitSet _Scope_in_declareVariable2731 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _WS_in_declareVariable2734 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF0UL,0x7FFFFFFEUL});
		public static readonly BitSet _lineArg_in_declareVariable2736 = new BitSet(new ulong[]{0x2UL,0x10000000UL});
		public static readonly BitSet _ID_in_value2786 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_value2788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_value2790 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_value2792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_value2794 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_accessor2804 = new BitSet(new ulong[]{0x18000000000002UL});
		public static readonly BitSet _indexer_in_accessor2807 = new BitSet(new ulong[]{0x18000000000002UL});
		public static readonly BitSet _typeCast_in_accessor2809 = new BitSet(new ulong[]{0x18000000000002UL});
		public static readonly BitSet _LSquare_in_indexer2822 = new BitSet(new ulong[]{0xFFFFFFFFFFFDFFF0UL,0x7FFFFFFFUL});
		public static readonly BitSet _commaValue_in_indexer2825 = new BitSet(new ulong[]{0x20000UL,0x8000UL});
		public static readonly BitSet _Comma_in_indexer2828 = new BitSet(new ulong[]{0xFFFFFFFFFFFDFFF0UL,0x7FFF7FFFUL});
		public static readonly BitSet _commaValue_in_indexer2830 = new BitSet(new ulong[]{0x20000UL,0x8000UL});
		public static readonly BitSet _RSquare_in_indexer2836 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _commaArg_in_commaValue2855 = new BitSet(new ulong[]{0xFFFFFFFFFFFDFFF2UL,0x7FFF7FFFUL});
		public static readonly BitSet _LParen_in_typeCast2873 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _id_in_typeCast2875 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_typeCast2877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _include_in_synpred1_LavishScript93 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_synpred2_LavishScript200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _command_in_synpred3_LavishScript211 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_synpred4_LavishScript606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataCommand_in_synpred5_LavishScript1245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred6_LavishScript1269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_synpred7_LavishScript1308 = new BitSet(new ulong[]{0x0UL,0x10000000UL});
		public static readonly BitSet _WS_in_synpred7_LavishScript1310 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NewLine_in_synpred8_LavishScript1597 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _ElseIf_in_synpred8_LavishScript1599 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NewLine_in_synpred9_LavishScript1622 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _Else_in_synpred9_LavishScript1624 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _For_in_synpred10_LavishScript1735 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_synpred10_LavishScript1737 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_synpred10_LavishScript1739 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_synpred10_LavishScript1741 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_synpred10_LavishScript1743 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_synpred10_LavishScript1745 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_synpred10_LavishScript1747 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_synpred10_LavishScript1749 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_synpred10_LavishScript1751 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_synpred10_LavishScript1753 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_synpred10_LavishScript1755 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_synpred10_LavishScript1757 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_synpred10_LavishScript1759 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_synpred10_LavishScript1761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _For_in_synpred11_LavishScript1818 = new BitSet(new ulong[]{0x8000000000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_synpred11_LavishScript1820 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LParen_in_synpred11_LavishScript1822 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _ws_in_synpred11_LavishScript1824 = new BitSet(new ulong[]{0xFFFFFFFFFFFBFFF0UL,0x7FFFBFFFUL});
		public static readonly BitSet _condition_in_synpred11_LavishScript1826 = new BitSet(new ulong[]{0x0UL,0x10200001UL});
		public static readonly BitSet _ws_in_synpred11_LavishScript1828 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _Semi_in_synpred11_LavishScript1830 = new BitSet(new ulong[]{0x80002000000UL,0x10000001UL});
		public static readonly BitSet _ws_in_synpred11_LavishScript1832 = new BitSet(new ulong[]{0x80002000000UL});
		public static readonly BitSet _command_in_synpred11_LavishScript1834 = new BitSet(new ulong[]{0x0UL,0x10004001UL});
		public static readonly BitSet _ws_in_synpred11_LavishScript1836 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RParen_in_synpred11_LavishScript1838 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_synpred12_LavishScript1975 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_synpred13_LavishScript2029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_synpred14_LavishScript2292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_synpred15_LavishScript2326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_synpred16_LavishScript2364 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionValue_in_synpred17_LavishScript2468 = new BitSet(new ulong[]{0x40000UL,0x10000001UL});
		public static readonly BitSet _ws_in_synpred17_LavishScript2470 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _Comparer_in_synpred17_LavishScript2472 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
