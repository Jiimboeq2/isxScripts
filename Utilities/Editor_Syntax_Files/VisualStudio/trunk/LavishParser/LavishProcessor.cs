//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Grammars\\LavishProcessor.g 2012-04-20 03:47:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class LavishProcessor : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARG", "And", "Assign", "Atom", "Band", "Bnegate", "Bor", "COMMAND", "COMMENT", "CONDITION", "Case", "CodeBlock", "Colon", "Comma", "Comparer", "DataCommand", "DeclareVariable", "Default", "Define", "Div", "Do", "Dollar", "Dot", "ESC_SEQ", "EXPONENT", "Echo", "Elipse", "Else", "ElseIf", "EndIf", "EndMac", "EqualTo", "Error", "FLOAT", "For", "Function", "GreaterThan", "GreaterThanEqual", "HEX_DIGIT", "ID", "INT", "If", "IfDef", "IfNDef", "Include", "Inherits", "LCurly", "LParen", "LSquare", "LeftShift", "LessThan", "LessThanEqual", "MATH", "Macro", "Member", "Method", "Minus", "Modu", "Mult", "Negate", "NewLine", "NotEqualTo", "OCTAL_ESC", "ObjectDef", "Or", "Other", "Param", "Params", "Plus", "PreElse", "PreElseIf", "PreIf", "Quote", "RCurly", "RParen", "RSquare", "Returns", "RightShift", "STRING", "Scope", "Script", "Semi", "Switch", "Type", "UNICODE_ESC", "Unmac", "Variable", "VariableCase", "WS", "While", "Xor"
	};
	public const int EOF=-1;
	public const int ARG=4;
	public const int And=5;
	public const int Assign=6;
	public const int Atom=7;
	public const int Band=8;
	public const int Bnegate=9;
	public const int Bor=10;
	public const int COMMAND=11;
	public const int COMMENT=12;
	public const int CONDITION=13;
	public const int Case=14;
	public const int CodeBlock=15;
	public const int Colon=16;
	public const int Comma=17;
	public const int Comparer=18;
	public const int DataCommand=19;
	public const int DeclareVariable=20;
	public const int Default=21;
	public const int Define=22;
	public const int Div=23;
	public const int Do=24;
	public const int Dollar=25;
	public const int Dot=26;
	public const int ESC_SEQ=27;
	public const int EXPONENT=28;
	public const int Echo=29;
	public const int Elipse=30;
	public const int Else=31;
	public const int ElseIf=32;
	public const int EndIf=33;
	public const int EndMac=34;
	public const int EqualTo=35;
	public const int Error=36;
	public const int FLOAT=37;
	public const int For=38;
	public const int Function=39;
	public const int GreaterThan=40;
	public const int GreaterThanEqual=41;
	public const int HEX_DIGIT=42;
	public const int ID=43;
	public const int INT=44;
	public const int If=45;
	public const int IfDef=46;
	public const int IfNDef=47;
	public const int Include=48;
	public const int Inherits=49;
	public const int LCurly=50;
	public const int LParen=51;
	public const int LSquare=52;
	public const int LeftShift=53;
	public const int LessThan=54;
	public const int LessThanEqual=55;
	public const int MATH=56;
	public const int Macro=57;
	public const int Member=58;
	public const int Method=59;
	public const int Minus=60;
	public const int Modu=61;
	public const int Mult=62;
	public const int Negate=63;
	public const int NewLine=64;
	public const int NotEqualTo=65;
	public const int OCTAL_ESC=66;
	public const int ObjectDef=67;
	public const int Or=68;
	public const int Other=69;
	public const int Param=70;
	public const int Params=71;
	public const int Plus=72;
	public const int PreElse=73;
	public const int PreElseIf=74;
	public const int PreIf=75;
	public const int Quote=76;
	public const int RCurly=77;
	public const int RParen=78;
	public const int RSquare=79;
	public const int Returns=80;
	public const int RightShift=81;
	public const int STRING=82;
	public const int Scope=83;
	public const int Script=84;
	public const int Semi=85;
	public const int Switch=86;
	public const int Type=87;
	public const int UNICODE_ESC=88;
	public const int Unmac=89;
	public const int Variable=90;
	public const int VariableCase=91;
	public const int WS=92;
	public const int While=93;
	public const int Xor=94;

	public LavishProcessor(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public LavishProcessor(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return LavishProcessor.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\LavishProcessor.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();
	// $ANTLR start "script"
	// Grammars\\LavishProcessor.g:7:8: public script : ( scriptStructure )+ ;
	[GrammarRule("script")]
	public void script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(7, 1);
		try
		{
			// Grammars\\LavishProcessor.g:8:2: ( ( scriptStructure )+ )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:8:4: ( scriptStructure )+
			{
			DebugLocation(8, 4);
			// Grammars\\LavishProcessor.g:8:4: ( scriptStructure )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==Atom||LA1_1==Define||LA1_1==Echo||LA1_1==Error||LA1_1==Function||(LA1_1>=IfDef && LA1_1<=Include)||LA1_1==Macro||LA1_1==ObjectDef||LA1_1==PreIf||(LA1_1>=Unmac && LA1_1<=Variable)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:8:4: scriptStructure
					{
					DebugLocation(8, 4);
					PushFollow(Follow._scriptStructure_in_script36);
					scriptStructure();
					PopFollow();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(9, 1);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return;

	}
	// $ANTLR end "script"

	partial void EnterRule_scriptStructure();
	partial void LeaveRule_scriptStructure();
	// $ANTLR start "scriptStructure"
	// Grammars\\LavishProcessor.g:10:8: public scriptStructure : ( variableDeclare | function | atom | objectDef | preProcessor );
	[GrammarRule("scriptStructure")]
	public void scriptStructure()
	{
		EnterRule_scriptStructure();
		EnterRule("scriptStructure", 2);
		TraceIn("scriptStructure", 2);
		try { DebugEnterRule(GrammarFileName, "scriptStructure");
		DebugLocation(10, 1);
		try
		{
			// Grammars\\LavishProcessor.g:11:2: ( variableDeclare | function | atom | objectDef | preProcessor )
			int alt2=5;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case Variable:
				{
				alt2 = 1;
				}
				break;
			case Function:
				{
				alt2 = 2;
				}
				break;
			case Atom:
				{
				alt2 = 3;
				}
				break;
			case ObjectDef:
				{
				alt2 = 4;
				}
				break;
			case Define:
			case Echo:
			case Error:
			case IfDef:
			case IfNDef:
			case Include:
			case Macro:
			case PreIf:
			case Unmac:
				{
				alt2 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:11:4: variableDeclare
				{
				DebugLocation(11, 4);
				PushFollow(Follow._variableDeclare_in_scriptStructure49);
				variableDeclare();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:12:4: function
				{
				DebugLocation(12, 4);
				PushFollow(Follow._function_in_scriptStructure55);
				function();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:13:4: atom
				{
				DebugLocation(13, 4);
				PushFollow(Follow._atom_in_scriptStructure61);
				atom();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:14:4: objectDef
				{
				DebugLocation(14, 4);
				PushFollow(Follow._objectDef_in_scriptStructure67);
				objectDef();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishProcessor.g:15:4: preProcessor
				{
				DebugLocation(15, 4);
				PushFollow(Follow._preProcessor_in_scriptStructure72);
				preProcessor();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("scriptStructure", 2);
			LeaveRule("scriptStructure", 2);
			LeaveRule_scriptStructure();
		}
		DebugLocation(16, 1);
		} finally { DebugExitRule(GrammarFileName, "scriptStructure"); }
		return;

	}
	// $ANTLR end "scriptStructure"

	partial void EnterRule_objectDef();
	partial void LeaveRule_objectDef();
	// $ANTLR start "objectDef"
	// Grammars\\LavishProcessor.g:17:8: public objectDef : ^( ObjectDef ^( ID ( function | atom | objectMember | variableDeclare | objectMethod )* ) ( ^( Inherits ID ) )? ) ;
	[GrammarRule("objectDef")]
	public void objectDef()
	{
		EnterRule_objectDef();
		EnterRule("objectDef", 3);
		TraceIn("objectDef", 3);
		try { DebugEnterRule(GrammarFileName, "objectDef");
		DebugLocation(17, 1);
		try
		{
			// Grammars\\LavishProcessor.g:18:2: ( ^( ObjectDef ^( ID ( function | atom | objectMember | variableDeclare | objectMethod )* ) ( ^( Inherits ID ) )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:18:4: ^( ObjectDef ^( ID ( function | atom | objectMember | variableDeclare | objectMethod )* ) ( ^( Inherits ID ) )? )
			{
			DebugLocation(18, 4);
			DebugLocation(18, 6);
			Match(input,ObjectDef,Follow._ObjectDef_in_objectDef85); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(18, 16);
			DebugLocation(18, 18);
			Match(input,ID,Follow._ID_in_objectDef88); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(18, 21);
				// Grammars\\LavishProcessor.g:18:21: ( function | atom | objectMember | variableDeclare | objectMethod )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=6;
					try { DebugEnterDecision(3, false);
					switch (input.LA(1))
					{
					case Function:
						{
						alt3 = 1;
						}
						break;
					case Atom:
						{
						alt3 = 2;
						}
						break;
					case Member:
						{
						alt3 = 3;
						}
						break;
					case Variable:
						{
						alt3 = 4;
						}
						break;
					case Method:
						{
						alt3 = 5;
						}
						break;
					}

					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:18:22: function
						{
						DebugLocation(18, 22);
						PushFollow(Follow._function_in_objectDef91);
						function();
						PopFollow();


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishProcessor.g:18:31: atom
						{
						DebugLocation(18, 31);
						PushFollow(Follow._atom_in_objectDef93);
						atom();
						PopFollow();


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Grammars\\LavishProcessor.g:18:36: objectMember
						{
						DebugLocation(18, 36);
						PushFollow(Follow._objectMember_in_objectDef95);
						objectMember();
						PopFollow();


						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Grammars\\LavishProcessor.g:18:49: variableDeclare
						{
						DebugLocation(18, 49);
						PushFollow(Follow._variableDeclare_in_objectDef97);
						variableDeclare();
						PopFollow();


						}
						break;
					case 5:
						DebugEnterAlt(5);
						// Grammars\\LavishProcessor.g:18:65: objectMethod
						{
						DebugLocation(18, 65);
						PushFollow(Follow._objectMethod_in_objectDef99);
						objectMethod();
						PopFollow();


						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(18, 81);
			// Grammars\\LavishProcessor.g:18:81: ( ^( Inherits ID ) )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==Inherits))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:18:82: ^( Inherits ID )
				{
				DebugLocation(18, 82);
				DebugLocation(18, 84);
				Match(input,Inherits,Follow._Inherits_in_objectDef106); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(18, 93);
				Match(input,ID,Follow._ID_in_objectDef108); 

				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("objectDef", 3);
			LeaveRule("objectDef", 3);
			LeaveRule_objectDef();
		}
		DebugLocation(19, 1);
		} finally { DebugExitRule(GrammarFileName, "objectDef"); }
		return;

	}
	// $ANTLR end "objectDef"

	partial void EnterRule_variableDeclare();
	partial void LeaveRule_variableDeclare();
	// $ANTLR start "variableDeclare"
	// Grammars\\LavishProcessor.g:20:8: public variableDeclare : ^( Variable ( Scope )? ID ( indexer )? ^( ID ( ^( Assign ( lineArg )* ) )? ) ) ;
	[GrammarRule("variableDeclare")]
	public void variableDeclare()
	{
		EnterRule_variableDeclare();
		EnterRule("variableDeclare", 4);
		TraceIn("variableDeclare", 4);
		try { DebugEnterRule(GrammarFileName, "variableDeclare");
		DebugLocation(20, 1);
		try
		{
			// Grammars\\LavishProcessor.g:21:2: ( ^( Variable ( Scope )? ID ( indexer )? ^( ID ( ^( Assign ( lineArg )* ) )? ) ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:21:4: ^( Variable ( Scope )? ID ( indexer )? ^( ID ( ^( Assign ( lineArg )* ) )? ) )
			{
			DebugLocation(21, 4);
			DebugLocation(21, 6);
			Match(input,Variable,Follow._Variable_in_variableDeclare125); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(21, 15);
			// Grammars\\LavishProcessor.g:21:15: ( Scope )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==Scope))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:21:15: Scope
				{
				DebugLocation(21, 15);
				Match(input,Scope,Follow._Scope_in_variableDeclare127); 

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(21, 22);
			Match(input,ID,Follow._ID_in_variableDeclare130); 
			DebugLocation(21, 25);
			// Grammars\\LavishProcessor.g:21:25: ( indexer )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==LSquare))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:21:25: indexer
				{
				DebugLocation(21, 25);
				PushFollow(Follow._indexer_in_variableDeclare132);
				indexer();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(21, 34);
			DebugLocation(21, 36);
			Match(input,ID,Follow._ID_in_variableDeclare136); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(21, 38);
				// Grammars\\LavishProcessor.g:21:38: ( ^( Assign ( lineArg )* ) )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==Assign))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:21:39: ^( Assign ( lineArg )* )
					{
					DebugLocation(21, 39);
					DebugLocation(21, 41);
					Match(input,Assign,Follow._Assign_in_variableDeclare139); 

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); 
						DebugLocation(21, 48);
						// Grammars\\LavishProcessor.g:21:48: ( lineArg )*
						try { DebugEnterSubRule(7);
						while (true)
						{
							int alt7=2;
							try { DebugEnterDecision(7, false);
							int LA7_1 = input.LA(1);

							if (((LA7_1>=ARG && LA7_1<=Negate)||(LA7_1>=NotEqualTo && LA7_1<=Xor)))
							{
								alt7 = 1;
							}


							} finally { DebugExitDecision(7); }
							switch ( alt7 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\LavishProcessor.g:21:48: lineArg
								{
								DebugLocation(21, 48);
								PushFollow(Follow._lineArg_in_variableDeclare141);
								lineArg();
								PopFollow();


								}
								break;

							default:
								goto loop7;
							}
						}

						loop7:
							;

						} finally { DebugExitSubRule(7); }


						Match(input, TokenTypes.Up, null); 
					}


					}
					break;

				}
				} finally { DebugExitSubRule(8); }


				Match(input, TokenTypes.Up, null); 
			}


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variableDeclare", 4);
			LeaveRule("variableDeclare", 4);
			LeaveRule_variableDeclare();
		}
		DebugLocation(22, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclare"); }
		return;

	}
	// $ANTLR end "variableDeclare"

	partial void EnterRule_function();
	partial void LeaveRule_function();
	// $ANTLR start "function"
	// Grammars\\LavishProcessor.g:23:8: public function : ^( Function ID ^( Returns ( ID )? ) params codeBlock ) ;
	[GrammarRule("function")]
	public void function()
	{
		EnterRule_function();
		EnterRule("function", 5);
		TraceIn("function", 5);
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(23, 1);
		try
		{
			// Grammars\\LavishProcessor.g:24:2: ( ^( Function ID ^( Returns ( ID )? ) params codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:24:4: ^( Function ID ^( Returns ( ID )? ) params codeBlock )
			{
			DebugLocation(24, 4);
			DebugLocation(24, 6);
			Match(input,Function,Follow._Function_in_function160); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(24, 15);
			Match(input,ID,Follow._ID_in_function162); 
			DebugLocation(24, 18);
			DebugLocation(24, 20);
			Match(input,Returns,Follow._Returns_in_function165); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(24, 28);
				// Grammars\\LavishProcessor.g:24:28: ( ID )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==ID))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:24:28: ID
					{
					DebugLocation(24, 28);
					Match(input,ID,Follow._ID_in_function167); 

					}
					break;

				}
				} finally { DebugExitSubRule(9); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(24, 33);
			PushFollow(Follow._params_in_function171);
			@params();
			PopFollow();

			DebugLocation(24, 40);
			PushFollow(Follow._codeBlock_in_function173);
			codeBlock();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("function", 5);
			LeaveRule("function", 5);
			LeaveRule_function();
		}
		DebugLocation(25, 1);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return;

	}
	// $ANTLR end "function"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\LavishProcessor.g:26:8: public atom : ^( Atom ID ^( Returns ( ID )? ) params codeBlock ) ;
	[GrammarRule("atom")]
	public void atom()
	{
		EnterRule_atom();
		EnterRule("atom", 6);
		TraceIn("atom", 6);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(26, 1);
		try
		{
			// Grammars\\LavishProcessor.g:27:2: ( ^( Atom ID ^( Returns ( ID )? ) params codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:27:4: ^( Atom ID ^( Returns ( ID )? ) params codeBlock )
			{
			DebugLocation(27, 4);
			DebugLocation(27, 6);
			Match(input,Atom,Follow._Atom_in_atom187); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(27, 11);
			Match(input,ID,Follow._ID_in_atom189); 
			DebugLocation(27, 14);
			DebugLocation(27, 16);
			Match(input,Returns,Follow._Returns_in_atom192); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(27, 24);
				// Grammars\\LavishProcessor.g:27:24: ( ID )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==ID))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:27:24: ID
					{
					DebugLocation(27, 24);
					Match(input,ID,Follow._ID_in_atom194); 

					}
					break;

				}
				} finally { DebugExitSubRule(10); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(27, 29);
			PushFollow(Follow._params_in_atom198);
			@params();
			PopFollow();

			DebugLocation(27, 36);
			PushFollow(Follow._codeBlock_in_atom200);
			codeBlock();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 6);
			LeaveRule("atom", 6);
			LeaveRule_atom();
		}
		DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return;

	}
	// $ANTLR end "atom"

	partial void EnterRule_objectMember();
	partial void LeaveRule_objectMember();
	// $ANTLR start "objectMember"
	// Grammars\\LavishProcessor.g:29:8: public objectMember : ^( Member ID ^( Returns ( ID )? ) params codeBlock ) ;
	[GrammarRule("objectMember")]
	public void objectMember()
	{
		EnterRule_objectMember();
		EnterRule("objectMember", 7);
		TraceIn("objectMember", 7);
		try { DebugEnterRule(GrammarFileName, "objectMember");
		DebugLocation(29, 1);
		try
		{
			// Grammars\\LavishProcessor.g:30:2: ( ^( Member ID ^( Returns ( ID )? ) params codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:30:4: ^( Member ID ^( Returns ( ID )? ) params codeBlock )
			{
			DebugLocation(30, 4);
			DebugLocation(30, 6);
			Match(input,Member,Follow._Member_in_objectMember214); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(30, 13);
			Match(input,ID,Follow._ID_in_objectMember216); 
			DebugLocation(30, 16);
			DebugLocation(30, 18);
			Match(input,Returns,Follow._Returns_in_objectMember219); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(30, 26);
				// Grammars\\LavishProcessor.g:30:26: ( ID )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==ID))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:30:26: ID
					{
					DebugLocation(30, 26);
					Match(input,ID,Follow._ID_in_objectMember221); 

					}
					break;

				}
				} finally { DebugExitSubRule(11); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(30, 31);
			PushFollow(Follow._params_in_objectMember225);
			@params();
			PopFollow();

			DebugLocation(30, 38);
			PushFollow(Follow._codeBlock_in_objectMember227);
			codeBlock();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("objectMember", 7);
			LeaveRule("objectMember", 7);
			LeaveRule_objectMember();
		}
		DebugLocation(31, 1);
		} finally { DebugExitRule(GrammarFileName, "objectMember"); }
		return;

	}
	// $ANTLR end "objectMember"

	partial void EnterRule_objectMethod();
	partial void LeaveRule_objectMethod();
	// $ANTLR start "objectMethod"
	// Grammars\\LavishProcessor.g:32:8: public objectMethod : ^( Method ID ^( Returns ( ID )? ) params codeBlock ) ;
	[GrammarRule("objectMethod")]
	public void objectMethod()
	{
		EnterRule_objectMethod();
		EnterRule("objectMethod", 8);
		TraceIn("objectMethod", 8);
		try { DebugEnterRule(GrammarFileName, "objectMethod");
		DebugLocation(32, 1);
		try
		{
			// Grammars\\LavishProcessor.g:33:2: ( ^( Method ID ^( Returns ( ID )? ) params codeBlock ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:33:4: ^( Method ID ^( Returns ( ID )? ) params codeBlock )
			{
			DebugLocation(33, 4);
			DebugLocation(33, 6);
			Match(input,Method,Follow._Method_in_objectMethod241); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(33, 13);
			Match(input,ID,Follow._ID_in_objectMethod243); 
			DebugLocation(33, 16);
			DebugLocation(33, 18);
			Match(input,Returns,Follow._Returns_in_objectMethod246); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(33, 26);
				// Grammars\\LavishProcessor.g:33:26: ( ID )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==ID))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:33:26: ID
					{
					DebugLocation(33, 26);
					Match(input,ID,Follow._ID_in_objectMethod248); 

					}
					break;

				}
				} finally { DebugExitSubRule(12); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(33, 31);
			PushFollow(Follow._params_in_objectMethod252);
			@params();
			PopFollow();

			DebugLocation(33, 38);
			PushFollow(Follow._codeBlock_in_objectMethod254);
			codeBlock();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("objectMethod", 8);
			LeaveRule("objectMethod", 8);
			LeaveRule_objectMethod();
		}
		DebugLocation(34, 1);
		} finally { DebugExitRule(GrammarFileName, "objectMethod"); }
		return;

	}
	// $ANTLR end "objectMethod"

	partial void EnterRule_params();
	partial void LeaveRule_params();
	// $ANTLR start "params"
	// Grammars\\LavishProcessor.g:35:8: public params : ( ^( Params ^( Param Elipse ID ) ) | ^( Params ( ^( Param ^( Type ( ID )? ) ) ^( ID ^( Assign value ) ) )* ) );
	[GrammarRule("params")]
	public void @params()
	{
		EnterRule_params();
		EnterRule("params", 9);
		TraceIn("params", 9);
		try { DebugEnterRule(GrammarFileName, "params");
		DebugLocation(35, 1);
		try
		{
			// Grammars\\LavishProcessor.g:36:2: ( ^( Params ^( Param Elipse ID ) ) | ^( Params ( ^( Param ^( Type ( ID )? ) ) ^( ID ^( Assign value ) ) )* ) )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==Params))
			{
				int LA15_2 = input.LA(2);

				if ((LA15_2==DOWN))
				{
					int LA15_3 = input.LA(3);

					if ((LA15_3==Param))
					{
						int LA15_4 = input.LA(4);

						if ((LA15_4==DOWN))
						{
							int LA15_5 = input.LA(5);

							if ((LA15_5==Elipse))
							{
								alt15 = 1;
							}
							else if ((LA15_5==Type))
							{
								alt15 = 2;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 15, 5, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 15, 3, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA15_3==UP))
					{
						alt15 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 15, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 15, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:36:4: ^( Params ^( Param Elipse ID ) )
				{
				DebugLocation(36, 4);
				DebugLocation(36, 6);
				Match(input,Params,Follow._Params_in_params268); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(36, 13);
				DebugLocation(36, 15);
				Match(input,Param,Follow._Param_in_params271); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(36, 21);
				Match(input,Elipse,Follow._Elipse_in_params273); 
				DebugLocation(36, 28);
				Match(input,ID,Follow._ID_in_params275); 

				Match(input, TokenTypes.Up, null); 


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:37:4: ^( Params ( ^( Param ^( Type ( ID )? ) ) ^( ID ^( Assign value ) ) )* )
				{
				DebugLocation(37, 4);
				DebugLocation(37, 6);
				Match(input,Params,Follow._Params_in_params283); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(37, 13);
					// Grammars\\LavishProcessor.g:37:13: ( ^( Param ^( Type ( ID )? ) ) ^( ID ^( Assign value ) ) )*
					try { DebugEnterSubRule(14);
					while (true)
					{
						int alt14=2;
						try { DebugEnterDecision(14, false);
						int LA14_1 = input.LA(1);

						if ((LA14_1==Param))
						{
							alt14 = 1;
						}


						} finally { DebugExitDecision(14); }
						switch ( alt14 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LavishProcessor.g:37:14: ^( Param ^( Type ( ID )? ) ) ^( ID ^( Assign value ) )
							{
							DebugLocation(37, 14);
							DebugLocation(37, 16);
							Match(input,Param,Follow._Param_in_params287); 

							Match(input, TokenTypes.Down, null); 
							DebugLocation(37, 22);
							DebugLocation(37, 24);
							Match(input,Type,Follow._Type_in_params290); 

							if (input.LA(1) == TokenTypes.Down)
							{
								Match(input, TokenTypes.Down, null); 
								DebugLocation(37, 29);
								// Grammars\\LavishProcessor.g:37:29: ( ID )?
								int alt13=2;
								try { DebugEnterSubRule(13);
								try { DebugEnterDecision(13, false);
								int LA13_1 = input.LA(1);

								if ((LA13_1==ID))
								{
									alt13 = 1;
								}
								} finally { DebugExitDecision(13); }
								switch (alt13)
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\LavishProcessor.g:37:29: ID
									{
									DebugLocation(37, 29);
									Match(input,ID,Follow._ID_in_params292); 

									}
									break;

								}
								} finally { DebugExitSubRule(13); }


								Match(input, TokenTypes.Up, null); 
							}


							Match(input, TokenTypes.Up, null); 

							DebugLocation(37, 35);
							DebugLocation(37, 37);
							Match(input,ID,Follow._ID_in_params298); 

							Match(input, TokenTypes.Down, null); 
							DebugLocation(37, 40);
							DebugLocation(37, 42);
							Match(input,Assign,Follow._Assign_in_params301); 

							Match(input, TokenTypes.Down, null); 
							DebugLocation(37, 49);
							PushFollow(Follow._value_in_params303);
							value();
							PopFollow();


							Match(input, TokenTypes.Up, null); 


							Match(input, TokenTypes.Up, null); 


							}
							break;

						default:
							goto loop14;
						}
					}

					loop14:
						;

					} finally { DebugExitSubRule(14); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("params", 9);
			LeaveRule("params", 9);
			LeaveRule_params();
		}
		DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "params"); }
		return;

	}
	// $ANTLR end "params"

	partial void EnterRule_value();
	partial void LeaveRule_value();
	// $ANTLR start "value"
	// Grammars\\LavishProcessor.g:39:8: public value : ( ID | dataSequence | string | INT | FLOAT | (~ ( WS | NewLine ) ) );
	[GrammarRule("value")]
	public void value()
	{
		EnterRule_value();
		EnterRule("value", 10);
		TraceIn("value", 10);
		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(39, 1);
		try
		{
			// Grammars\\LavishProcessor.g:40:2: ( ID | dataSequence | string | INT | FLOAT | (~ ( WS | NewLine ) ) )
			int alt16=6;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt16 = 1;
				}
				break;
			case Dollar:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==DOWN))
				{
					alt16 = 2;
				}
				else if ((LA16_2==UP))
				{
					alt16 = 6;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case STRING:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==DOWN))
				{
					alt16 = 3;
				}
				else if ((LA16_2==UP))
				{
					alt16 = 6;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				alt16 = 4;
				}
				break;
			case FLOAT:
				{
				alt16 = 5;
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case Band:
			case Bnegate:
			case Bor:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Div:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LParen:
			case LSquare:
			case LeftShift:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Minus:
			case Modu:
			case Mult:
			case Negate:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case Plus:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case Quote:
			case RCurly:
			case RParen:
			case RSquare:
			case Returns:
			case RightShift:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case While:
			case Xor:
				{
				alt16 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:40:4: ID
				{
				DebugLocation(40, 4);
				Match(input,ID,Follow._ID_in_value320); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:40:7: dataSequence
				{
				DebugLocation(40, 7);
				PushFollow(Follow._dataSequence_in_value322);
				dataSequence();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:40:20: string
				{
				DebugLocation(40, 20);
				PushFollow(Follow._string_in_value324);
				@string();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:40:27: INT
				{
				DebugLocation(40, 27);
				Match(input,INT,Follow._INT_in_value326); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishProcessor.g:40:31: FLOAT
				{
				DebugLocation(40, 31);
				Match(input,FLOAT,Follow._FLOAT_in_value328); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishProcessor.g:40:37: (~ ( WS | NewLine ) )
				{
				DebugLocation(40, 37);
				if ((input.LA(1)>=ARG && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=VariableCase)||(input.LA(1)>=While && input.LA(1)<=Xor))
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("value", 10);
			LeaveRule("value", 10);
			LeaveRule_value();
		}
		DebugLocation(41, 1);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return;

	}
	// $ANTLR end "value"

	partial void EnterRule_dataSequence();
	partial void LeaveRule_dataSequence();
	// $ANTLR start "dataSequence"
	// Grammars\\LavishProcessor.g:42:8: public dataSequence : ^( Dollar accessor ( member )? ) ;
	[GrammarRule("dataSequence")]
	public void dataSequence()
	{
		EnterRule_dataSequence();
		EnterRule("dataSequence", 11);
		TraceIn("dataSequence", 11);
		try { DebugEnterRule(GrammarFileName, "dataSequence");
		DebugLocation(42, 1);
		try
		{
			// Grammars\\LavishProcessor.g:43:2: ( ^( Dollar accessor ( member )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:43:4: ^( Dollar accessor ( member )? )
			{
			DebugLocation(43, 4);
			DebugLocation(43, 6);
			Match(input,Dollar,Follow._Dollar_in_dataSequence350); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(43, 13);
			PushFollow(Follow._accessor_in_dataSequence352);
			accessor();
			PopFollow();

			DebugLocation(43, 22);
			// Grammars\\LavishProcessor.g:43:22: ( member )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==Colon||LA17_1==Dot))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:43:22: member
				{
				DebugLocation(43, 22);
				PushFollow(Follow._member_in_dataSequence354);
				member();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("dataSequence", 11);
			LeaveRule("dataSequence", 11);
			LeaveRule_dataSequence();
		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "dataSequence"); }
		return;

	}
	// $ANTLR end "dataSequence"

	partial void EnterRule_accessor();
	partial void LeaveRule_accessor();
	// $ANTLR start "accessor"
	// Grammars\\LavishProcessor.g:45:8: public accessor : id ( indexer | typeCast )* ;
	[GrammarRule("accessor")]
	public void accessor()
	{
		EnterRule_accessor();
		EnterRule("accessor", 12);
		TraceIn("accessor", 12);
		try { DebugEnterRule(GrammarFileName, "accessor");
		DebugLocation(45, 1);
		try
		{
			// Grammars\\LavishProcessor.g:46:2: ( id ( indexer | typeCast )* )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:46:4: id ( indexer | typeCast )*
			{
			DebugLocation(46, 4);
			PushFollow(Follow._id_in_accessor368);
			id();
			PopFollow();

			DebugLocation(46, 7);
			// Grammars\\LavishProcessor.g:46:7: ( indexer | typeCast )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=3;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==LSquare))
				{
					alt18 = 1;
				}
				else if ((LA18_1==LParen))
				{
					alt18 = 2;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:46:8: indexer
					{
					DebugLocation(46, 8);
					PushFollow(Follow._indexer_in_accessor371);
					indexer();
					PopFollow();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishProcessor.g:46:16: typeCast
					{
					DebugLocation(46, 16);
					PushFollow(Follow._typeCast_in_accessor373);
					typeCast();
					PopFollow();


					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("accessor", 12);
			LeaveRule("accessor", 12);
			LeaveRule_accessor();
		}
		DebugLocation(47, 1);
		} finally { DebugExitRule(GrammarFileName, "accessor"); }
		return;

	}
	// $ANTLR end "accessor"

	partial void EnterRule_id();
	partial void LeaveRule_id();
	// $ANTLR start "id"
	// Grammars\\LavishProcessor.g:48:8: public id : ( ^( ID ( id )? ) | dataSequence ( id )? );
	[GrammarRule("id")]
	public void id()
	{
		EnterRule_id();
		EnterRule("id", 13);
		TraceIn("id", 13);
		try { DebugEnterRule(GrammarFileName, "id");
		DebugLocation(48, 1);
		try
		{
			// Grammars\\LavishProcessor.g:49:2: ( ^( ID ( id )? ) | dataSequence ( id )? )
			int alt21=2;
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==ID))
			{
				alt21 = 1;
			}
			else if ((LA21_1==Dollar))
			{
				alt21 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:49:4: ^( ID ( id )? )
				{
				DebugLocation(49, 4);
				DebugLocation(49, 6);
				Match(input,ID,Follow._ID_in_id388); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(49, 9);
					// Grammars\\LavishProcessor.g:49:9: ( id )?
					int alt19=2;
					try { DebugEnterSubRule(19);
					try { DebugEnterDecision(19, false);
					int LA19_1 = input.LA(1);

					if ((LA19_1==Dollar||LA19_1==ID))
					{
						alt19 = 1;
					}
					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:49:9: id
						{
						DebugLocation(49, 9);
						PushFollow(Follow._id_in_id390);
						id();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(19); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:50:4: dataSequence ( id )?
				{
				DebugLocation(50, 4);
				PushFollow(Follow._dataSequence_in_id397);
				dataSequence();
				PopFollow();

				DebugLocation(50, 17);
				// Grammars\\LavishProcessor.g:50:17: ( id )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==Dollar||LA20_1==ID))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:50:17: id
					{
					DebugLocation(50, 17);
					PushFollow(Follow._id_in_id399);
					id();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(20); }


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("id", 13);
			LeaveRule("id", 13);
			LeaveRule_id();
		}
		DebugLocation(51, 1);
		} finally { DebugExitRule(GrammarFileName, "id"); }
		return;

	}
	// $ANTLR end "id"

	partial void EnterRule_typeCast();
	partial void LeaveRule_typeCast();
	// $ANTLR start "typeCast"
	// Grammars\\LavishProcessor.g:52:8: public typeCast : ^( LParen id ) ;
	[GrammarRule("typeCast")]
	public void typeCast()
	{
		EnterRule_typeCast();
		EnterRule("typeCast", 14);
		TraceIn("typeCast", 14);
		try { DebugEnterRule(GrammarFileName, "typeCast");
		DebugLocation(52, 1);
		try
		{
			// Grammars\\LavishProcessor.g:53:2: ( ^( LParen id ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:53:4: ^( LParen id )
			{
			DebugLocation(53, 4);
			DebugLocation(53, 6);
			Match(input,LParen,Follow._LParen_in_typeCast413); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(53, 13);
			PushFollow(Follow._id_in_typeCast415);
			id();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("typeCast", 14);
			LeaveRule("typeCast", 14);
			LeaveRule_typeCast();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "typeCast"); }
		return;

	}
	// $ANTLR end "typeCast"

	partial void EnterRule_member();
	partial void LeaveRule_member();
	// $ANTLR start "member"
	// Grammars\\LavishProcessor.g:55:8: public member : ( ^( Dot accessor ( member )? ) | ^( Colon accessor ( member )? ) );
	[GrammarRule("member")]
	public void member()
	{
		EnterRule_member();
		EnterRule("member", 15);
		TraceIn("member", 15);
		try { DebugEnterRule(GrammarFileName, "member");
		DebugLocation(55, 1);
		try
		{
			// Grammars\\LavishProcessor.g:56:2: ( ^( Dot accessor ( member )? ) | ^( Colon accessor ( member )? ) )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==Dot))
			{
				alt24 = 1;
			}
			else if ((LA24_1==Colon))
			{
				alt24 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:56:4: ^( Dot accessor ( member )? )
				{
				DebugLocation(56, 4);
				DebugLocation(56, 6);
				Match(input,Dot,Follow._Dot_in_member429); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(56, 10);
				PushFollow(Follow._accessor_in_member431);
				accessor();
				PopFollow();

				DebugLocation(56, 19);
				// Grammars\\LavishProcessor.g:56:19: ( member )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==Colon||LA22_1==Dot))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:56:19: member
					{
					DebugLocation(56, 19);
					PushFollow(Follow._member_in_member433);
					member();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(22); }


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:57:4: ^( Colon accessor ( member )? )
				{
				DebugLocation(57, 4);
				DebugLocation(57, 6);
				Match(input,Colon,Follow._Colon_in_member441); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(57, 12);
				PushFollow(Follow._accessor_in_member443);
				accessor();
				PopFollow();

				DebugLocation(57, 21);
				// Grammars\\LavishProcessor.g:57:21: ( member )?
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==Colon||LA23_1==Dot))
				{
					alt23 = 1;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:57:21: member
					{
					DebugLocation(57, 21);
					PushFollow(Follow._member_in_member445);
					member();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(23); }


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("member", 15);
			LeaveRule("member", 15);
			LeaveRule_member();
		}
		DebugLocation(58, 1);
		} finally { DebugExitRule(GrammarFileName, "member"); }
		return;

	}
	// $ANTLR end "member"

	partial void EnterRule_string();
	partial void LeaveRule_string();
	// $ANTLR start "string"
	// Grammars\\LavishProcessor.g:59:8: public string : ^( STRING ( dataSequence | quoteString )* ) ;
	[GrammarRule("string")]
	public void @string()
	{
		EnterRule_string();
		EnterRule("string", 16);
		TraceIn("string", 16);
		try { DebugEnterRule(GrammarFileName, "string");
		DebugLocation(59, 1);
		try
		{
			// Grammars\\LavishProcessor.g:60:2: ( ^( STRING ( dataSequence | quoteString )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:60:4: ^( STRING ( dataSequence | quoteString )* )
			{
			DebugLocation(60, 4);
			DebugLocation(60, 6);
			Match(input,STRING,Follow._STRING_in_string460); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(60, 13);
				// Grammars\\LavishProcessor.g:60:13: ( dataSequence | quoteString )*
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=3;
					try { DebugEnterDecision(25, false);
					int LA25_1 = input.LA(1);

					if ((LA25_1==Dollar))
					{
						int LA25_2 = input.LA(2);

						if ((LA25_2==DOWN))
						{
							alt25 = 1;
						}
						else if (((LA25_2>=UP && LA25_2<=PreIf)||(LA25_2>=RCurly && LA25_2<=Xor)))
						{
							alt25 = 2;
						}


					}
					else if (((LA25_1>=ARG && LA25_1<=Do)||(LA25_1>=Dot && LA25_1<=PreIf)||(LA25_1>=RCurly && LA25_1<=Xor)))
					{
						alt25 = 2;
					}


					} finally { DebugExitDecision(25); }
					switch ( alt25 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:60:14: dataSequence
						{
						DebugLocation(60, 14);
						PushFollow(Follow._dataSequence_in_string463);
						dataSequence();
						PopFollow();


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\LavishProcessor.g:60:27: quoteString
						{
						DebugLocation(60, 27);
						PushFollow(Follow._quoteString_in_string465);
						quoteString();
						PopFollow();


						}
						break;

					default:
						goto loop25;
					}
				}

				loop25:
					;

				} finally { DebugExitSubRule(25); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("string", 16);
			LeaveRule("string", 16);
			LeaveRule_string();
		}
		DebugLocation(61, 1);
		} finally { DebugExitRule(GrammarFileName, "string"); }
		return;

	}
	// $ANTLR end "string"

	partial void EnterRule_quoteString();
	partial void LeaveRule_quoteString();
	// $ANTLR start "quoteString"
	// Grammars\\LavishProcessor.g:62:8: public quoteString : ~ ( Quote ) ;
	[GrammarRule("quoteString")]
	public void quoteString()
	{
		EnterRule_quoteString();
		EnterRule("quoteString", 17);
		TraceIn("quoteString", 17);
		try { DebugEnterRule(GrammarFileName, "quoteString");
		DebugLocation(62, 1);
		try
		{
			// Grammars\\LavishProcessor.g:63:2: (~ ( Quote ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:
			{
			DebugLocation(63, 2);
			if ((input.LA(1)>=ARG && input.LA(1)<=PreIf)||(input.LA(1)>=RCurly && input.LA(1)<=Xor))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("quoteString", 17);
			LeaveRule("quoteString", 17);
			LeaveRule_quoteString();
		}
		DebugLocation(64, 1);
		} finally { DebugExitRule(GrammarFileName, "quoteString"); }
		return;

	}
	// $ANTLR end "quoteString"

	partial void EnterRule_math();
	partial void LeaveRule_math();
	// $ANTLR start "math"
	// Grammars\\LavishProcessor.g:65:8: public math : ( ^( Bor math math ) | ^( Xor math math ) | ^( Band math math ) | ^( LeftShift math math ) | ^( RightShift math math ) | ^( Plus math math ) | ^( Minus math math ) | ^( Mult math math ) | ^( Div math math ) | ^( Modu math math ) | ^( Bnegate math math ) | INT | FLOAT | dataSequence );
	[GrammarRule("math")]
	public void math()
	{
		EnterRule_math();
		EnterRule("math", 18);
		TraceIn("math", 18);
		try { DebugEnterRule(GrammarFileName, "math");
		DebugLocation(65, 1);
		try
		{
			// Grammars\\LavishProcessor.g:66:2: ( ^( Bor math math ) | ^( Xor math math ) | ^( Band math math ) | ^( LeftShift math math ) | ^( RightShift math math ) | ^( Plus math math ) | ^( Minus math math ) | ^( Mult math math ) | ^( Div math math ) | ^( Modu math math ) | ^( Bnegate math math ) | INT | FLOAT | dataSequence )
			int alt26=14;
			try { DebugEnterDecision(26, false);
			switch (input.LA(1))
			{
			case Bor:
				{
				alt26 = 1;
				}
				break;
			case Xor:
				{
				alt26 = 2;
				}
				break;
			case Band:
				{
				alt26 = 3;
				}
				break;
			case LeftShift:
				{
				alt26 = 4;
				}
				break;
			case RightShift:
				{
				alt26 = 5;
				}
				break;
			case Plus:
				{
				alt26 = 6;
				}
				break;
			case Minus:
				{
				alt26 = 7;
				}
				break;
			case Mult:
				{
				alt26 = 8;
				}
				break;
			case Div:
				{
				alt26 = 9;
				}
				break;
			case Modu:
				{
				alt26 = 10;
				}
				break;
			case Bnegate:
				{
				alt26 = 11;
				}
				break;
			case INT:
				{
				alt26 = 12;
				}
				break;
			case FLOAT:
				{
				alt26 = 13;
				}
				break;
			case Dollar:
				{
				alt26 = 14;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:66:4: ^( Bor math math )
				{
				DebugLocation(66, 4);
				DebugLocation(66, 6);
				Match(input,Bor,Follow._Bor_in_math496); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(66, 10);
				PushFollow(Follow._math_in_math498);
				math();
				PopFollow();

				DebugLocation(66, 15);
				PushFollow(Follow._math_in_math500);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:67:4: ^( Xor math math )
				{
				DebugLocation(67, 4);
				DebugLocation(67, 6);
				Match(input,Xor,Follow._Xor_in_math507); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(67, 10);
				PushFollow(Follow._math_in_math509);
				math();
				PopFollow();

				DebugLocation(67, 15);
				PushFollow(Follow._math_in_math511);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:68:4: ^( Band math math )
				{
				DebugLocation(68, 4);
				DebugLocation(68, 6);
				Match(input,Band,Follow._Band_in_math518); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(68, 11);
				PushFollow(Follow._math_in_math520);
				math();
				PopFollow();

				DebugLocation(68, 16);
				PushFollow(Follow._math_in_math522);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:69:4: ^( LeftShift math math )
				{
				DebugLocation(69, 4);
				DebugLocation(69, 6);
				Match(input,LeftShift,Follow._LeftShift_in_math529); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(69, 16);
				PushFollow(Follow._math_in_math531);
				math();
				PopFollow();

				DebugLocation(69, 21);
				PushFollow(Follow._math_in_math533);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishProcessor.g:70:4: ^( RightShift math math )
				{
				DebugLocation(70, 4);
				DebugLocation(70, 6);
				Match(input,RightShift,Follow._RightShift_in_math540); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(70, 17);
				PushFollow(Follow._math_in_math542);
				math();
				PopFollow();

				DebugLocation(70, 22);
				PushFollow(Follow._math_in_math544);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishProcessor.g:71:4: ^( Plus math math )
				{
				DebugLocation(71, 4);
				DebugLocation(71, 6);
				Match(input,Plus,Follow._Plus_in_math551); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(71, 11);
				PushFollow(Follow._math_in_math553);
				math();
				PopFollow();

				DebugLocation(71, 16);
				PushFollow(Follow._math_in_math555);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LavishProcessor.g:72:4: ^( Minus math math )
				{
				DebugLocation(72, 4);
				DebugLocation(72, 6);
				Match(input,Minus,Follow._Minus_in_math562); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(72, 12);
				PushFollow(Follow._math_in_math564);
				math();
				PopFollow();

				DebugLocation(72, 17);
				PushFollow(Follow._math_in_math566);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LavishProcessor.g:73:4: ^( Mult math math )
				{
				DebugLocation(73, 4);
				DebugLocation(73, 6);
				Match(input,Mult,Follow._Mult_in_math573); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(73, 11);
				PushFollow(Follow._math_in_math575);
				math();
				PopFollow();

				DebugLocation(73, 16);
				PushFollow(Follow._math_in_math577);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LavishProcessor.g:74:4: ^( Div math math )
				{
				DebugLocation(74, 4);
				DebugLocation(74, 6);
				Match(input,Div,Follow._Div_in_math584); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(74, 10);
				PushFollow(Follow._math_in_math586);
				math();
				PopFollow();

				DebugLocation(74, 15);
				PushFollow(Follow._math_in_math588);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\LavishProcessor.g:75:4: ^( Modu math math )
				{
				DebugLocation(75, 4);
				DebugLocation(75, 6);
				Match(input,Modu,Follow._Modu_in_math595); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(75, 11);
				PushFollow(Follow._math_in_math597);
				math();
				PopFollow();

				DebugLocation(75, 16);
				PushFollow(Follow._math_in_math599);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammars\\LavishProcessor.g:76:4: ^( Bnegate math math )
				{
				DebugLocation(76, 4);
				DebugLocation(76, 6);
				Match(input,Bnegate,Follow._Bnegate_in_math606); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(76, 14);
				PushFollow(Follow._math_in_math608);
				math();
				PopFollow();

				DebugLocation(76, 19);
				PushFollow(Follow._math_in_math610);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammars\\LavishProcessor.g:77:4: INT
				{
				DebugLocation(77, 4);
				Match(input,INT,Follow._INT_in_math616); 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Grammars\\LavishProcessor.g:78:4: FLOAT
				{
				DebugLocation(78, 4);
				Match(input,FLOAT,Follow._FLOAT_in_math621); 

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Grammars\\LavishProcessor.g:79:4: dataSequence
				{
				DebugLocation(79, 4);
				PushFollow(Follow._dataSequence_in_math626);
				dataSequence();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("math", 18);
			LeaveRule("math", 18);
			LeaveRule_math();
		}
		DebugLocation(80, 1);
		} finally { DebugExitRule(GrammarFileName, "math"); }
		return;

	}
	// $ANTLR end "math"

	partial void EnterRule_commaVals();
	partial void LeaveRule_commaVals();
	// $ANTLR start "commaVals"
	// Grammars\\LavishProcessor.g:81:8: public commaVals : ( commaArg )+ ;
	[GrammarRule("commaVals")]
	public void commaVals()
	{
		EnterRule_commaVals();
		EnterRule("commaVals", 19);
		TraceIn("commaVals", 19);
		try { DebugEnterRule(GrammarFileName, "commaVals");
		DebugLocation(81, 1);
		try
		{
			// Grammars\\LavishProcessor.g:82:2: ( ( commaArg )+ )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:82:4: ( commaArg )+
			{
			DebugLocation(82, 4);
			// Grammars\\LavishProcessor.g:82:4: ( commaArg )+
			int cnt27=0;
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if (((LA27_1>=ARG && LA27_1<=Colon)||(LA27_1>=Comparer && LA27_1<=RParen)||(LA27_1>=Returns && LA27_1<=Xor)))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:82:4: commaArg
					{
					DebugLocation(82, 4);
					PushFollow(Follow._commaArg_in_commaVals638);
					commaArg();
					PopFollow();


					}
					break;

				default:
					if (cnt27 >= 1)
						goto loop27;

					EarlyExitException eee27 = new EarlyExitException( 27, input );
					DebugRecognitionException(eee27);
					throw eee27;
				}
				cnt27++;
			}
			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("commaVals", 19);
			LeaveRule("commaVals", 19);
			LeaveRule_commaVals();
		}
		DebugLocation(83, 1);
		} finally { DebugExitRule(GrammarFileName, "commaVals"); }
		return;

	}
	// $ANTLR end "commaVals"

	partial void EnterRule_commaArg();
	partial void LeaveRule_commaArg();
	// $ANTLR start "commaArg"
	// Grammars\\LavishProcessor.g:85:8: public commaArg : ( ID | string | math |~ ( Comma | RSquare ) );
	[GrammarRule("commaArg")]
	public void commaArg()
	{
		EnterRule_commaArg();
		EnterRule("commaArg", 20);
		TraceIn("commaArg", 20);
		try { DebugEnterRule(GrammarFileName, "commaArg");
		DebugLocation(85, 1);
		try
		{
			// Grammars\\LavishProcessor.g:86:2: ( ID | string | math |~ ( Comma | RSquare ) )
			int alt28=4;
			try { DebugEnterDecision(28, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt28 = 1;
				}
				break;
			case STRING:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 2;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Bor:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Xor:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Band:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LeftShift:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RightShift:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Plus:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Minus:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Mult:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Div:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Modu:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Bnegate:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 13, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				alt28 = 3;
				}
				break;
			case FLOAT:
				{
				alt28 = 3;
				}
				break;
			case Dollar:
				{
				int LA28_2 = input.LA(2);

				if ((LA28_2==DOWN))
				{
					alt28 = 3;
				}
				else if ((LA28_2==EOF||(LA28_2>=UP && LA28_2<=Colon)||(LA28_2>=Comparer && LA28_2<=RParen)||(LA28_2>=Returns && LA28_2<=Xor)))
				{
					alt28 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 16, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LParen:
			case LSquare:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Negate:
			case NewLine:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case Quote:
			case RCurly:
			case RParen:
			case Returns:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
				{
				alt28 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:86:4: ID
				{
				DebugLocation(86, 4);
				Match(input,ID,Follow._ID_in_commaArg652); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:87:4: string
				{
				DebugLocation(87, 4);
				PushFollow(Follow._string_in_commaArg657);
				@string();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:88:4: math
				{
				DebugLocation(88, 4);
				PushFollow(Follow._math_in_commaArg662);
				math();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:89:4: ~ ( Comma | RSquare )
				{
				DebugLocation(89, 4);
				if ((input.LA(1)>=ARG && input.LA(1)<=Colon)||(input.LA(1)>=Comparer && input.LA(1)<=RParen)||(input.LA(1)>=Returns && input.LA(1)<=Xor))
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("commaArg", 20);
			LeaveRule("commaArg", 20);
			LeaveRule_commaArg();
		}
		DebugLocation(90, 1);
		} finally { DebugExitRule(GrammarFileName, "commaArg"); }
		return;

	}
	// $ANTLR end "commaArg"

	partial void EnterRule_command();
	partial void LeaveRule_command();
	// $ANTLR start "command"
	// Grammars\\LavishProcessor.g:91:8: public command : ( ^( DataCommand dataCommand ) | ^( COMMAND ID ( commandArg )* ) | ^( COMMAND dataSequence ( commandArg )* ) );
	[GrammarRule("command")]
	public void command()
	{
		EnterRule_command();
		EnterRule("command", 21);
		TraceIn("command", 21);
		try { DebugEnterRule(GrammarFileName, "command");
		DebugLocation(91, 1);
		try
		{
			// Grammars\\LavishProcessor.g:92:2: ( ^( DataCommand dataCommand ) | ^( COMMAND ID ( commandArg )* ) | ^( COMMAND dataSequence ( commandArg )* ) )
			int alt31=3;
			try { DebugEnterDecision(31, false);
			int LA31_1 = input.LA(1);

			if ((LA31_1==DataCommand))
			{
				alt31 = 1;
			}
			else if ((LA31_1==COMMAND))
			{
				int LA31_2 = input.LA(2);

				if ((LA31_2==DOWN))
				{
					int LA31_3 = input.LA(3);

					if ((LA31_3==ID))
					{
						alt31 = 2;
					}
					else if ((LA31_3==Dollar))
					{
						alt31 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 31, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 31, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:92:4: ^( DataCommand dataCommand )
				{
				DebugLocation(92, 4);
				DebugLocation(92, 6);
				Match(input,DataCommand,Follow._DataCommand_in_command685); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(92, 18);
				PushFollow(Follow._dataCommand_in_command687);
				dataCommand();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:93:4: ^( COMMAND ID ( commandArg )* )
				{
				DebugLocation(93, 4);
				DebugLocation(93, 6);
				Match(input,COMMAND,Follow._COMMAND_in_command694); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(93, 14);
				Match(input,ID,Follow._ID_in_command696); 
				DebugLocation(93, 17);
				// Grammars\\LavishProcessor.g:93:17: ( commandArg )*
				try { DebugEnterSubRule(29);
				while (true)
				{
					int alt29=2;
					try { DebugEnterDecision(29, false);
					int LA29_1 = input.LA(1);

					if (((LA29_1>=ARG && LA29_1<=Negate)||(LA29_1>=NotEqualTo && LA29_1<=Script)||(LA29_1>=Switch && LA29_1<=Xor)))
					{
						alt29 = 1;
					}


					} finally { DebugExitDecision(29); }
					switch ( alt29 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:93:17: commandArg
						{
						DebugLocation(93, 17);
						PushFollow(Follow._commandArg_in_command698);
						commandArg();
						PopFollow();


						}
						break;

					default:
						goto loop29;
					}
				}

				loop29:
					;

				} finally { DebugExitSubRule(29); }


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:94:4: ^( COMMAND dataSequence ( commandArg )* )
				{
				DebugLocation(94, 4);
				DebugLocation(94, 6);
				Match(input,COMMAND,Follow._COMMAND_in_command706); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(94, 14);
				PushFollow(Follow._dataSequence_in_command708);
				dataSequence();
				PopFollow();

				DebugLocation(94, 27);
				// Grammars\\LavishProcessor.g:94:27: ( commandArg )*
				try { DebugEnterSubRule(30);
				while (true)
				{
					int alt30=2;
					try { DebugEnterDecision(30, false);
					int LA30_1 = input.LA(1);

					if (((LA30_1>=ARG && LA30_1<=Negate)||(LA30_1>=NotEqualTo && LA30_1<=Script)||(LA30_1>=Switch && LA30_1<=Xor)))
					{
						alt30 = 1;
					}


					} finally { DebugExitDecision(30); }
					switch ( alt30 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:94:27: commandArg
						{
						DebugLocation(94, 27);
						PushFollow(Follow._commandArg_in_command710);
						commandArg();
						PopFollow();


						}
						break;

					default:
						goto loop30;
					}
				}

				loop30:
					;

				} finally { DebugExitSubRule(30); }


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("command", 21);
			LeaveRule("command", 21);
			LeaveRule_command();
		}
		DebugLocation(95, 1);
		} finally { DebugExitRule(GrammarFileName, "command"); }
		return;

	}
	// $ANTLR end "command"

	partial void EnterRule_dataCommand();
	partial void LeaveRule_dataCommand();
	// $ANTLR start "dataCommand"
	// Grammars\\LavishProcessor.g:97:8: public dataCommand : accessor member ;
	[GrammarRule("dataCommand")]
	public void dataCommand()
	{
		EnterRule_dataCommand();
		EnterRule("dataCommand", 22);
		TraceIn("dataCommand", 22);
		try { DebugEnterRule(GrammarFileName, "dataCommand");
		DebugLocation(97, 1);
		try
		{
			// Grammars\\LavishProcessor.g:98:2: ( accessor member )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:98:4: accessor member
			{
			DebugLocation(98, 4);
			PushFollow(Follow._accessor_in_dataCommand725);
			accessor();
			PopFollow();

			DebugLocation(98, 13);
			PushFollow(Follow._member_in_dataCommand727);
			member();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("dataCommand", 22);
			LeaveRule("dataCommand", 22);
			LeaveRule_dataCommand();
		}
		DebugLocation(99, 1);
		} finally { DebugExitRule(GrammarFileName, "dataCommand"); }
		return;

	}
	// $ANTLR end "dataCommand"

	partial void EnterRule_commandArg();
	partial void LeaveRule_commandArg();
	// $ANTLR start "commandArg"
	// Grammars\\LavishProcessor.g:100:8: public commandArg : ( ID | string | math |~ ( NewLine | Semi ) );
	[GrammarRule("commandArg")]
	public void commandArg()
	{
		EnterRule_commandArg();
		EnterRule("commandArg", 23);
		TraceIn("commandArg", 23);
		try { DebugEnterRule(GrammarFileName, "commandArg");
		DebugLocation(100, 1);
		try
		{
			// Grammars\\LavishProcessor.g:101:2: ( ID | string | math |~ ( NewLine | Semi ) )
			int alt32=4;
			try { DebugEnterDecision(32, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt32 = 1;
				}
				break;
			case STRING:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 2;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Bor:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Xor:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Band:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LeftShift:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RightShift:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Plus:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Minus:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Mult:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Div:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Modu:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Bnegate:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 13, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				alt32 = 3;
				}
				break;
			case FLOAT:
				{
				alt32 = 3;
				}
				break;
			case Dollar:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==DOWN))
				{
					alt32 = 3;
				}
				else if (((LA32_2>=UP && LA32_2<=Negate)||(LA32_2>=NotEqualTo && LA32_2<=Script)||(LA32_2>=Switch && LA32_2<=Xor)))
				{
					alt32 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 16, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LParen:
			case LSquare:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Negate:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case Quote:
			case RCurly:
			case RParen:
			case RSquare:
			case Returns:
			case Scope:
			case Script:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
				{
				alt32 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:101:4: ID
				{
				DebugLocation(101, 4);
				Match(input,ID,Follow._ID_in_commandArg739); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:102:4: string
				{
				DebugLocation(102, 4);
				PushFollow(Follow._string_in_commandArg744);
				@string();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:103:4: math
				{
				DebugLocation(103, 4);
				PushFollow(Follow._math_in_commandArg749);
				math();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:104:4: ~ ( NewLine | Semi )
				{
				DebugLocation(104, 4);
				if ((input.LA(1)>=ARG && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=Script)||(input.LA(1)>=Switch && input.LA(1)<=Xor))
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("commandArg", 23);
			LeaveRule("commandArg", 23);
			LeaveRule_commandArg();
		}
		DebugLocation(105, 1);
		} finally { DebugExitRule(GrammarFileName, "commandArg"); }
		return;

	}
	// $ANTLR end "commandArg"

	partial void EnterRule_indexer();
	partial void LeaveRule_indexer();
	// $ANTLR start "indexer"
	// Grammars\\LavishProcessor.g:106:8: public indexer : ^( LSquare ( commaValue )* ) ;
	[GrammarRule("indexer")]
	public void indexer()
	{
		EnterRule_indexer();
		EnterRule("indexer", 24);
		TraceIn("indexer", 24);
		try { DebugEnterRule(GrammarFileName, "indexer");
		DebugLocation(106, 1);
		try
		{
			// Grammars\\LavishProcessor.g:107:2: ( ^( LSquare ( commaValue )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:107:4: ^( LSquare ( commaValue )* )
			{
			DebugLocation(107, 4);
			DebugLocation(107, 6);
			Match(input,LSquare,Follow._LSquare_in_indexer772); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(107, 14);
				// Grammars\\LavishProcessor.g:107:14: ( commaValue )*
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=2;
					try { DebugEnterDecision(33, false);
					int LA33_1 = input.LA(1);

					if ((LA33_1==ARG))
					{
						alt33 = 1;
					}


					} finally { DebugExitDecision(33); }
					switch ( alt33 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:107:14: commaValue
						{
						DebugLocation(107, 14);
						PushFollow(Follow._commaValue_in_indexer774);
						commaValue();
						PopFollow();


						}
						break;

					default:
						goto loop33;
					}
				}

				loop33:
					;

				} finally { DebugExitSubRule(33); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("indexer", 24);
			LeaveRule("indexer", 24);
			LeaveRule_indexer();
		}
		DebugLocation(108, 1);
		} finally { DebugExitRule(GrammarFileName, "indexer"); }
		return;

	}
	// $ANTLR end "indexer"

	partial void EnterRule_commaValue();
	partial void LeaveRule_commaValue();
	// $ANTLR start "commaValue"
	// Grammars\\LavishProcessor.g:109:8: public commaValue : ^( ARG ( commaArg )+ ) ;
	[GrammarRule("commaValue")]
	public void commaValue()
	{
		EnterRule_commaValue();
		EnterRule("commaValue", 25);
		TraceIn("commaValue", 25);
		try { DebugEnterRule(GrammarFileName, "commaValue");
		DebugLocation(109, 1);
		try
		{
			// Grammars\\LavishProcessor.g:110:2: ( ^( ARG ( commaArg )+ ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:110:4: ^( ARG ( commaArg )+ )
			{
			DebugLocation(110, 4);
			DebugLocation(110, 6);
			Match(input,ARG,Follow._ARG_in_commaValue789); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(110, 10);
			// Grammars\\LavishProcessor.g:110:10: ( commaArg )+
			int cnt34=0;
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if (((LA34_1>=ARG && LA34_1<=Colon)||(LA34_1>=Comparer && LA34_1<=RParen)||(LA34_1>=Returns && LA34_1<=Xor)))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch (alt34)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:110:10: commaArg
					{
					DebugLocation(110, 10);
					PushFollow(Follow._commaArg_in_commaValue791);
					commaArg();
					PopFollow();


					}
					break;

				default:
					if (cnt34 >= 1)
						goto loop34;

					EarlyExitException eee34 = new EarlyExitException( 34, input );
					DebugRecognitionException(eee34);
					throw eee34;
				}
				cnt34++;
			}
			loop34:
				;

			} finally { DebugExitSubRule(34); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("commaValue", 25);
			LeaveRule("commaValue", 25);
			LeaveRule_commaValue();
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "commaValue"); }
		return;

	}
	// $ANTLR end "commaValue"

	partial void EnterRule_lineArg();
	partial void LeaveRule_lineArg();
	// $ANTLR start "lineArg"
	// Grammars\\LavishProcessor.g:112:8: public lineArg : ( ID | string | math |~ NewLine );
	[GrammarRule("lineArg")]
	public void lineArg()
	{
		EnterRule_lineArg();
		EnterRule("lineArg", 26);
		TraceIn("lineArg", 26);
		try { DebugEnterRule(GrammarFileName, "lineArg");
		DebugLocation(112, 1);
		try
		{
			// Grammars\\LavishProcessor.g:113:2: ( ID | string | math |~ NewLine )
			int alt35=4;
			try { DebugEnterDecision(35, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt35 = 1;
				}
				break;
			case STRING:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 2;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Bor:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Xor:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Band:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LeftShift:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RightShift:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Plus:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Minus:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Mult:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Div:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Modu:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Bnegate:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 13, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				alt35 = 3;
				}
				break;
			case FLOAT:
				{
				alt35 = 3;
				}
				break;
			case Dollar:
				{
				int LA35_2 = input.LA(2);

				if ((LA35_2==DOWN))
				{
					alt35 = 3;
				}
				else if (((LA35_2>=UP && LA35_2<=Negate)||(LA35_2>=NotEqualTo && LA35_2<=Xor)))
				{
					alt35 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 16, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case Comparer:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LParen:
			case LSquare:
			case LessThan:
			case LessThanEqual:
			case MATH:
			case Macro:
			case Member:
			case Method:
			case Negate:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case Quote:
			case RCurly:
			case RParen:
			case RSquare:
			case Returns:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
				{
				alt35 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 35, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:113:4: ID
				{
				DebugLocation(113, 4);
				Match(input,ID,Follow._ID_in_lineArg805); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:114:4: string
				{
				DebugLocation(114, 4);
				PushFollow(Follow._string_in_lineArg810);
				@string();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:115:4: math
				{
				DebugLocation(115, 4);
				PushFollow(Follow._math_in_lineArg815);
				math();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:116:4: ~ NewLine
				{
				DebugLocation(116, 4);
				if ((input.LA(1)>=ARG && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=Xor))
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("lineArg", 26);
			LeaveRule("lineArg", 26);
			LeaveRule_lineArg();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "lineArg"); }
		return;

	}
	// $ANTLR end "lineArg"

	partial void EnterRule_codeBlock();
	partial void LeaveRule_codeBlock();
	// $ANTLR start "codeBlock"
	// Grammars\\LavishProcessor.g:118:8: public codeBlock : ^( CodeBlock ( expression )* ) ;
	[GrammarRule("codeBlock")]
	public void codeBlock()
	{
		EnterRule_codeBlock();
		EnterRule("codeBlock", 27);
		TraceIn("codeBlock", 27);
		try { DebugEnterRule(GrammarFileName, "codeBlock");
		DebugLocation(118, 1);
		try
		{
			// Grammars\\LavishProcessor.g:119:2: ( ^( CodeBlock ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:119:4: ^( CodeBlock ( expression )* )
			{
			DebugLocation(119, 4);
			DebugLocation(119, 6);
			Match(input,CodeBlock,Follow._CodeBlock_in_codeBlock834); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(119, 16);
				// Grammars\\LavishProcessor.g:119:16: ( expression )*
				try { DebugEnterSubRule(36);
				while (true)
				{
					int alt36=2;
					try { DebugEnterDecision(36, false);
					int LA36_1 = input.LA(1);

					if ((LA36_1==COMMAND||LA36_1==CodeBlock||(LA36_1>=DataCommand && LA36_1<=DeclareVariable)||LA36_1==Define||LA36_1==Do||LA36_1==Echo||LA36_1==Error||LA36_1==For||(LA36_1>=If && LA36_1<=Include)||LA36_1==Macro||LA36_1==PreIf||LA36_1==Switch||(LA36_1>=Unmac && LA36_1<=Variable)||LA36_1==While))
					{
						alt36 = 1;
					}


					} finally { DebugExitDecision(36); }
					switch ( alt36 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:119:16: expression
						{
						DebugLocation(119, 16);
						PushFollow(Follow._expression_in_codeBlock836);
						expression();
						PopFollow();


						}
						break;

					default:
						goto loop36;
					}
				}

				loop36:
					;

				} finally { DebugExitSubRule(36); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("codeBlock", 27);
			LeaveRule("codeBlock", 27);
			LeaveRule_codeBlock();
		}
		DebugLocation(120, 1);
		} finally { DebugExitRule(GrammarFileName, "codeBlock"); }
		return;

	}
	// $ANTLR end "codeBlock"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Grammars\\LavishProcessor.g:121:8: public expression : ( command | declareVariable | preProcessor | variableDeclare | forStatement | doStatement | whileStatement | ifStatement | switchStatement | codeBlock );
	[GrammarRule("expression")]
	public void expression()
	{
		EnterRule_expression();
		EnterRule("expression", 28);
		TraceIn("expression", 28);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(121, 1);
		try
		{
			// Grammars\\LavishProcessor.g:122:2: ( command | declareVariable | preProcessor | variableDeclare | forStatement | doStatement | whileStatement | ifStatement | switchStatement | codeBlock )
			int alt37=10;
			try { DebugEnterDecision(37, false);
			switch (input.LA(1))
			{
			case COMMAND:
			case DataCommand:
				{
				alt37 = 1;
				}
				break;
			case DeclareVariable:
				{
				alt37 = 2;
				}
				break;
			case Define:
			case Echo:
			case Error:
			case IfDef:
			case IfNDef:
			case Include:
			case Macro:
			case PreIf:
			case Unmac:
				{
				alt37 = 3;
				}
				break;
			case Variable:
				{
				alt37 = 4;
				}
				break;
			case For:
				{
				alt37 = 5;
				}
				break;
			case Do:
				{
				alt37 = 6;
				}
				break;
			case While:
				{
				alt37 = 7;
				}
				break;
			case If:
				{
				alt37 = 8;
				}
				break;
			case Switch:
				{
				alt37 = 9;
				}
				break;
			case CodeBlock:
				{
				alt37 = 10;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 37, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:122:4: command
				{
				DebugLocation(122, 4);
				PushFollow(Follow._command_in_expression850);
				command();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:122:12: declareVariable
				{
				DebugLocation(122, 12);
				PushFollow(Follow._declareVariable_in_expression852);
				declareVariable();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:122:28: preProcessor
				{
				DebugLocation(122, 28);
				PushFollow(Follow._preProcessor_in_expression854);
				preProcessor();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:123:5: variableDeclare
				{
				DebugLocation(123, 5);
				PushFollow(Follow._variableDeclare_in_expression860);
				variableDeclare();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishProcessor.g:123:21: forStatement
				{
				DebugLocation(123, 21);
				PushFollow(Follow._forStatement_in_expression862);
				forStatement();
				PopFollow();


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishProcessor.g:124:6: doStatement
				{
				DebugLocation(124, 6);
				PushFollow(Follow._doStatement_in_expression869);
				doStatement();
				PopFollow();


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LavishProcessor.g:124:18: whileStatement
				{
				DebugLocation(124, 18);
				PushFollow(Follow._whileStatement_in_expression871);
				whileStatement();
				PopFollow();


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LavishProcessor.g:124:33: ifStatement
				{
				DebugLocation(124, 33);
				PushFollow(Follow._ifStatement_in_expression873);
				ifStatement();
				PopFollow();


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LavishProcessor.g:124:45: switchStatement
				{
				DebugLocation(124, 45);
				PushFollow(Follow._switchStatement_in_expression875);
				switchStatement();
				PopFollow();


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\LavishProcessor.g:124:61: codeBlock
				{
				DebugLocation(124, 61);
				PushFollow(Follow._codeBlock_in_expression877);
				codeBlock();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 28);
			LeaveRule("expression", 28);
			LeaveRule_expression();
		}
		DebugLocation(125, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return;

	}
	// $ANTLR end "expression"

	partial void EnterRule_declareVariable();
	partial void LeaveRule_declareVariable();
	// $ANTLR start "declareVariable"
	// Grammars\\LavishProcessor.g:126:8: public declareVariable : ^( DeclareVariable ( Scope )? ^( ID ( indexer )? ^( ID ( ^( Assign ( lineArg )* ) )? ) ) ) ;
	[GrammarRule("declareVariable")]
	public void declareVariable()
	{
		EnterRule_declareVariable();
		EnterRule("declareVariable", 29);
		TraceIn("declareVariable", 29);
		try { DebugEnterRule(GrammarFileName, "declareVariable");
		DebugLocation(126, 1);
		try
		{
			// Grammars\\LavishProcessor.g:127:2: ( ^( DeclareVariable ( Scope )? ^( ID ( indexer )? ^( ID ( ^( Assign ( lineArg )* ) )? ) ) ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:127:4: ^( DeclareVariable ( Scope )? ^( ID ( indexer )? ^( ID ( ^( Assign ( lineArg )* ) )? ) ) )
			{
			DebugLocation(127, 4);
			DebugLocation(127, 6);
			Match(input,DeclareVariable,Follow._DeclareVariable_in_declareVariable890); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(127, 22);
			// Grammars\\LavishProcessor.g:127:22: ( Scope )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==Scope))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:127:22: Scope
				{
				DebugLocation(127, 22);
				Match(input,Scope,Follow._Scope_in_declareVariable892); 

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(127, 30);
			DebugLocation(127, 32);
			Match(input,ID,Follow._ID_in_declareVariable897); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(127, 35);
			// Grammars\\LavishProcessor.g:127:35: ( indexer )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==LSquare))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:127:35: indexer
				{
				DebugLocation(127, 35);
				PushFollow(Follow._indexer_in_declareVariable899);
				indexer();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(39); }

			DebugLocation(127, 44);
			DebugLocation(127, 46);
			Match(input,ID,Follow._ID_in_declareVariable903); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(127, 50);
				// Grammars\\LavishProcessor.g:127:50: ( ^( Assign ( lineArg )* ) )?
				int alt41=2;
				try { DebugEnterSubRule(41);
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==Assign))
				{
					alt41 = 1;
				}
				} finally { DebugExitDecision(41); }
				switch (alt41)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:127:51: ^( Assign ( lineArg )* )
					{
					DebugLocation(127, 51);
					DebugLocation(127, 53);
					Match(input,Assign,Follow._Assign_in_declareVariable908); 

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); 
						DebugLocation(127, 60);
						// Grammars\\LavishProcessor.g:127:60: ( lineArg )*
						try { DebugEnterSubRule(40);
						while (true)
						{
							int alt40=2;
							try { DebugEnterDecision(40, false);
							int LA40_1 = input.LA(1);

							if (((LA40_1>=ARG && LA40_1<=Negate)||(LA40_1>=NotEqualTo && LA40_1<=Xor)))
							{
								alt40 = 1;
							}


							} finally { DebugExitDecision(40); }
							switch ( alt40 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\LavishProcessor.g:127:60: lineArg
								{
								DebugLocation(127, 60);
								PushFollow(Follow._lineArg_in_declareVariable910);
								lineArg();
								PopFollow();


								}
								break;

							default:
								goto loop40;
							}
						}

						loop40:
							;

						} finally { DebugExitSubRule(40); }


						Match(input, TokenTypes.Up, null); 
					}


					}
					break;

				}
				} finally { DebugExitSubRule(41); }


				Match(input, TokenTypes.Up, null); 
			}


			Match(input, TokenTypes.Up, null); 


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declareVariable", 29);
			LeaveRule("declareVariable", 29);
			LeaveRule_declareVariable();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "declareVariable"); }
		return;

	}
	// $ANTLR end "declareVariable"

	partial void EnterRule_preProcessor();
	partial void LeaveRule_preProcessor();
	// $ANTLR start "preProcessor"
	// Grammars\\LavishProcessor.g:129:8: public preProcessor : ( include | define | macro | preIf | ifDef | ifNDef | echo | error | unmac );
	[GrammarRule("preProcessor")]
	public void preProcessor()
	{
		EnterRule_preProcessor();
		EnterRule("preProcessor", 30);
		TraceIn("preProcessor", 30);
		try { DebugEnterRule(GrammarFileName, "preProcessor");
		DebugLocation(129, 1);
		try
		{
			// Grammars\\LavishProcessor.g:130:2: ( include | define | macro | preIf | ifDef | ifNDef | echo | error | unmac )
			int alt42=9;
			try { DebugEnterDecision(42, false);
			switch (input.LA(1))
			{
			case Include:
				{
				alt42 = 1;
				}
				break;
			case Define:
				{
				alt42 = 2;
				}
				break;
			case Macro:
				{
				alt42 = 3;
				}
				break;
			case PreIf:
				{
				alt42 = 4;
				}
				break;
			case IfDef:
				{
				alt42 = 5;
				}
				break;
			case IfNDef:
				{
				alt42 = 6;
				}
				break;
			case Echo:
				{
				alt42 = 7;
				}
				break;
			case Error:
				{
				alt42 = 8;
				}
				break;
			case Unmac:
				{
				alt42 = 9;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:130:4: include
				{
				DebugLocation(130, 4);
				PushFollow(Follow._include_in_preProcessor929);
				include();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:131:4: define
				{
				DebugLocation(131, 4);
				PushFollow(Follow._define_in_preProcessor934);
				define();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:132:4: macro
				{
				DebugLocation(132, 4);
				PushFollow(Follow._macro_in_preProcessor939);
				macro();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:133:4: preIf
				{
				DebugLocation(133, 4);
				PushFollow(Follow._preIf_in_preProcessor944);
				preIf();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishProcessor.g:134:4: ifDef
				{
				DebugLocation(134, 4);
				PushFollow(Follow._ifDef_in_preProcessor949);
				ifDef();
				PopFollow();


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishProcessor.g:135:4: ifNDef
				{
				DebugLocation(135, 4);
				PushFollow(Follow._ifNDef_in_preProcessor954);
				ifNDef();
				PopFollow();


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LavishProcessor.g:136:4: echo
				{
				DebugLocation(136, 4);
				PushFollow(Follow._echo_in_preProcessor959);
				echo();
				PopFollow();


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LavishProcessor.g:137:4: error
				{
				DebugLocation(137, 4);
				PushFollow(Follow._error_in_preProcessor964);
				error();
				PopFollow();


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LavishProcessor.g:138:4: unmac
				{
				DebugLocation(138, 4);
				PushFollow(Follow._unmac_in_preProcessor969);
				unmac();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preProcessor", 30);
			LeaveRule("preProcessor", 30);
			LeaveRule_preProcessor();
		}
		DebugLocation(139, 1);
		} finally { DebugExitRule(GrammarFileName, "preProcessor"); }
		return;

	}
	// $ANTLR end "preProcessor"

	partial void EnterRule_include();
	partial void LeaveRule_include();
	// $ANTLR start "include"
	// Grammars\\LavishProcessor.g:140:8: public include : ^( Include string ) ;
	[GrammarRule("include")]
	public void include()
	{
		EnterRule_include();
		EnterRule("include", 31);
		TraceIn("include", 31);
		try { DebugEnterRule(GrammarFileName, "include");
		DebugLocation(140, 1);
		try
		{
			// Grammars\\LavishProcessor.g:141:2: ( ^( Include string ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:141:4: ^( Include string )
			{
			DebugLocation(141, 4);
			DebugLocation(141, 6);
			Match(input,Include,Follow._Include_in_include982); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(141, 14);
			PushFollow(Follow._string_in_include984);
			@string();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("include", 31);
			LeaveRule("include", 31);
			LeaveRule_include();
		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "include"); }
		return;

	}
	// $ANTLR end "include"

	partial void EnterRule_define();
	partial void LeaveRule_define();
	// $ANTLR start "define"
	// Grammars\\LavishProcessor.g:143:8: public define : ^( Define ( ID | INT | string | FLOAT | dataSequence | command | condition )+ ) ;
	[GrammarRule("define")]
	public void define()
	{
		EnterRule_define();
		EnterRule("define", 32);
		TraceIn("define", 32);
		try { DebugEnterRule(GrammarFileName, "define");
		DebugLocation(143, 1);
		try
		{
			// Grammars\\LavishProcessor.g:144:2: ( ^( Define ( ID | INT | string | FLOAT | dataSequence | command | condition )+ ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:144:4: ^( Define ( ID | INT | string | FLOAT | dataSequence | command | condition )+ )
			{
			DebugLocation(144, 4);
			DebugLocation(145, 3);
			Match(input,Define,Follow._Define_in_define1001); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(146, 4);
			// Grammars\\LavishProcessor.g:146:4: ( ID | INT | string | FLOAT | dataSequence | command | condition )+
			int cnt43=0;
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=8;
				try { DebugEnterDecision(43, false);
				switch (input.LA(1))
				{
				case ID:
					{
					alt43 = 1;
					}
					break;
				case INT:
					{
					alt43 = 2;
					}
					break;
				case STRING:
					{
					alt43 = 3;
					}
					break;
				case FLOAT:
					{
					alt43 = 4;
					}
					break;
				case Dollar:
					{
					alt43 = 5;
					}
					break;
				case COMMAND:
				case DataCommand:
					{
					alt43 = 6;
					}
					break;
				case CONDITION:
				case Negate:
					{
					alt43 = 7;
					}
					break;
				}

				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:146:5: ID
					{
					DebugLocation(146, 5);
					Match(input,ID,Follow._ID_in_define1008); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\LavishProcessor.g:147:5: INT
					{
					DebugLocation(147, 5);
					Match(input,INT,Follow._INT_in_define1014); 

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\LavishProcessor.g:148:5: string
					{
					DebugLocation(148, 5);
					PushFollow(Follow._string_in_define1020);
					@string();
					PopFollow();


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammars\\LavishProcessor.g:149:5: FLOAT
					{
					DebugLocation(149, 5);
					Match(input,FLOAT,Follow._FLOAT_in_define1026); 

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammars\\LavishProcessor.g:150:5: dataSequence
					{
					DebugLocation(150, 5);
					PushFollow(Follow._dataSequence_in_define1032);
					dataSequence();
					PopFollow();


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Grammars\\LavishProcessor.g:151:5: command
					{
					DebugLocation(151, 5);
					PushFollow(Follow._command_in_define1038);
					command();
					PopFollow();


					}
					break;
				case 7:
					DebugEnterAlt(7);
					// Grammars\\LavishProcessor.g:152:5: condition
					{
					DebugLocation(152, 5);
					PushFollow(Follow._condition_in_define1044);
					condition();
					PopFollow();


					}
					break;

				default:
					if (cnt43 >= 1)
						goto loop43;

					EarlyExitException eee43 = new EarlyExitException( 43, input );
					DebugRecognitionException(eee43);
					throw eee43;
				}
				cnt43++;
			}
			loop43:
				;

			} finally { DebugExitSubRule(43); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("define", 32);
			LeaveRule("define", 32);
			LeaveRule_define();
		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "define"); }
		return;

	}
	// $ANTLR end "define"

	partial void EnterRule_condition();
	partial void LeaveRule_condition();
	// $ANTLR start "condition"
	// Grammars\\LavishProcessor.g:156:8: public condition : ( ^( Negate condition ) ( orCondition )? ( andCondition )? | ^( CONDITION conditionValue ( orCondition )? ( andCondition )? ) | ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? ) | ^( CONDITION ( orCondition )? ( andCondition )? ) );
	[GrammarRule("condition")]
	public void condition()
	{
		EnterRule_condition();
		EnterRule("condition", 33);
		TraceIn("condition", 33);
		try { DebugEnterRule(GrammarFileName, "condition");
		DebugLocation(156, 1);
		try
		{
			// Grammars\\LavishProcessor.g:157:2: ( ^( Negate condition ) ( orCondition )? ( andCondition )? | ^( CONDITION conditionValue ( orCondition )? ( andCondition )? ) | ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? ) | ^( CONDITION ( orCondition )? ( andCondition )? ) )
			int alt52=4;
			try { DebugEnterDecision(52, false);
			int LA52_1 = input.LA(1);

			if ((LA52_1==Negate))
			{
				alt52 = 1;
			}
			else if ((LA52_1==CONDITION))
			{
				int LA52_2 = input.LA(2);

				if ((LA52_2==DOWN))
				{
					switch (input.LA(3))
					{
					case Comparer:
						{
						alt52 = 3;
						}
						break;
					case ARG:
					case Assign:
					case Atom:
					case Band:
					case Bnegate:
					case Bor:
					case COMMAND:
					case COMMENT:
					case CONDITION:
					case Case:
					case CodeBlock:
					case Colon:
					case Comma:
					case DataCommand:
					case DeclareVariable:
					case Default:
					case Define:
					case Div:
					case Do:
					case Dollar:
					case Dot:
					case ESC_SEQ:
					case EXPONENT:
					case Echo:
					case Elipse:
					case Else:
					case ElseIf:
					case EndIf:
					case EndMac:
					case EqualTo:
					case Error:
					case FLOAT:
					case For:
					case Function:
					case GreaterThan:
					case GreaterThanEqual:
					case HEX_DIGIT:
					case ID:
					case INT:
					case If:
					case IfDef:
					case IfNDef:
					case Include:
					case Inherits:
					case LCurly:
					case LSquare:
					case LeftShift:
					case LessThan:
					case LessThanEqual:
					case MATH:
					case Macro:
					case Member:
					case Method:
					case Minus:
					case Modu:
					case Mult:
					case Negate:
					case NotEqualTo:
					case OCTAL_ESC:
					case ObjectDef:
					case Other:
					case Param:
					case Params:
					case Plus:
					case PreElse:
					case PreElseIf:
					case PreIf:
					case Quote:
					case RCurly:
					case RSquare:
					case Returns:
					case RightShift:
					case STRING:
					case Scope:
					case Script:
					case Semi:
					case Switch:
					case Type:
					case UNICODE_ESC:
					case Unmac:
					case Variable:
					case VariableCase:
					case WS:
					case While:
					case Xor:
						{
						alt52 = 2;
						}
						break;
					case Or:
						{
						int LA52_4 = input.LA(4);

						if ((LA52_4==DOWN))
						{
							alt52 = 4;
						}
						else if ((LA52_4==UP||LA52_4==And||LA52_4==Or))
						{
							alt52 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 52, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case And:
						{
						int LA52_4 = input.LA(4);

						if ((LA52_4==DOWN))
						{
							alt52 = 4;
						}
						else if ((LA52_4==UP||LA52_4==And||LA52_4==Or))
						{
							alt52 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 52, 7, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case UP:
						{
						alt52 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 52, 3, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 52, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:157:4: ^( Negate condition ) ( orCondition )? ( andCondition )?
				{
				DebugLocation(157, 4);
				DebugLocation(157, 6);
				Match(input,Negate,Follow._Negate_in_condition1067); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(157, 13);
				PushFollow(Follow._condition_in_condition1069);
				condition();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(157, 24);
				// Grammars\\LavishProcessor.g:157:24: ( orCondition )?
				int alt44=2;
				try { DebugEnterSubRule(44);
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1==Or))
				{
					alt44 = 1;
				}
				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:157:24: orCondition
					{
					DebugLocation(157, 24);
					PushFollow(Follow._orCondition_in_condition1072);
					orCondition();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(44); }

				DebugLocation(157, 37);
				// Grammars\\LavishProcessor.g:157:37: ( andCondition )?
				int alt45=2;
				try { DebugEnterSubRule(45);
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==And))
				{
					alt45 = 1;
				}
				} finally { DebugExitDecision(45); }
				switch (alt45)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:157:37: andCondition
					{
					DebugLocation(157, 37);
					PushFollow(Follow._andCondition_in_condition1075);
					andCondition();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(45); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:158:4: ^( CONDITION conditionValue ( orCondition )? ( andCondition )? )
				{
				DebugLocation(158, 4);
				DebugLocation(158, 6);
				Match(input,CONDITION,Follow._CONDITION_in_condition1082); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(158, 16);
				PushFollow(Follow._conditionValue_in_condition1084);
				conditionValue();
				PopFollow();

				DebugLocation(158, 31);
				// Grammars\\LavishProcessor.g:158:31: ( orCondition )?
				int alt46=2;
				try { DebugEnterSubRule(46);
				try { DebugEnterDecision(46, false);
				int LA46_1 = input.LA(1);

				if ((LA46_1==Or))
				{
					alt46 = 1;
				}
				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:158:31: orCondition
					{
					DebugLocation(158, 31);
					PushFollow(Follow._orCondition_in_condition1086);
					orCondition();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(46); }

				DebugLocation(158, 44);
				// Grammars\\LavishProcessor.g:158:44: ( andCondition )?
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==And))
				{
					alt47 = 1;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:158:44: andCondition
					{
					DebugLocation(158, 44);
					PushFollow(Follow._andCondition_in_condition1089);
					andCondition();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(47); }


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:159:4: ^( CONDITION ^( Comparer conditionValue conditionValue ) ( orCondition )? ( andCondition )? )
				{
				DebugLocation(159, 4);
				DebugLocation(159, 6);
				Match(input,CONDITION,Follow._CONDITION_in_condition1097); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(159, 16);
				DebugLocation(159, 18);
				Match(input,Comparer,Follow._Comparer_in_condition1100); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(159, 27);
				PushFollow(Follow._conditionValue_in_condition1102);
				conditionValue();
				PopFollow();

				DebugLocation(159, 42);
				PushFollow(Follow._conditionValue_in_condition1104);
				conditionValue();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(159, 58);
				// Grammars\\LavishProcessor.g:159:58: ( orCondition )?
				int alt48=2;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==Or))
				{
					alt48 = 1;
				}
				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:159:58: orCondition
					{
					DebugLocation(159, 58);
					PushFollow(Follow._orCondition_in_condition1107);
					orCondition();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(48); }

				DebugLocation(159, 71);
				// Grammars\\LavishProcessor.g:159:71: ( andCondition )?
				int alt49=2;
				try { DebugEnterSubRule(49);
				try { DebugEnterDecision(49, false);
				int LA49_1 = input.LA(1);

				if ((LA49_1==And))
				{
					alt49 = 1;
				}
				} finally { DebugExitDecision(49); }
				switch (alt49)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:159:71: andCondition
					{
					DebugLocation(159, 71);
					PushFollow(Follow._andCondition_in_condition1110);
					andCondition();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(49); }


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:160:4: ^( CONDITION ( orCondition )? ( andCondition )? )
				{
				DebugLocation(160, 4);
				DebugLocation(160, 6);
				Match(input,CONDITION,Follow._CONDITION_in_condition1118); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(160, 16);
					// Grammars\\LavishProcessor.g:160:16: ( orCondition )?
					int alt50=2;
					try { DebugEnterSubRule(50);
					try { DebugEnterDecision(50, false);
					int LA50_1 = input.LA(1);

					if ((LA50_1==Or))
					{
						alt50 = 1;
					}
					} finally { DebugExitDecision(50); }
					switch (alt50)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:160:16: orCondition
						{
						DebugLocation(160, 16);
						PushFollow(Follow._orCondition_in_condition1120);
						orCondition();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(50); }

					DebugLocation(160, 29);
					// Grammars\\LavishProcessor.g:160:29: ( andCondition )?
					int alt51=2;
					try { DebugEnterSubRule(51);
					try { DebugEnterDecision(51, false);
					int LA51_1 = input.LA(1);

					if ((LA51_1==And))
					{
						alt51 = 1;
					}
					} finally { DebugExitDecision(51); }
					switch (alt51)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:160:29: andCondition
						{
						DebugLocation(160, 29);
						PushFollow(Follow._andCondition_in_condition1123);
						andCondition();
						PopFollow();


						}
						break;

					}
					} finally { DebugExitSubRule(51); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("condition", 33);
			LeaveRule("condition", 33);
			LeaveRule_condition();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "condition"); }
		return;

	}
	// $ANTLR end "condition"

	partial void EnterRule_conditionValue();
	partial void LeaveRule_conditionValue();
	// $ANTLR start "conditionValue"
	// Grammars\\LavishProcessor.g:162:8: public conditionValue : ( ^( Negate ID ) | ^( Negate dataSequence ) | ^( Negate string ) | ^( Negate INT ) | ^( Negate FLOAT ) | ^( Negate ^( MATH math ) ) | ^( Negate conditionString ) | ID | dataSequence | string | INT | FLOAT | ^( MATH math ) | conditionString );
	[GrammarRule("conditionValue")]
	public void conditionValue()
	{
		EnterRule_conditionValue();
		EnterRule("conditionValue", 34);
		TraceIn("conditionValue", 34);
		try { DebugEnterRule(GrammarFileName, "conditionValue");
		DebugLocation(162, 1);
		try
		{
			// Grammars\\LavishProcessor.g:163:2: ( ^( Negate ID ) | ^( Negate dataSequence ) | ^( Negate string ) | ^( Negate INT ) | ^( Negate FLOAT ) | ^( Negate ^( MATH math ) ) | ^( Negate conditionString ) | ID | dataSequence | string | INT | FLOAT | ^( MATH math ) | conditionString )
			int alt53=14;
			try { DebugEnterDecision(53, false);
			switch (input.LA(1))
			{
			case Negate:
				{
				int LA53_2 = input.LA(2);

				if ((LA53_2==DOWN))
				{
					switch (input.LA(3))
					{
					case ID:
						{
						int LA53_4 = input.LA(4);

						if ((LA53_4==UP))
						{
							alt53 = 1;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 13, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case INT:
						{
						int LA53_4 = input.LA(4);

						if ((LA53_4==UP))
						{
							alt53 = 4;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 14, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case FLOAT:
						{
						int LA53_4 = input.LA(4);

						if ((LA53_4==UP))
						{
							alt53 = 5;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 15, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case MATH:
						{
						int LA53_4 = input.LA(4);

						if ((LA53_4==DOWN))
						{
							alt53 = 6;
						}
						else if ((LA53_4==UP))
						{
							alt53 = 7;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 16, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case Dollar:
						{
						int LA53_4 = input.LA(4);

						if ((LA53_4==DOWN))
						{
							alt53 = 2;
						}
						else if ((LA53_4==UP))
						{
							alt53 = 7;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 17, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case STRING:
						{
						int LA53_4 = input.LA(4);

						if ((LA53_4==DOWN))
						{
							alt53 = 3;
						}
						else if ((LA53_4==UP))
						{
							alt53 = 7;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 18, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case ARG:
					case And:
					case Assign:
					case Atom:
					case Band:
					case Bnegate:
					case Bor:
					case COMMAND:
					case COMMENT:
					case CONDITION:
					case Case:
					case CodeBlock:
					case Colon:
					case Comma:
					case DataCommand:
					case DeclareVariable:
					case Default:
					case Define:
					case Div:
					case Do:
					case Dot:
					case ESC_SEQ:
					case EXPONENT:
					case Echo:
					case Elipse:
					case Else:
					case ElseIf:
					case EndIf:
					case EndMac:
					case EqualTo:
					case Error:
					case For:
					case Function:
					case GreaterThan:
					case GreaterThanEqual:
					case HEX_DIGIT:
					case If:
					case IfDef:
					case IfNDef:
					case Include:
					case Inherits:
					case LCurly:
					case LSquare:
					case LeftShift:
					case LessThan:
					case LessThanEqual:
					case Macro:
					case Member:
					case Method:
					case Minus:
					case Modu:
					case Mult:
					case Negate:
					case NotEqualTo:
					case OCTAL_ESC:
					case ObjectDef:
					case Or:
					case Other:
					case Param:
					case Params:
					case Plus:
					case PreElse:
					case PreElseIf:
					case PreIf:
					case Quote:
					case RCurly:
					case RSquare:
					case Returns:
					case RightShift:
					case Scope:
					case Script:
					case Semi:
					case Switch:
					case Type:
					case UNICODE_ESC:
					case Unmac:
					case Variable:
					case VariableCase:
					case WS:
					case While:
					case Xor:
						{
						alt53 = 7;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 53, 9, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else if (((LA53_2>=UP && LA53_2<=Comma)||(LA53_2>=DataCommand && LA53_2<=LCurly)||(LA53_2>=LSquare && LA53_2<=Negate)||(LA53_2>=NotEqualTo && LA53_2<=RCurly)||(LA53_2>=RSquare && LA53_2<=Xor)))
				{
					alt53 = 14;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 53, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ID:
				{
				alt53 = 8;
				}
				break;
			case Dollar:
				{
				int LA53_2 = input.LA(2);

				if ((LA53_2==DOWN))
				{
					alt53 = 9;
				}
				else if (((LA53_2>=UP && LA53_2<=Comma)||(LA53_2>=DataCommand && LA53_2<=LCurly)||(LA53_2>=LSquare && LA53_2<=Negate)||(LA53_2>=NotEqualTo && LA53_2<=RCurly)||(LA53_2>=RSquare && LA53_2<=Xor)))
				{
					alt53 = 14;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 53, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case STRING:
				{
				int LA53_2 = input.LA(2);

				if ((LA53_2==DOWN))
				{
					alt53 = 10;
				}
				else if (((LA53_2>=UP && LA53_2<=Comma)||(LA53_2>=DataCommand && LA53_2<=LCurly)||(LA53_2>=LSquare && LA53_2<=Negate)||(LA53_2>=NotEqualTo && LA53_2<=RCurly)||(LA53_2>=RSquare && LA53_2<=Xor)))
				{
					alt53 = 14;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 53, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				alt53 = 11;
				}
				break;
			case FLOAT:
				{
				alt53 = 12;
				}
				break;
			case MATH:
				{
				int LA53_2 = input.LA(2);

				if ((LA53_2==DOWN))
				{
					alt53 = 13;
				}
				else if (((LA53_2>=UP && LA53_2<=Comma)||(LA53_2>=DataCommand && LA53_2<=LCurly)||(LA53_2>=LSquare && LA53_2<=Negate)||(LA53_2>=NotEqualTo && LA53_2<=RCurly)||(LA53_2>=RSquare && LA53_2<=Xor)))
				{
					alt53 = 14;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 53, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ARG:
			case And:
			case Assign:
			case Atom:
			case Band:
			case Bnegate:
			case Bor:
			case COMMAND:
			case COMMENT:
			case CONDITION:
			case Case:
			case CodeBlock:
			case Colon:
			case Comma:
			case DataCommand:
			case DeclareVariable:
			case Default:
			case Define:
			case Div:
			case Do:
			case Dot:
			case ESC_SEQ:
			case EXPONENT:
			case Echo:
			case Elipse:
			case Else:
			case ElseIf:
			case EndIf:
			case EndMac:
			case EqualTo:
			case Error:
			case For:
			case Function:
			case GreaterThan:
			case GreaterThanEqual:
			case HEX_DIGIT:
			case If:
			case IfDef:
			case IfNDef:
			case Include:
			case Inherits:
			case LCurly:
			case LSquare:
			case LeftShift:
			case LessThan:
			case LessThanEqual:
			case Macro:
			case Member:
			case Method:
			case Minus:
			case Modu:
			case Mult:
			case NotEqualTo:
			case OCTAL_ESC:
			case ObjectDef:
			case Or:
			case Other:
			case Param:
			case Params:
			case Plus:
			case PreElse:
			case PreElseIf:
			case PreIf:
			case Quote:
			case RCurly:
			case RSquare:
			case Returns:
			case RightShift:
			case Scope:
			case Script:
			case Semi:
			case Switch:
			case Type:
			case UNICODE_ESC:
			case Unmac:
			case Variable:
			case VariableCase:
			case WS:
			case While:
			case Xor:
				{
				alt53 = 14;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:163:4: ^( Negate ID )
				{
				DebugLocation(163, 4);
				DebugLocation(163, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1138); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(163, 13);
				Match(input,ID,Follow._ID_in_conditionValue1140); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:164:4: ^( Negate dataSequence )
				{
				DebugLocation(164, 4);
				DebugLocation(164, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1147); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(164, 13);
				PushFollow(Follow._dataSequence_in_conditionValue1149);
				dataSequence();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LavishProcessor.g:165:4: ^( Negate string )
				{
				DebugLocation(165, 4);
				DebugLocation(165, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1156); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(165, 13);
				PushFollow(Follow._string_in_conditionValue1158);
				@string();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LavishProcessor.g:166:4: ^( Negate INT )
				{
				DebugLocation(166, 4);
				DebugLocation(166, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1165); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(166, 13);
				Match(input,INT,Follow._INT_in_conditionValue1167); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LavishProcessor.g:167:4: ^( Negate FLOAT )
				{
				DebugLocation(167, 4);
				DebugLocation(167, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1174); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(167, 13);
				Match(input,FLOAT,Follow._FLOAT_in_conditionValue1176); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LavishProcessor.g:168:4: ^( Negate ^( MATH math ) )
				{
				DebugLocation(168, 4);
				DebugLocation(168, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1183); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(168, 13);
				DebugLocation(168, 15);
				Match(input,MATH,Follow._MATH_in_conditionValue1186); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(168, 20);
				PushFollow(Follow._math_in_conditionValue1188);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LavishProcessor.g:169:4: ^( Negate conditionString )
				{
				DebugLocation(169, 4);
				DebugLocation(169, 6);
				Match(input,Negate,Follow._Negate_in_conditionValue1196); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(169, 13);
				PushFollow(Follow._conditionString_in_conditionValue1198);
				conditionString();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LavishProcessor.g:170:4: ID
				{
				DebugLocation(170, 4);
				Match(input,ID,Follow._ID_in_conditionValue1204); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LavishProcessor.g:171:4: dataSequence
				{
				DebugLocation(171, 4);
				PushFollow(Follow._dataSequence_in_conditionValue1209);
				dataSequence();
				PopFollow();


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\LavishProcessor.g:172:4: string
				{
				DebugLocation(172, 4);
				PushFollow(Follow._string_in_conditionValue1214);
				@string();
				PopFollow();


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammars\\LavishProcessor.g:173:4: INT
				{
				DebugLocation(173, 4);
				Match(input,INT,Follow._INT_in_conditionValue1219); 

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammars\\LavishProcessor.g:174:4: FLOAT
				{
				DebugLocation(174, 4);
				Match(input,FLOAT,Follow._FLOAT_in_conditionValue1224); 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Grammars\\LavishProcessor.g:175:4: ^( MATH math )
				{
				DebugLocation(175, 4);
				DebugLocation(175, 6);
				Match(input,MATH,Follow._MATH_in_conditionValue1230); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(175, 11);
				PushFollow(Follow._math_in_conditionValue1232);
				math();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Grammars\\LavishProcessor.g:176:4: conditionString
				{
				DebugLocation(176, 4);
				PushFollow(Follow._conditionString_in_conditionValue1238);
				conditionString();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("conditionValue", 34);
			LeaveRule("conditionValue", 34);
			LeaveRule_conditionValue();
		}
		DebugLocation(177, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionValue"); }
		return;

	}
	// $ANTLR end "conditionValue"

	partial void EnterRule_conditionString();
	partial void LeaveRule_conditionString();
	// $ANTLR start "conditionString"
	// Grammars\\LavishProcessor.g:178:8: public conditionString : ~ ( Comparer | LParen | RParen | NewLine ) ;
	[GrammarRule("conditionString")]
	public void conditionString()
	{
		EnterRule_conditionString();
		EnterRule("conditionString", 35);
		TraceIn("conditionString", 35);
		try { DebugEnterRule(GrammarFileName, "conditionString");
		DebugLocation(178, 1);
		try
		{
			// Grammars\\LavishProcessor.g:179:2: (~ ( Comparer | LParen | RParen | NewLine ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:
			{
			DebugLocation(179, 2);
			if ((input.LA(1)>=ARG && input.LA(1)<=Comma)||(input.LA(1)>=DataCommand && input.LA(1)<=LCurly)||(input.LA(1)>=LSquare && input.LA(1)<=Negate)||(input.LA(1)>=NotEqualTo && input.LA(1)<=RCurly)||(input.LA(1)>=RSquare && input.LA(1)<=Xor))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("conditionString", 35);
			LeaveRule("conditionString", 35);
			LeaveRule_conditionString();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionString"); }
		return;

	}
	// $ANTLR end "conditionString"

	partial void EnterRule_orCondition();
	partial void LeaveRule_orCondition();
	// $ANTLR start "orCondition"
	// Grammars\\LavishProcessor.g:181:8: public orCondition : ^( Or condition ) ;
	[GrammarRule("orCondition")]
	public void orCondition()
	{
		EnterRule_orCondition();
		EnterRule("orCondition", 36);
		TraceIn("orCondition", 36);
		try { DebugEnterRule(GrammarFileName, "orCondition");
		DebugLocation(181, 1);
		try
		{
			// Grammars\\LavishProcessor.g:182:2: ( ^( Or condition ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:182:4: ^( Or condition )
			{
			DebugLocation(182, 4);
			DebugLocation(182, 6);
			Match(input,Or,Follow._Or_in_orCondition1272); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(182, 9);
			PushFollow(Follow._condition_in_orCondition1274);
			condition();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("orCondition", 36);
			LeaveRule("orCondition", 36);
			LeaveRule_orCondition();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "orCondition"); }
		return;

	}
	// $ANTLR end "orCondition"

	partial void EnterRule_andCondition();
	partial void LeaveRule_andCondition();
	// $ANTLR start "andCondition"
	// Grammars\\LavishProcessor.g:184:8: public andCondition : ^( And condition ) ;
	[GrammarRule("andCondition")]
	public void andCondition()
	{
		EnterRule_andCondition();
		EnterRule("andCondition", 37);
		TraceIn("andCondition", 37);
		try { DebugEnterRule(GrammarFileName, "andCondition");
		DebugLocation(184, 1);
		try
		{
			// Grammars\\LavishProcessor.g:185:2: ( ^( And condition ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:185:4: ^( And condition )
			{
			DebugLocation(185, 4);
			DebugLocation(185, 6);
			Match(input,And,Follow._And_in_andCondition1288); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(185, 10);
			PushFollow(Follow._condition_in_andCondition1290);
			condition();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("andCondition", 37);
			LeaveRule("andCondition", 37);
			LeaveRule_andCondition();
		}
		DebugLocation(186, 1);
		} finally { DebugExitRule(GrammarFileName, "andCondition"); }
		return;

	}
	// $ANTLR end "andCondition"

	partial void EnterRule_macro();
	partial void LeaveRule_macro();
	// $ANTLR start "macro"
	// Grammars\\LavishProcessor.g:187:8: public macro : ^( Macro ID ^( Params params ) ( expression )* ) ;
	[GrammarRule("macro")]
	public void macro()
	{
		EnterRule_macro();
		EnterRule("macro", 38);
		TraceIn("macro", 38);
		try { DebugEnterRule(GrammarFileName, "macro");
		DebugLocation(187, 1);
		try
		{
			// Grammars\\LavishProcessor.g:188:2: ( ^( Macro ID ^( Params params ) ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:188:4: ^( Macro ID ^( Params params ) ( expression )* )
			{
			DebugLocation(188, 4);
			DebugLocation(188, 6);
			Match(input,Macro,Follow._Macro_in_macro1304); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(188, 12);
			Match(input,ID,Follow._ID_in_macro1306); 
			DebugLocation(188, 15);
			DebugLocation(188, 17);
			Match(input,Params,Follow._Params_in_macro1309); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(188, 24);
			PushFollow(Follow._params_in_macro1311);
			@params();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(188, 32);
			// Grammars\\LavishProcessor.g:188:32: ( expression )*
			try { DebugEnterSubRule(54);
			while (true)
			{
				int alt54=2;
				try { DebugEnterDecision(54, false);
				int LA54_1 = input.LA(1);

				if ((LA54_1==COMMAND||LA54_1==CodeBlock||(LA54_1>=DataCommand && LA54_1<=DeclareVariable)||LA54_1==Define||LA54_1==Do||LA54_1==Echo||LA54_1==Error||LA54_1==For||(LA54_1>=If && LA54_1<=Include)||LA54_1==Macro||LA54_1==PreIf||LA54_1==Switch||(LA54_1>=Unmac && LA54_1<=Variable)||LA54_1==While))
				{
					alt54 = 1;
				}


				} finally { DebugExitDecision(54); }
				switch ( alt54 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:188:32: expression
					{
					DebugLocation(188, 32);
					PushFollow(Follow._expression_in_macro1314);
					expression();
					PopFollow();


					}
					break;

				default:
					goto loop54;
				}
			}

			loop54:
				;

			} finally { DebugExitSubRule(54); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("macro", 38);
			LeaveRule("macro", 38);
			LeaveRule_macro();
		}
		DebugLocation(189, 1);
		} finally { DebugExitRule(GrammarFileName, "macro"); }
		return;

	}
	// $ANTLR end "macro"

	partial void EnterRule_preIf();
	partial void LeaveRule_preIf();
	// $ANTLR start "preIf"
	// Grammars\\LavishProcessor.g:190:8: public preIf : ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? ) ;
	[GrammarRule("preIf")]
	public void preIf()
	{
		EnterRule_preIf();
		EnterRule("preIf", 39);
		TraceIn("preIf", 39);
		try { DebugEnterRule(GrammarFileName, "preIf");
		DebugLocation(190, 1);
		try
		{
			// Grammars\\LavishProcessor.g:191:2: ( ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:191:4: ^( PreIf condition ( expression )* ( preElseIf )* ( preElse )? )
			{
			DebugLocation(191, 4);
			DebugLocation(191, 6);
			Match(input,PreIf,Follow._PreIf_in_preIf1329); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(191, 12);
			PushFollow(Follow._condition_in_preIf1331);
			condition();
			PopFollow();

			DebugLocation(191, 22);
			// Grammars\\LavishProcessor.g:191:22: ( expression )*
			try { DebugEnterSubRule(55);
			while (true)
			{
				int alt55=2;
				try { DebugEnterDecision(55, false);
				int LA55_1 = input.LA(1);

				if ((LA55_1==COMMAND||LA55_1==CodeBlock||(LA55_1>=DataCommand && LA55_1<=DeclareVariable)||LA55_1==Define||LA55_1==Do||LA55_1==Echo||LA55_1==Error||LA55_1==For||(LA55_1>=If && LA55_1<=Include)||LA55_1==Macro||LA55_1==PreIf||LA55_1==Switch||(LA55_1>=Unmac && LA55_1<=Variable)||LA55_1==While))
				{
					alt55 = 1;
				}


				} finally { DebugExitDecision(55); }
				switch ( alt55 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:191:22: expression
					{
					DebugLocation(191, 22);
					PushFollow(Follow._expression_in_preIf1333);
					expression();
					PopFollow();


					}
					break;

				default:
					goto loop55;
				}
			}

			loop55:
				;

			} finally { DebugExitSubRule(55); }

			DebugLocation(191, 34);
			// Grammars\\LavishProcessor.g:191:34: ( preElseIf )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==PreElse))
				{
					int LA56_2 = input.LA(2);

					if ((LA56_2==DOWN))
					{
						int LA56_3 = input.LA(3);

						if ((LA56_3==CONDITION||LA56_3==Negate))
						{
							alt56 = 1;
						}


					}


				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:191:34: preElseIf
					{
					DebugLocation(191, 34);
					PushFollow(Follow._preElseIf_in_preIf1336);
					preElseIf();
					PopFollow();


					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }

			DebugLocation(191, 45);
			// Grammars\\LavishProcessor.g:191:45: ( preElse )?
			int alt57=2;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			int LA57_1 = input.LA(1);

			if ((LA57_1==PreElse))
			{
				alt57 = 1;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:191:45: preElse
				{
				DebugLocation(191, 45);
				PushFollow(Follow._preElse_in_preIf1339);
				preElse();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(57); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preIf", 39);
			LeaveRule("preIf", 39);
			LeaveRule_preIf();
		}
		DebugLocation(192, 1);
		} finally { DebugExitRule(GrammarFileName, "preIf"); }
		return;

	}
	// $ANTLR end "preIf"

	partial void EnterRule_preElseIf();
	partial void LeaveRule_preElseIf();
	// $ANTLR start "preElseIf"
	// Grammars\\LavishProcessor.g:193:8: public preElseIf : ^( PreElse condition ( expression )* ) ;
	[GrammarRule("preElseIf")]
	public void preElseIf()
	{
		EnterRule_preElseIf();
		EnterRule("preElseIf", 40);
		TraceIn("preElseIf", 40);
		try { DebugEnterRule(GrammarFileName, "preElseIf");
		DebugLocation(193, 1);
		try
		{
			// Grammars\\LavishProcessor.g:194:2: ( ^( PreElse condition ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:194:4: ^( PreElse condition ( expression )* )
			{
			DebugLocation(194, 4);
			DebugLocation(194, 6);
			Match(input,PreElse,Follow._PreElse_in_preElseIf1354); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(194, 14);
			PushFollow(Follow._condition_in_preElseIf1356);
			condition();
			PopFollow();

			DebugLocation(194, 24);
			// Grammars\\LavishProcessor.g:194:24: ( expression )*
			try { DebugEnterSubRule(58);
			while (true)
			{
				int alt58=2;
				try { DebugEnterDecision(58, false);
				int LA58_1 = input.LA(1);

				if ((LA58_1==COMMAND||LA58_1==CodeBlock||(LA58_1>=DataCommand && LA58_1<=DeclareVariable)||LA58_1==Define||LA58_1==Do||LA58_1==Echo||LA58_1==Error||LA58_1==For||(LA58_1>=If && LA58_1<=Include)||LA58_1==Macro||LA58_1==PreIf||LA58_1==Switch||(LA58_1>=Unmac && LA58_1<=Variable)||LA58_1==While))
				{
					alt58 = 1;
				}


				} finally { DebugExitDecision(58); }
				switch ( alt58 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:194:24: expression
					{
					DebugLocation(194, 24);
					PushFollow(Follow._expression_in_preElseIf1358);
					expression();
					PopFollow();


					}
					break;

				default:
					goto loop58;
				}
			}

			loop58:
				;

			} finally { DebugExitSubRule(58); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preElseIf", 40);
			LeaveRule("preElseIf", 40);
			LeaveRule_preElseIf();
		}
		DebugLocation(195, 1);
		} finally { DebugExitRule(GrammarFileName, "preElseIf"); }
		return;

	}
	// $ANTLR end "preElseIf"

	partial void EnterRule_preElse();
	partial void LeaveRule_preElse();
	// $ANTLR start "preElse"
	// Grammars\\LavishProcessor.g:196:8: public preElse : ^( PreElse ( expression )* ) ;
	[GrammarRule("preElse")]
	public void preElse()
	{
		EnterRule_preElse();
		EnterRule("preElse", 41);
		TraceIn("preElse", 41);
		try { DebugEnterRule(GrammarFileName, "preElse");
		DebugLocation(196, 1);
		try
		{
			// Grammars\\LavishProcessor.g:197:2: ( ^( PreElse ( expression )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:197:4: ^( PreElse ( expression )* )
			{
			DebugLocation(197, 4);
			DebugLocation(197, 6);
			Match(input,PreElse,Follow._PreElse_in_preElse1373); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(197, 14);
				// Grammars\\LavishProcessor.g:197:14: ( expression )*
				try { DebugEnterSubRule(59);
				while (true)
				{
					int alt59=2;
					try { DebugEnterDecision(59, false);
					int LA59_1 = input.LA(1);

					if ((LA59_1==COMMAND||LA59_1==CodeBlock||(LA59_1>=DataCommand && LA59_1<=DeclareVariable)||LA59_1==Define||LA59_1==Do||LA59_1==Echo||LA59_1==Error||LA59_1==For||(LA59_1>=If && LA59_1<=Include)||LA59_1==Macro||LA59_1==PreIf||LA59_1==Switch||(LA59_1>=Unmac && LA59_1<=Variable)||LA59_1==While))
					{
						alt59 = 1;
					}


					} finally { DebugExitDecision(59); }
					switch ( alt59 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:197:14: expression
						{
						DebugLocation(197, 14);
						PushFollow(Follow._expression_in_preElse1375);
						expression();
						PopFollow();


						}
						break;

					default:
						goto loop59;
					}
				}

				loop59:
					;

				} finally { DebugExitSubRule(59); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("preElse", 41);
			LeaveRule("preElse", 41);
			LeaveRule_preElse();
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "preElse"); }
		return;

	}
	// $ANTLR end "preElse"

	partial void EnterRule_ifDef();
	partial void LeaveRule_ifDef();
	// $ANTLR start "ifDef"
	// Grammars\\LavishProcessor.g:199:8: public ifDef : ^( IfDef ID ( preElse )? ) ;
	[GrammarRule("ifDef")]
	public void ifDef()
	{
		EnterRule_ifDef();
		EnterRule("ifDef", 42);
		TraceIn("ifDef", 42);
		try { DebugEnterRule(GrammarFileName, "ifDef");
		DebugLocation(199, 1);
		try
		{
			// Grammars\\LavishProcessor.g:200:2: ( ^( IfDef ID ( preElse )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:200:4: ^( IfDef ID ( preElse )? )
			{
			DebugLocation(200, 4);
			DebugLocation(200, 6);
			Match(input,IfDef,Follow._IfDef_in_ifDef1390); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(200, 12);
			Match(input,ID,Follow._ID_in_ifDef1392); 
			DebugLocation(200, 15);
			// Grammars\\LavishProcessor.g:200:15: ( preElse )?
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			int LA60_1 = input.LA(1);

			if ((LA60_1==PreElse))
			{
				alt60 = 1;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:200:15: preElse
				{
				DebugLocation(200, 15);
				PushFollow(Follow._preElse_in_ifDef1394);
				preElse();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(60); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifDef", 42);
			LeaveRule("ifDef", 42);
			LeaveRule_ifDef();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "ifDef"); }
		return;

	}
	// $ANTLR end "ifDef"

	partial void EnterRule_ifNDef();
	partial void LeaveRule_ifNDef();
	// $ANTLR start "ifNDef"
	// Grammars\\LavishProcessor.g:202:8: public ifNDef : ^( IfNDef ID ( preElse )? ) ;
	[GrammarRule("ifNDef")]
	public void ifNDef()
	{
		EnterRule_ifNDef();
		EnterRule("ifNDef", 43);
		TraceIn("ifNDef", 43);
		try { DebugEnterRule(GrammarFileName, "ifNDef");
		DebugLocation(202, 1);
		try
		{
			// Grammars\\LavishProcessor.g:203:2: ( ^( IfNDef ID ( preElse )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:203:4: ^( IfNDef ID ( preElse )? )
			{
			DebugLocation(203, 4);
			DebugLocation(203, 6);
			Match(input,IfNDef,Follow._IfNDef_in_ifNDef1409); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(203, 13);
			Match(input,ID,Follow._ID_in_ifNDef1411); 
			DebugLocation(203, 16);
			// Grammars\\LavishProcessor.g:203:16: ( preElse )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_1 = input.LA(1);

			if ((LA61_1==PreElse))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:203:16: preElse
				{
				DebugLocation(203, 16);
				PushFollow(Follow._preElse_in_ifNDef1413);
				preElse();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(61); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifNDef", 43);
			LeaveRule("ifNDef", 43);
			LeaveRule_ifNDef();
		}
		DebugLocation(204, 1);
		} finally { DebugExitRule(GrammarFileName, "ifNDef"); }
		return;

	}
	// $ANTLR end "ifNDef"

	partial void EnterRule_echo();
	partial void LeaveRule_echo();
	// $ANTLR start "echo"
	// Grammars\\LavishProcessor.g:205:8: public echo : ^( Echo ( lineArg )* ) ;
	[GrammarRule("echo")]
	public void echo()
	{
		EnterRule_echo();
		EnterRule("echo", 44);
		TraceIn("echo", 44);
		try { DebugEnterRule(GrammarFileName, "echo");
		DebugLocation(205, 1);
		try
		{
			// Grammars\\LavishProcessor.g:206:2: ( ^( Echo ( lineArg )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:206:4: ^( Echo ( lineArg )* )
			{
			DebugLocation(206, 4);
			DebugLocation(206, 6);
			Match(input,Echo,Follow._Echo_in_echo1428); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(206, 11);
				// Grammars\\LavishProcessor.g:206:11: ( lineArg )*
				try { DebugEnterSubRule(62);
				while (true)
				{
					int alt62=2;
					try { DebugEnterDecision(62, false);
					int LA62_1 = input.LA(1);

					if (((LA62_1>=ARG && LA62_1<=Negate)||(LA62_1>=NotEqualTo && LA62_1<=Xor)))
					{
						alt62 = 1;
					}


					} finally { DebugExitDecision(62); }
					switch ( alt62 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:206:11: lineArg
						{
						DebugLocation(206, 11);
						PushFollow(Follow._lineArg_in_echo1430);
						lineArg();
						PopFollow();


						}
						break;

					default:
						goto loop62;
					}
				}

				loop62:
					;

				} finally { DebugExitSubRule(62); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("echo", 44);
			LeaveRule("echo", 44);
			LeaveRule_echo();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "echo"); }
		return;

	}
	// $ANTLR end "echo"

	partial void EnterRule_error();
	partial void LeaveRule_error();
	// $ANTLR start "error"
	// Grammars\\LavishProcessor.g:208:8: public error : ^( Error ( lineArg )* ) ;
	[GrammarRule("error")]
	public void error()
	{
		EnterRule_error();
		EnterRule("error", 45);
		TraceIn("error", 45);
		try { DebugEnterRule(GrammarFileName, "error");
		DebugLocation(208, 1);
		try
		{
			// Grammars\\LavishProcessor.g:209:2: ( ^( Error ( lineArg )* ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:209:4: ^( Error ( lineArg )* )
			{
			DebugLocation(209, 4);
			DebugLocation(209, 6);
			Match(input,Error,Follow._Error_in_error1445); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(209, 12);
				// Grammars\\LavishProcessor.g:209:12: ( lineArg )*
				try { DebugEnterSubRule(63);
				while (true)
				{
					int alt63=2;
					try { DebugEnterDecision(63, false);
					int LA63_1 = input.LA(1);

					if (((LA63_1>=ARG && LA63_1<=Negate)||(LA63_1>=NotEqualTo && LA63_1<=Xor)))
					{
						alt63 = 1;
					}


					} finally { DebugExitDecision(63); }
					switch ( alt63 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:209:12: lineArg
						{
						DebugLocation(209, 12);
						PushFollow(Follow._lineArg_in_error1447);
						lineArg();
						PopFollow();


						}
						break;

					default:
						goto loop63;
					}
				}

				loop63:
					;

				} finally { DebugExitSubRule(63); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("error", 45);
			LeaveRule("error", 45);
			LeaveRule_error();
		}
		DebugLocation(210, 1);
		} finally { DebugExitRule(GrammarFileName, "error"); }
		return;

	}
	// $ANTLR end "error"

	partial void EnterRule_unmac();
	partial void LeaveRule_unmac();
	// $ANTLR start "unmac"
	// Grammars\\LavishProcessor.g:211:8: public unmac : ^( Unmac ID ) ;
	[GrammarRule("unmac")]
	public void unmac()
	{
		EnterRule_unmac();
		EnterRule("unmac", 46);
		TraceIn("unmac", 46);
		try { DebugEnterRule(GrammarFileName, "unmac");
		DebugLocation(211, 1);
		try
		{
			// Grammars\\LavishProcessor.g:212:2: ( ^( Unmac ID ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:212:4: ^( Unmac ID )
			{
			DebugLocation(212, 4);
			DebugLocation(212, 6);
			Match(input,Unmac,Follow._Unmac_in_unmac1462); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(212, 12);
			Match(input,ID,Follow._ID_in_unmac1464); 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unmac", 46);
			LeaveRule("unmac", 46);
			LeaveRule_unmac();
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "unmac"); }
		return;

	}
	// $ANTLR end "unmac"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// Grammars\\LavishProcessor.g:214:8: public forStatement : ^( For command condition command ) ;
	[GrammarRule("forStatement")]
	public void forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 47);
		TraceIn("forStatement", 47);
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(214, 1);
		try
		{
			// Grammars\\LavishProcessor.g:215:2: ( ^( For command condition command ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:215:4: ^( For command condition command )
			{
			DebugLocation(215, 4);
			DebugLocation(215, 6);
			Match(input,For,Follow._For_in_forStatement1478); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(215, 10);
			PushFollow(Follow._command_in_forStatement1480);
			command();
			PopFollow();

			DebugLocation(215, 18);
			PushFollow(Follow._condition_in_forStatement1482);
			condition();
			PopFollow();

			DebugLocation(215, 28);
			PushFollow(Follow._command_in_forStatement1484);
			command();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forStatement", 47);
			LeaveRule("forStatement", 47);
			LeaveRule_forStatement();
		}
		DebugLocation(216, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_doStatement();
	partial void LeaveRule_doStatement();
	// $ANTLR start "doStatement"
	// Grammars\\LavishProcessor.g:217:8: public doStatement : ^( Do expression condition ) ;
	[GrammarRule("doStatement")]
	public void doStatement()
	{
		EnterRule_doStatement();
		EnterRule("doStatement", 48);
		TraceIn("doStatement", 48);
		try { DebugEnterRule(GrammarFileName, "doStatement");
		DebugLocation(217, 1);
		try
		{
			// Grammars\\LavishProcessor.g:218:2: ( ^( Do expression condition ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:218:4: ^( Do expression condition )
			{
			DebugLocation(218, 4);
			DebugLocation(218, 6);
			Match(input,Do,Follow._Do_in_doStatement1498); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(218, 9);
			PushFollow(Follow._expression_in_doStatement1500);
			expression();
			PopFollow();

			DebugLocation(218, 20);
			PushFollow(Follow._condition_in_doStatement1502);
			condition();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("doStatement", 48);
			LeaveRule("doStatement", 48);
			LeaveRule_doStatement();
		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "doStatement"); }
		return;

	}
	// $ANTLR end "doStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// Grammars\\LavishProcessor.g:220:8: public whileStatement : ^( While condition expression ) ;
	[GrammarRule("whileStatement")]
	public void whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 49);
		TraceIn("whileStatement", 49);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(220, 1);
		try
		{
			// Grammars\\LavishProcessor.g:221:2: ( ^( While condition expression ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:221:4: ^( While condition expression )
			{
			DebugLocation(221, 4);
			DebugLocation(221, 6);
			Match(input,While,Follow._While_in_whileStatement1516); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(221, 12);
			PushFollow(Follow._condition_in_whileStatement1518);
			condition();
			PopFollow();

			DebugLocation(221, 22);
			PushFollow(Follow._expression_in_whileStatement1520);
			expression();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whileStatement", 49);
			LeaveRule("whileStatement", 49);
			LeaveRule_whileStatement();
		}
		DebugLocation(222, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// Grammars\\LavishProcessor.g:223:8: public ifStatement : ^( If condition expression ( ^( ElseIf condition expression ) )* ( ^( Else expression ) )? ) ;
	[GrammarRule("ifStatement")]
	public void ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 50);
		TraceIn("ifStatement", 50);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(223, 1);
		try
		{
			// Grammars\\LavishProcessor.g:224:2: ( ^( If condition expression ( ^( ElseIf condition expression ) )* ( ^( Else expression ) )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:224:4: ^( If condition expression ( ^( ElseIf condition expression ) )* ( ^( Else expression ) )? )
			{
			DebugLocation(224, 4);
			DebugLocation(224, 6);
			Match(input,If,Follow._If_in_ifStatement1534); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(224, 9);
			PushFollow(Follow._condition_in_ifStatement1536);
			condition();
			PopFollow();

			DebugLocation(224, 19);
			PushFollow(Follow._expression_in_ifStatement1538);
			expression();
			PopFollow();

			DebugLocation(224, 30);
			// Grammars\\LavishProcessor.g:224:30: ( ^( ElseIf condition expression ) )*
			try { DebugEnterSubRule(64);
			while (true)
			{
				int alt64=2;
				try { DebugEnterDecision(64, false);
				int LA64_1 = input.LA(1);

				if ((LA64_1==ElseIf))
				{
					alt64 = 1;
				}


				} finally { DebugExitDecision(64); }
				switch ( alt64 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:224:31: ^( ElseIf condition expression )
					{
					DebugLocation(224, 31);
					DebugLocation(224, 33);
					Match(input,ElseIf,Follow._ElseIf_in_ifStatement1542); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(224, 40);
					PushFollow(Follow._condition_in_ifStatement1544);
					condition();
					PopFollow();

					DebugLocation(224, 50);
					PushFollow(Follow._expression_in_ifStatement1546);
					expression();
					PopFollow();


					Match(input, TokenTypes.Up, null); 


					}
					break;

				default:
					goto loop64;
				}
			}

			loop64:
				;

			} finally { DebugExitSubRule(64); }

			DebugLocation(224, 64);
			// Grammars\\LavishProcessor.g:224:64: ( ^( Else expression ) )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==Else))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:224:65: ^( Else expression )
				{
				DebugLocation(224, 65);
				DebugLocation(224, 67);
				Match(input,Else,Follow._Else_in_ifStatement1553); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(224, 72);
				PushFollow(Follow._expression_in_ifStatement1555);
				expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
			} finally { DebugExitSubRule(65); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifStatement", 50);
			LeaveRule("ifStatement", 50);
			LeaveRule_ifStatement();
		}
		DebugLocation(225, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// Grammars\\LavishProcessor.g:226:8: public switchStatement : ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? ) ;
	[GrammarRule("switchStatement")]
	public void switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 51);
		TraceIn("switchStatement", 51);
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(226, 1);
		try
		{
			// Grammars\\LavishProcessor.g:227:2: ( ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:227:4: ^( Switch ^( Param ( lineArg )+ ) ( switchCase )* ( defaultCase )? )
			{
			DebugLocation(227, 4);
			DebugLocation(227, 6);
			Match(input,Switch,Follow._Switch_in_switchStatement1572); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(227, 13);
			DebugLocation(227, 15);
			Match(input,Param,Follow._Param_in_switchStatement1575); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(227, 21);
			// Grammars\\LavishProcessor.g:227:21: ( lineArg )+
			int cnt66=0;
			try { DebugEnterSubRule(66);
			while (true)
			{
				int alt66=2;
				try { DebugEnterDecision(66, false);
				int LA66_1 = input.LA(1);

				if (((LA66_1>=ARG && LA66_1<=Negate)||(LA66_1>=NotEqualTo && LA66_1<=Xor)))
				{
					alt66 = 1;
				}


				} finally { DebugExitDecision(66); }
				switch (alt66)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:227:21: lineArg
					{
					DebugLocation(227, 21);
					PushFollow(Follow._lineArg_in_switchStatement1577);
					lineArg();
					PopFollow();


					}
					break;

				default:
					if (cnt66 >= 1)
						goto loop66;

					EarlyExitException eee66 = new EarlyExitException( 66, input );
					DebugRecognitionException(eee66);
					throw eee66;
				}
				cnt66++;
			}
			loop66:
				;

			} finally { DebugExitSubRule(66); }


			Match(input, TokenTypes.Up, null); 

			DebugLocation(227, 31);
			// Grammars\\LavishProcessor.g:227:31: ( switchCase )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==Case||LA67_1==VariableCase))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LavishProcessor.g:227:31: switchCase
					{
					DebugLocation(227, 31);
					PushFollow(Follow._switchCase_in_switchStatement1581);
					switchCase();
					PopFollow();


					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }

			DebugLocation(227, 43);
			// Grammars\\LavishProcessor.g:227:43: ( defaultCase )?
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_1 = input.LA(1);

			if ((LA68_1==Default))
			{
				alt68 = 1;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:227:43: defaultCase
				{
				DebugLocation(227, 43);
				PushFollow(Follow._defaultCase_in_switchStatement1584);
				defaultCase();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(68); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("switchStatement", 51);
			LeaveRule("switchStatement", 51);
			LeaveRule_switchStatement();
		}
		DebugLocation(228, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_switchCase();
	partial void LeaveRule_switchCase();
	// $ANTLR start "switchCase"
	// Grammars\\LavishProcessor.g:229:8: public switchCase : ( ^( Case ^( Param ( lineArg )+ ) expression ) | ^( VariableCase dataSequence expression ) );
	[GrammarRule("switchCase")]
	public void switchCase()
	{
		EnterRule_switchCase();
		EnterRule("switchCase", 52);
		TraceIn("switchCase", 52);
		try { DebugEnterRule(GrammarFileName, "switchCase");
		DebugLocation(229, 1);
		try
		{
			// Grammars\\LavishProcessor.g:230:2: ( ^( Case ^( Param ( lineArg )+ ) expression ) | ^( VariableCase dataSequence expression ) )
			int alt70=2;
			try { DebugEnterDecision(70, false);
			int LA70_1 = input.LA(1);

			if ((LA70_1==Case))
			{
				alt70 = 1;
			}
			else if ((LA70_1==VariableCase))
			{
				alt70 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(70); }
			switch (alt70)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LavishProcessor.g:230:4: ^( Case ^( Param ( lineArg )+ ) expression )
				{
				DebugLocation(230, 4);
				DebugLocation(230, 6);
				Match(input,Case,Follow._Case_in_switchCase1599); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(230, 11);
				DebugLocation(230, 13);
				Match(input,Param,Follow._Param_in_switchCase1602); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(230, 19);
				// Grammars\\LavishProcessor.g:230:19: ( lineArg )+
				int cnt69=0;
				try { DebugEnterSubRule(69);
				while (true)
				{
					int alt69=2;
					try { DebugEnterDecision(69, false);
					int LA69_1 = input.LA(1);

					if (((LA69_1>=ARG && LA69_1<=Negate)||(LA69_1>=NotEqualTo && LA69_1<=Xor)))
					{
						alt69 = 1;
					}


					} finally { DebugExitDecision(69); }
					switch (alt69)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LavishProcessor.g:230:19: lineArg
						{
						DebugLocation(230, 19);
						PushFollow(Follow._lineArg_in_switchCase1604);
						lineArg();
						PopFollow();


						}
						break;

					default:
						if (cnt69 >= 1)
							goto loop69;

						EarlyExitException eee69 = new EarlyExitException( 69, input );
						DebugRecognitionException(eee69);
						throw eee69;
					}
					cnt69++;
				}
				loop69:
					;

				} finally { DebugExitSubRule(69); }


				Match(input, TokenTypes.Up, null); 

				DebugLocation(230, 29);
				PushFollow(Follow._expression_in_switchCase1608);
				expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LavishProcessor.g:231:4: ^( VariableCase dataSequence expression )
				{
				DebugLocation(231, 4);
				DebugLocation(231, 6);
				Match(input,VariableCase,Follow._VariableCase_in_switchCase1615); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(231, 19);
				PushFollow(Follow._dataSequence_in_switchCase1617);
				dataSequence();
				PopFollow();

				DebugLocation(231, 32);
				PushFollow(Follow._expression_in_switchCase1619);
				expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("switchCase", 52);
			LeaveRule("switchCase", 52);
			LeaveRule_switchCase();
		}
		DebugLocation(232, 1);
		} finally { DebugExitRule(GrammarFileName, "switchCase"); }
		return;

	}
	// $ANTLR end "switchCase"

	partial void EnterRule_defaultCase();
	partial void LeaveRule_defaultCase();
	// $ANTLR start "defaultCase"
	// Grammars\\LavishProcessor.g:233:8: public defaultCase : ^( Default expression ) ;
	[GrammarRule("defaultCase")]
	public void defaultCase()
	{
		EnterRule_defaultCase();
		EnterRule("defaultCase", 53);
		TraceIn("defaultCase", 53);
		try { DebugEnterRule(GrammarFileName, "defaultCase");
		DebugLocation(233, 1);
		try
		{
			// Grammars\\LavishProcessor.g:234:2: ( ^( Default expression ) )
			DebugEnterAlt(1);
			// Grammars\\LavishProcessor.g:234:4: ^( Default expression )
			{
			DebugLocation(234, 4);
			DebugLocation(234, 6);
			Match(input,Default,Follow._Default_in_defaultCase1633); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(234, 14);
			PushFollow(Follow._expression_in_defaultCase1635);
			expression();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("defaultCase", 53);
			LeaveRule("defaultCase", 53);
			LeaveRule_defaultCase();
		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultCase"); }
		return;

	}
	// $ANTLR end "defaultCase"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _scriptStructure_in_script36 = new BitSet(new ulong[]{0x201C09020400082UL,0x6000808UL});
		public static readonly BitSet _variableDeclare_in_scriptStructure49 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_in_scriptStructure55 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_scriptStructure61 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectDef_in_scriptStructure67 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preProcessor_in_scriptStructure72 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ObjectDef_in_objectDef85 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_objectDef88 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _function_in_objectDef91 = new BitSet(new ulong[]{0xC00008000000088UL,0x4000000UL});
		public static readonly BitSet _atom_in_objectDef93 = new BitSet(new ulong[]{0xC00008000000088UL,0x4000000UL});
		public static readonly BitSet _objectMember_in_objectDef95 = new BitSet(new ulong[]{0xC00008000000088UL,0x4000000UL});
		public static readonly BitSet _variableDeclare_in_objectDef97 = new BitSet(new ulong[]{0xC00008000000088UL,0x4000000UL});
		public static readonly BitSet _objectMethod_in_objectDef99 = new BitSet(new ulong[]{0xC00008000000088UL,0x4000000UL});
		public static readonly BitSet _Inherits_in_objectDef106 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_objectDef108 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Variable_in_variableDeclare125 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Scope_in_variableDeclare127 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_variableDeclare130 = new BitSet(new ulong[]{0x10080000000000UL});
		public static readonly BitSet _indexer_in_variableDeclare132 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_variableDeclare136 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Assign_in_variableDeclare139 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _lineArg_in_variableDeclare141 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFFFFEUL});
		public static readonly BitSet _Function_in_function160 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_function162 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _Returns_in_function165 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_function167 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _params_in_function171 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _codeBlock_in_function173 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Atom_in_atom187 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_atom189 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _Returns_in_atom192 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_atom194 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _params_in_atom198 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _codeBlock_in_atom200 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Member_in_objectMember214 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_objectMember216 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _Returns_in_objectMember219 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_objectMember221 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _params_in_objectMember225 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _codeBlock_in_objectMember227 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Method_in_objectMethod241 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_objectMethod243 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _Returns_in_objectMethod246 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_objectMethod248 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _params_in_objectMethod252 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _codeBlock_in_objectMethod254 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Params_in_params268 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Param_in_params271 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Elipse_in_params273 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_params275 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Params_in_params283 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Param_in_params287 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Type_in_params290 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_params292 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_params298 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Assign_in_params301 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _value_in_params303 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_value320 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_value322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_value324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_value326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_value328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_value330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Dollar_in_dataSequence350 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessor_in_dataSequence352 = new BitSet(new ulong[]{0x4010008UL});
		public static readonly BitSet _member_in_dataSequence354 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _id_in_accessor368 = new BitSet(new ulong[]{0x18000000000002UL});
		public static readonly BitSet _indexer_in_accessor371 = new BitSet(new ulong[]{0x18000000000002UL});
		public static readonly BitSet _typeCast_in_accessor373 = new BitSet(new ulong[]{0x18000000000002UL});
		public static readonly BitSet _ID_in_id388 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _id_in_id390 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _dataSequence_in_id397 = new BitSet(new ulong[]{0x80002000002UL});
		public static readonly BitSet _id_in_id399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LParen_in_typeCast413 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _id_in_typeCast415 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Dot_in_member429 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessor_in_member431 = new BitSet(new ulong[]{0x4010008UL});
		public static readonly BitSet _member_in_member433 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Colon_in_member441 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _accessor_in_member443 = new BitSet(new ulong[]{0x4010008UL});
		public static readonly BitSet _member_in_member445 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STRING_in_string460 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _dataSequence_in_string463 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFEFFFUL});
		public static readonly BitSet _quoteString_in_string465 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFEFFFUL});
		public static readonly BitSet _Bor_in_math496 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math498 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math500 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Xor_in_math507 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math509 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math511 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Band_in_math518 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math520 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math522 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LeftShift_in_math529 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math531 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math533 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RightShift_in_math540 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math542 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math544 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Plus_in_math551 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math553 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math555 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Minus_in_math562 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math564 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math566 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Mult_in_math573 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math575 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math577 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Div_in_math584 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math586 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math588 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Modu_in_math595 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math597 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math599 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Bnegate_in_math606 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_math608 = new BitSet(new ulong[]{0x7020102002800700UL,0x40020100UL});
		public static readonly BitSet _math_in_math610 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INT_in_math616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_math621 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_math626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _commaArg_in_commaVals638 = new BitSet(new ulong[]{0xFFFFFFFFFFFDFFF2UL,0x7FFF7FFFUL});
		public static readonly BitSet _ID_in_commaArg652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_commaArg657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_commaArg662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_commaArg667 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DataCommand_in_command685 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _dataCommand_in_command687 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _COMMAND_in_command694 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_command696 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FDFFFFEUL});
		public static readonly BitSet _commandArg_in_command698 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FDFFFFEUL});
		public static readonly BitSet _COMMAND_in_command706 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _dataSequence_in_command708 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FDFFFFEUL});
		public static readonly BitSet _commandArg_in_command710 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FDFFFFEUL});
		public static readonly BitSet _accessor_in_dataCommand725 = new BitSet(new ulong[]{0x4010000UL});
		public static readonly BitSet _member_in_dataCommand727 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_commandArg739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_commandArg744 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_commandArg749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_commandArg754 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LSquare_in_indexer772 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _commaValue_in_indexer774 = new BitSet(new ulong[]{0x18UL});
		public static readonly BitSet _ARG_in_commaValue789 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _commaArg_in_commaValue791 = new BitSet(new ulong[]{0xFFFFFFFFFFFDFFF8UL,0x7FFF7FFFUL});
		public static readonly BitSet _ID_in_lineArg805 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_lineArg810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _math_in_lineArg815 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_lineArg820 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CodeBlock_in_codeBlock834 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_codeBlock836 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400800UL});
		public static readonly BitSet _command_in_expression850 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declareVariable_in_expression852 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preProcessor_in_expression854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclare_in_expression860 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_expression862 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doStatement_in_expression869 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_expression871 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_expression873 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_expression875 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _codeBlock_in_expression877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DeclareVariable_in_declareVariable890 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Scope_in_declareVariable892 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_declareVariable897 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _indexer_in_declareVariable899 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_declareVariable903 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Assign_in_declareVariable908 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _lineArg_in_declareVariable910 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFFFFEUL});
		public static readonly BitSet _include_in_preProcessor929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _define_in_preProcessor934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _macro_in_preProcessor939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _preIf_in_preProcessor944 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifDef_in_preProcessor949 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifNDef_in_preProcessor954 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _echo_in_preProcessor959 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _error_in_preProcessor964 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unmac_in_preProcessor969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Include_in_include982 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _string_in_include984 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Define_in_define1001 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_define1008 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _INT_in_define1014 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _string_in_define1020 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _FLOAT_in_define1026 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _dataSequence_in_define1032 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _command_in_define1038 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _condition_in_define1044 = new BitSet(new ulong[]{0x8000182002082808UL,0x40000UL});
		public static readonly BitSet _Negate_in_condition1067 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_condition1069 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _orCondition_in_condition1072 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _andCondition_in_condition1075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONDITION_in_condition1082 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _conditionValue_in_condition1084 = new BitSet(new ulong[]{0x28UL,0x10UL});
		public static readonly BitSet _orCondition_in_condition1086 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _andCondition_in_condition1089 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CONDITION_in_condition1097 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Comparer_in_condition1100 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _conditionValue_in_condition1102 = new BitSet(new ulong[]{0xFFF7FFFFFFFBFFF0UL,0x7FFFBFFEUL});
		public static readonly BitSet _conditionValue_in_condition1104 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _orCondition_in_condition1107 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _andCondition_in_condition1110 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CONDITION_in_condition1118 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _orCondition_in_condition1120 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _andCondition_in_condition1123 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1138 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_conditionValue1140 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1147 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _dataSequence_in_conditionValue1149 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1156 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _string_in_conditionValue1158 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1165 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INT_in_conditionValue1167 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1174 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FLOAT_in_conditionValue1176 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1183 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _MATH_in_conditionValue1186 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_conditionValue1188 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Negate_in_conditionValue1196 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _conditionString_in_conditionValue1198 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_conditionValue1204 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dataSequence_in_conditionValue1209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_conditionValue1214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_conditionValue1219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_conditionValue1224 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MATH_in_conditionValue1230 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _math_in_conditionValue1232 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _conditionString_in_conditionValue1238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Or_in_orCondition1272 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_orCondition1274 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _And_in_andCondition1288 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_andCondition1290 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Macro_in_macro1304 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_macro1306 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _Params_in_macro1309 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _params_in_macro1311 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _expression_in_macro1314 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400800UL});
		public static readonly BitSet _PreIf_in_preIf1329 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_preIf1331 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400A00UL});
		public static readonly BitSet _expression_in_preIf1333 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400A00UL});
		public static readonly BitSet _preElseIf_in_preIf1336 = new BitSet(new ulong[]{0x8UL,0x200UL});
		public static readonly BitSet _preElse_in_preIf1339 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PreElse_in_preElseIf1354 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_preElseIf1356 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400800UL});
		public static readonly BitSet _expression_in_preElseIf1358 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400800UL});
		public static readonly BitSet _PreElse_in_preElse1373 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_preElse1375 = new BitSet(new ulong[]{0x201E05021588808UL,0x26400800UL});
		public static readonly BitSet _IfDef_in_ifDef1390 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_ifDef1392 = new BitSet(new ulong[]{0x8UL,0x200UL});
		public static readonly BitSet _preElse_in_ifDef1394 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IfNDef_in_ifNDef1409 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_ifNDef1411 = new BitSet(new ulong[]{0x8UL,0x200UL});
		public static readonly BitSet _preElse_in_ifNDef1413 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Echo_in_echo1428 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _lineArg_in_echo1430 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFFFFEUL});
		public static readonly BitSet _Error_in_error1445 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _lineArg_in_error1447 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFFFFEUL});
		public static readonly BitSet _Unmac_in_unmac1462 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_unmac1464 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _For_in_forStatement1478 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _command_in_forStatement1480 = new BitSet(new ulong[]{0x8000000000002000UL});
		public static readonly BitSet _condition_in_forStatement1482 = new BitSet(new ulong[]{0x80800UL});
		public static readonly BitSet _command_in_forStatement1484 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Do_in_doStatement1498 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_doStatement1500 = new BitSet(new ulong[]{0x8000000000002000UL});
		public static readonly BitSet _condition_in_doStatement1502 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _While_in_whileStatement1516 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_whileStatement1518 = new BitSet(new ulong[]{0x201E05021588800UL,0x26400800UL});
		public static readonly BitSet _expression_in_whileStatement1520 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _If_in_ifStatement1534 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_ifStatement1536 = new BitSet(new ulong[]{0x201E05021588800UL,0x26400800UL});
		public static readonly BitSet _expression_in_ifStatement1538 = new BitSet(new ulong[]{0x180000008UL});
		public static readonly BitSet _ElseIf_in_ifStatement1542 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _condition_in_ifStatement1544 = new BitSet(new ulong[]{0x201E05021588800UL,0x26400800UL});
		public static readonly BitSet _expression_in_ifStatement1546 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Else_in_ifStatement1553 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_ifStatement1555 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Switch_in_switchStatement1572 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Param_in_switchStatement1575 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _lineArg_in_switchStatement1577 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFFFFEUL});
		public static readonly BitSet _switchCase_in_switchStatement1581 = new BitSet(new ulong[]{0x204008UL,0x8000000UL});
		public static readonly BitSet _defaultCase_in_switchStatement1584 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Case_in_switchCase1599 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _Param_in_switchCase1602 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _lineArg_in_switchCase1604 = new BitSet(new ulong[]{0xFFFFFFFFFFFFFFF8UL,0x7FFFFFFEUL});
		public static readonly BitSet _expression_in_switchCase1608 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _VariableCase_in_switchCase1615 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _dataSequence_in_switchCase1617 = new BitSet(new ulong[]{0x201E05021588800UL,0x26400800UL});
		public static readonly BitSet _expression_in_switchCase1619 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _Default_in_defaultCase1633 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_defaultCase1635 = new BitSet(new ulong[]{0x8UL});
	}
	#endregion Follow sets
}
